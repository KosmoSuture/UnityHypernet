{
  "address": "0.4.0.0.1.4",
  "type_address": null,
  "data": {
    "name": "0.0.1.4-NOTIFICATION.md",
    "type": "file",
    "extension": ".md",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.4 - Object Type Registry\\0.0.1 - Core Types\\0.0.1.4-NOTIFICATION.md",
    "size": 36287,
    "content": "# NOTIFICATION - User Notification Object Type\n\n**Type ID:** `hypernet.core.notification`\n**Version:** 1.0\n**Category:** 0.0.1 - Core Types\n**Parent:** BaseObject\n**Status:** Active\n**Created:** 2026-02-09\n**Last Updated:** 2026-02-09\n\n---\n\n## Object Type Metadata\n\n```yaml\ntype_name: \"Notification\"\ntype_id: \"hypernet.core.notification\"\nversion: \"1.0\"\nparent_type: \"BaseObject\"\ncategory: \"0.0.1 - Core Types\"\nabstract: false\ninstantiable: true\n```\n\n---\n\n## Purpose and Description\n\n### What is a Notification?\n\nA Notification is a message to a user about an event, status change, or action that requires their attention. Notifications inform users about sync progress, integration errors, AI discoveries, system updates, and user actions. They are the primary communication channel between Hypernet and its users.\n\n### Core Functions\n\n1. **User Communication** - Alert users to important events and status changes\n2. **Integration Status** - Report sync progress, errors, and completions\n3. **AI Insights** - Share AI discoveries, recommendations, and analysis\n4. **System Updates** - Announce new features, maintenance, security issues\n5. **Action Prompts** - Request user decisions or confirmations\n6. **Audit Trail** - Record of all communications to user\n\n### Why This Matters\n\nWithout a unified notification system:\n- Users miss important events (sync failures, quota limits)\n- Integration errors go unnoticed\n- AI insights are lost\n- User experience is fragmented across channels\n\nWith Notifications, Hypernet provides:\n- Centralized communication hub\n- Multi-channel delivery (in-app, email, push)\n- Priority and category management\n- Read/unread tracking\n- Action links and deep links\n\n### When to Use\n\n- Integration sync completes or fails\n- AI discovers duplicates or relationships\n- Storage quota approaching limit\n- Security alert (new login, password change)\n- Feature announcement\n- Collaboration invitation\n- Any event requiring user awareness\n\n---\n\n## Inherited Fields from BaseObject\n\n```yaml\nid: UUID\n  - Unique notification identifier\n\nuser_id: UUID\n  - Recipient of this notification\n  - User who should see this message\n\ncreated_at: DateTime\n  - When notification was created\n  - Used for chronological ordering\n\nupdated_at: DateTime\n  - Last modification timestamp\n  - Updated when read/unread status changes\n\ndeleted_at: DateTime (nullable)\n  - Soft delete for dismissed notifications\n  - Preserves notification history\n\nsource_type: String\n  - What generated this notification\n  - \"system\", \"integration\", \"ai\", \"user\"\n\nsource_id: String\n  - ID of source object (optional)\n  - Integration ID, AI task ID, etc.\n\nmetadata: JSONB\n  - Notification-specific data\n  - Action links, context, formatting\n```\n\n---\n\n## Required Fields\n\n### Notification Content\n\n```yaml\nnotification_type: String(50)\n  type: String\n  max_length: 50\n  nullable: false\n  indexed: true\n  description: \"Type/category of notification\"\n  allowed_values:\n    # Integration Events\n    - \"sync_started\": Sync operation initiated\n    - \"sync_completed\": Sync finished successfully\n    - \"sync_failed\": Sync encountered errors\n    - \"sync_partial\": Sync partially completed\n    - \"integration_connected\": New integration added\n    - \"integration_error\": Integration authentication failed\n    - \"integration_disconnected\": Integration removed\n\n    # AI Events\n    - \"ai_discovery\": AI found duplicates, relationships\n    - \"ai_recommendation\": AI suggests action\n    - \"ai_analysis_complete\": AI analysis finished\n    - \"ai_insight\": AI shares insight about user's data\n\n    # System Events\n    - \"storage_warning\": Approaching storage quota\n    - \"storage_full\": Storage quota exceeded\n    - \"feature_announcement\": New feature available\n    - \"maintenance_scheduled\": Upcoming maintenance\n    - \"system_update\": System upgrade completed\n\n    # Security Events\n    - \"login_new_device\": Login from unrecognized device\n    - \"password_changed\": Password was changed\n    - \"api_key_created\": New API key generated\n    - \"suspicious_activity\": Potential security issue\n\n    # User Events\n    - \"collaboration_invite\": Invited to collaborate\n    - \"share_received\": Someone shared content\n    - \"comment_added\": Comment on user's content\n    - \"mention\": User mentioned in content\n\n    # Account Events\n    - \"welcome\": New user onboarding\n    - \"verification_required\": Email verification needed\n    - \"subscription_expiring\": Subscription renewal due\n    - \"account_suspended\": Account suspended\n  purpose: \"Enable filtering, routing, and priority assignment\"\n\ntitle: String(200)\n  type: String\n  max_length: 200\n  nullable: false\n  description: \"Short notification title/subject\"\n  examples:\n    - \"Instagram Sync Complete\"\n    - \"Storage Quota at 90%\"\n    - \"AI Found 15 Duplicate Photos\"\n    - \"Login from New Device\"\n  constraints:\n    - Minimum 1 character\n    - Maximum 200 characters\n    - Should be concise and actionable\n\nmessage: Text\n  type: Text\n  nullable: false\n  description: \"Full notification message body\"\n  format: \"Plain text or markdown\"\n  examples:\n    - \"Successfully synced 25 new photos from your Instagram account.\"\n    - \"Your storage is at 90% capacity (45 GB of 50 GB used). Consider upgrading or deleting unused files.\"\n    - \"AI detected 15 potential duplicate photos. Review and merge?\"\n  constraints:\n    - Minimum 1 character\n    - Maximum 5000 characters\n    - Should provide context and actionable information\n\npriority: Enum\n  type: String\n  max_length: 20\n  nullable: false\n  indexed: true\n  default: \"normal\"\n  description: \"Urgency level of notification\"\n  allowed_values:\n    - \"low\": Informational, no urgency\n    - \"normal\": Standard notification\n    - \"high\": Important, requires attention\n    - \"urgent\": Critical, immediate action needed\n  examples:\n    - low: Feature announcement, AI insight\n    - normal: Sync completed, new content shared\n    - high: Storage warning, integration error\n    - urgent: Security alert, account suspended\n  purpose: \"Determine notification presentation and delivery\"\n```\n\n---\n\n## Optional Fields\n\n### Status and Tracking\n\n```yaml\nis_read: Boolean\n  type: Boolean\n  nullable: false\n  default: false\n  indexed: true\n  description: \"Whether user has read this notification\"\n  transitions:\n    - false -> true: User opens notification\n    - true -> false: User marks as unread (rare)\n  purpose: \"Show unread badge count, filter unread notifications\"\n\nread_at: DateTime\n  type: DateTime\n  nullable: true\n  timezone: true (UTC)\n  description: \"When user marked notification as read\"\n  updated: \"When is_read changes to true\"\n  purpose: \"Track engagement, calculate read rates\"\n\nis_dismissed: Boolean\n  type: Boolean\n  nullable: false\n  default: false\n  indexed: true\n  description: \"Whether user dismissed this notification\"\n  purpose: \"Hide from notification list without deleting\"\n  note: \"Dismissed notifications still queryable for history\"\n\ndismissed_at: DateTime\n  type: DateTime\n  nullable: true\n  timezone: true (UTC)\n  description: \"When user dismissed notification\"\n```\n\n### Delivery Management\n\n```yaml\ndelivery_channels: JSONB\n  type: JSONB\n  nullable: false\n  default: [\"in_app\"]\n  description: \"Where notification should be delivered\"\n  allowed_values:\n    - \"in_app\": Notification center in Hypernet UI\n    - \"email\": Send email to user\n    - \"push\": Push notification (web/mobile)\n    - \"sms\": SMS message (high priority only)\n    - \"webhook\": Webhook to external service\n  examples:\n    - [\"in_app\"]: Standard notification\n    - [\"in_app\", \"email\"]: Important notification\n    - [\"in_app\", \"email\", \"push\"]: Urgent notification\n  constraints:\n    - Must include at least \"in_app\"\n    - Actual delivery respects user preferences\n\ndelivered_at: JSONB\n  type: JSONB\n  nullable: false\n  default: {}\n  description: \"Delivery timestamps per channel\"\n  structure:\n    {\n      \"in_app\": \"2026-02-09T10:00:00Z\",\n      \"email\": \"2026-02-09T10:01:30Z\",\n      \"push\": \"2026-02-09T10:00:15Z\"\n    }\n  purpose: \"Track delivery status and timing\"\n\ndelivery_errors: JSONB\n  type: JSONB\n  nullable: false\n  default: {}\n  description: \"Errors encountered during delivery\"\n  structure:\n    {\n      \"email\": {\n        \"error\": \"SMTP server unavailable\",\n        \"attempted_at\": \"2026-02-09T10:01:30Z\",\n        \"retry_count\": 2\n      }\n    }\n```\n\n### Action and Context\n\n```yaml\naction_url: String(500)\n  type: String\n  max_length: 500\n  nullable: true\n  description: \"Deep link URL for primary action\"\n  format: \"Absolute or relative URL\"\n  examples:\n    - \"/integrations/integration-uuid\": View integration\n    - \"/media/duplicates\": Review duplicates\n    - \"/settings/storage\": Manage storage\n    - \"https://hypernet.io/feature/xyz\": External link\n  purpose: \"Enable click-through from notification\"\n\naction_label: String(100)\n  type: String\n  max_length: 100\n  nullable: true\n  description: \"Label for primary action button\"\n  examples:\n    - \"View Details\"\n    - \"Review Duplicates\"\n    - \"Upgrade Storage\"\n    - \"Learn More\"\n  constraints:\n    - Required if action_url is set\n\nrelated_object_id: UUID\n  type: UUID\n  nullable: true\n  indexed: true\n  description: \"ID of related object (if applicable)\"\n  examples:\n    - Integration ID for sync notifications\n    - Photo ID for duplicate notifications\n    - User ID for collaboration invites\n  purpose: \"Link notification to relevant object\"\n\nrelated_object_type: String(50)\n  type: String\n  max_length: 50\n  nullable: true\n  indexed: true\n  description: \"Type of related object\"\n  examples:\n    - \"Integration\"\n    - \"Photo\"\n    - \"Album\"\n    - \"User\"\n\nexpires_at: DateTime\n  type: DateTime\n  nullable: true\n  timezone: true (UTC)\n  description: \"When notification should expire and auto-dismiss\"\n  examples:\n    - Feature announcement: 30 days from creation\n    - Sync status: 7 days from creation\n    - Urgent alert: Never expires (null)\n  purpose: \"Auto-cleanup old notifications\"\n```\n\n---\n\n## Metadata Schema\n\nThe `metadata` JSONB field stores notification-specific data:\n\n```json\n{\n  \"sync\": {\n    \"integration_id\": \"integration-uuid\",\n    \"integration_name\": \"My Instagram\",\n    \"integration_type\": \"instagram\",\n    \"items_synced\": 25,\n    \"items_failed\": 0,\n    \"duration_seconds\": 45,\n    \"next_sync_at\": \"2026-02-09T12:00:00Z\"\n  },\n  \"ai_discovery\": {\n    \"discovery_type\": \"duplicates\",\n    \"count\": 15,\n    \"confidence\": 0.95,\n    \"review_url\": \"/media/duplicates\",\n    \"estimated_storage_savings\": \"250 MB\"\n  },\n  \"storage\": {\n    \"used_bytes\": 48318382080,\n    \"quota_bytes\": 53687091200,\n    \"percent_used\": 90,\n    \"growth_rate_mb_per_day\": 50,\n    \"estimated_full_date\": \"2026-03-01\"\n  },\n  \"security\": {\n    \"event_type\": \"login\",\n    \"device\": {\n      \"type\": \"desktop\",\n      \"os\": \"Windows 11\",\n      \"browser\": \"Chrome 122\",\n      \"ip_address\": \"192.168.1.100\",\n      \"location\": \"San Francisco, CA\"\n    },\n    \"is_recognized\": false\n  },\n  \"formatting\": {\n    \"icon\": \"check-circle\",\n    \"color\": \"success\",\n    \"avatar_url\": \"https://...\",\n    \"thumbnail_url\": \"https://...\"\n  },\n  \"actions\": [\n    {\n      \"label\": \"View Integration\",\n      \"url\": \"/integrations/integration-uuid\",\n      \"style\": \"primary\"\n    },\n    {\n      \"label\": \"Dismiss\",\n      \"action\": \"dismiss\",\n      \"style\": \"secondary\"\n    }\n  ],\n  \"analytics\": {\n    \"campaign_id\": \"feature_launch_2026_02\",\n    \"segment\": \"power_users\",\n    \"ab_test_variant\": \"A\"\n  }\n}\n```\n\n---\n\n## Relationships to Other Object Types\n\n### Recipient (Incoming)\n\n```yaml\nreceived_by: User\n  description: \"User who receives this notification\"\n  cardinality: \"N:1 (many notifications, one user)\"\n  implementation: \"user_id foreign key\"\n  constraints:\n    - User must exist\n    - Cannot be null\n\nrelated_to: Any Object Type\n  description: \"Object this notification is about\"\n  cardinality: \"N:0..1 (many notifications, optional object)\"\n  implementation: \"related_object_id + related_object_type\"\n  examples:\n    - Notification about Integration sync\n    - Notification about Photo duplicate\n    - Notification about Album share\n```\n\n---\n\n## API Endpoints\n\n### Notification Management\n\n```http\nGET /api/v1/notifications\n  Description: Get notifications for authenticated user\n  Query Parameters:\n    is_read: boolean - filter by read status\n    is_dismissed: boolean - filter by dismissed status\n    notification_type: string - filter by type\n    priority: string - filter by priority\n    since: datetime - notifications after this time\n    limit: integer (default 50, max 100)\n    offset: integer (default 0)\n  Response: 200 OK\n    {\n      \"items\": [{notification}, {notification}, ...],\n      \"total\": 150,\n      \"unread_count\": 12,\n      \"limit\": 50,\n      \"offset\": 0\n    }\n  Default Behavior:\n    - Excludes dismissed notifications\n    - Excludes expired notifications\n    - Sorted by created_at DESC (newest first)\n\nGET /api/v1/notifications/unread\n  Description: Get only unread notifications\n  Response: 200 OK\n    {\n      \"items\": [{notification}, ...],\n      \"count\": 12\n    }\n  Purpose: Display unread badge count\n\nGET /api/v1/notifications/{id}\n  Description: Get single notification\n  Path Parameters:\n    id: UUID (required) - notification ID\n  Response: 200 OK\n    {notification object}\n  Side Effect:\n    - If is_read=false, marks as read automatically\n  Security:\n    - User must be notification recipient\n\nPATCH /api/v1/notifications/{id}\n  Description: Update notification status\n  Path Parameters:\n    id: UUID (required) - notification ID\n  Request Body:\n    {\n      \"is_read\": true,\n      \"is_dismissed\": true\n    }\n  Response: 200 OK\n    {updated notification object}\n  Validation:\n    - Can only change: is_read, is_dismissed\n    - Cannot change content or metadata\n  Security:\n    - User must be notification recipient\n\nDELETE /api/v1/notifications/{id}\n  Description: Delete notification (soft delete)\n  Path Parameters:\n    id: UUID (required) - notification ID\n  Response: 204 No Content\n  Purpose: Permanent removal from notification list\n  Security:\n    - User must be notification recipient\n```\n\n### Bulk Operations\n\n```http\nPOST /api/v1/notifications/mark-all-read\n  Description: Mark all notifications as read\n  Query Parameters:\n    notification_type: string - only mark specific type\n  Response: 200 OK\n    {\n      \"marked_count\": 12\n    }\n  Purpose: \"Mark all as read\" button\n\nPOST /api/v1/notifications/dismiss-all\n  Description: Dismiss all notifications\n  Query Parameters:\n    notification_type: string - only dismiss specific type\n    before: datetime - only dismiss before this time\n  Response: 200 OK\n    {\n      \"dismissed_count\": 25\n    }\n  Purpose: Clear notification center\n\nDELETE /api/v1/notifications/cleanup\n  Description: Delete all dismissed or expired notifications\n  Response: 200 OK\n    {\n      \"deleted_count\": 50\n    }\n  Purpose: Periodic cleanup of old notifications\n```\n\n### Notification Preferences\n\n```http\nGET /api/v1/users/me/notification-preferences\n  Description: Get user's notification preferences\n  Response: 200 OK\n    {\n      \"channels\": {\n        \"in_app\": true,\n        \"email\": true,\n        \"push\": false,\n        \"sms\": false\n      },\n      \"types\": {\n        \"sync_completed\": [\"in_app\"],\n        \"sync_failed\": [\"in_app\", \"email\"],\n        \"ai_discovery\": [\"in_app\"],\n        \"storage_warning\": [\"in_app\", \"email\"],\n        \"security_alert\": [\"in_app\", \"email\", \"push\"]\n      },\n      \"quiet_hours\": {\n        \"enabled\": true,\n        \"start\": \"22:00\",\n        \"end\": \"08:00\",\n        \"timezone\": \"America/Los_Angeles\"\n      }\n    }\n\nPATCH /api/v1/users/me/notification-preferences\n  Description: Update notification preferences\n  Request Body:\n    {\n      \"channels\": {\n        \"email\": false\n      },\n      \"types\": {\n        \"sync_completed\": [\"in_app\"]\n      }\n    }\n  Response: 200 OK\n    {updated preferences}\n```\n\n### System Operations (Internal/Admin)\n\n```http\nPOST /api/v1/notifications/send\n  Description: Create and send notification (internal)\n  Headers:\n    Authorization: Bearer {system_token}\n  Request Body:\n    {\n      \"user_id\": \"user-uuid\",\n      \"notification_type\": \"sync_completed\",\n      \"title\": \"Instagram Sync Complete\",\n      \"message\": \"Successfully synced 25 new photos.\",\n      \"priority\": \"normal\",\n      \"delivery_channels\": [\"in_app\", \"email\"],\n      \"action_url\": \"/integrations/integration-uuid\",\n      \"action_label\": \"View Details\",\n      \"related_object_id\": \"integration-uuid\",\n      \"related_object_type\": \"Integration\",\n      \"metadata\": {...}\n    }\n  Response: 201 Created\n    {notification object}\n  Purpose: System-generated notifications\n  Security:\n    - Requires system/admin authentication\n\nPOST /api/v1/notifications/broadcast\n  Description: Send notification to multiple users\n  Headers:\n    Authorization: Bearer {admin_token}\n  Request Body:\n    {\n      \"user_ids\": [\"user-1\", \"user-2\", \"user-3\"],\n      \"notification_type\": \"feature_announcement\",\n      \"title\": \"New Feature: AI Duplicate Detection\",\n      \"message\": \"...\",\n      \"priority\": \"low\",\n      \"expires_at\": \"2026-03-09T00:00:00Z\"\n    }\n  Response: 201 Created\n    {\n      \"notifications_created\": 3,\n      \"notification_ids\": [\"notif-1\", \"notif-2\", \"notif-3\"]\n    }\n  Purpose: Broadcast announcements\n  Security:\n    - Admin only\n```\n\n---\n\n## Database Schema (SQLAlchemy Model Reference)\n\n```python\nfrom sqlalchemy import (\n    Column, String, Boolean, Text,\n    DateTime, Enum as SQLEnum, ForeignKey, Index, CheckConstraint\n)\nfrom sqlalchemy.dialects.postgresql import UUID, JSONB, ARRAY\nfrom sqlalchemy.orm import relationship\nfrom app.models.base import BaseObject\nfrom datetime import datetime\n\nclass Notification(BaseObject):\n    \"\"\"\n    User notification about events, status, or actions\n\n    Inherits from BaseObject: id, user_id, created_at, updated_at,\n    deleted_at, source_type, source_id, metadata\n    \"\"\"\n\n    __tablename__ = \"notifications\"\n\n    # Notification Content\n    notification_type = Column(\n        String(50),\n        nullable=False,\n        index=True,\n        doc=\"Type/category of notification\"\n    )\n    title = Column(\n        String(200),\n        nullable=False,\n        doc=\"Short notification title\"\n    )\n    message = Column(\n        Text,\n        nullable=False,\n        doc=\"Full notification message body\"\n    )\n    priority = Column(\n        SQLEnum('low', 'normal', 'high', 'urgent', name='notification_priority_enum'),\n        nullable=False,\n        default='normal',\n        index=True,\n        doc=\"Urgency level\"\n    )\n\n    # Status and Tracking\n    is_read = Column(\n        Boolean,\n        nullable=False,\n        default=False,\n        index=True,\n        doc=\"Whether user has read this\"\n    )\n    read_at = Column(\n        DateTime(timezone=True),\n        nullable=True,\n        doc=\"When marked as read\"\n    )\n    is_dismissed = Column(\n        Boolean,\n        nullable=False,\n        default=False,\n        index=True,\n        doc=\"Whether user dismissed this\"\n    )\n    dismissed_at = Column(\n        DateTime(timezone=True),\n        nullable=True,\n        doc=\"When dismissed\"\n    )\n\n    # Delivery Management\n    delivery_channels = Column(\n        JSONB,\n        nullable=False,\n        default=[\"in_app\"],\n        doc=\"Where to deliver notification\"\n    )\n    delivered_at = Column(\n        JSONB,\n        nullable=False,\n        default={},\n        doc=\"Delivery timestamps per channel\"\n    )\n    delivery_errors = Column(\n        JSONB,\n        nullable=False,\n        default={},\n        doc=\"Delivery errors per channel\"\n    )\n\n    # Action and Context\n    action_url = Column(\n        String(500),\n        nullable=True,\n        doc=\"Deep link URL for action\"\n    )\n    action_label = Column(\n        String(100),\n        nullable=True,\n        doc=\"Label for action button\"\n    )\n    related_object_id = Column(\n        UUID(as_uuid=True),\n        nullable=True,\n        index=True,\n        doc=\"ID of related object\"\n    )\n    related_object_type = Column(\n        String(50),\n        nullable=True,\n        index=True,\n        doc=\"Type of related object\"\n    )\n    expires_at = Column(\n        DateTime(timezone=True),\n        nullable=True,\n        index=True,\n        doc=\"When notification expires\"\n    )\n\n    # Relationships\n    recipient = relationship(\n        \"User\",\n        foreign_keys=[BaseObject.user_id],\n        back_populates=\"notifications\",\n        doc=\"User who receives this notification\"\n    )\n\n    # Table Constraints\n    __table_args__ = (\n        # action_label required if action_url set\n        CheckConstraint(\n            \"action_url IS NULL OR action_label IS NOT NULL\",\n            name=\"check_action_label_with_url\"\n        ),\n        # Composite indexes\n        Index('idx_notification_user_read', 'user_id', 'is_read', 'created_at'),\n        Index('idx_notification_user_type', 'user_id', 'notification_type'),\n        Index('idx_notification_unread', 'user_id', 'is_read', 'priority',\n              postgresql_where=\"is_read = false AND is_dismissed = false\"),\n        Index('idx_notification_expired', 'expires_at',\n              postgresql_where=\"expires_at IS NOT NULL\"),\n        Index('idx_notification_related', 'related_object_id', 'related_object_type'),\n    )\n\n    def __repr__(self):\n        return f\"<Notification(id={self.id}, type={self.notification_type}, \" \\\n               f\"user={self.user_id}, read={self.is_read})>\"\n\n    @property\n    def is_expired(self):\n        \"\"\"Check if notification has expired\"\"\"\n        if not self.expires_at:\n            return False\n        return datetime.utcnow() >= self.expires_at\n\n    @property\n    def is_active(self):\n        \"\"\"Check if notification is active (not dismissed, not expired)\"\"\"\n        return not self.is_dismissed and not self.is_expired\n\n    def mark_as_read(self):\n        \"\"\"Mark notification as read\"\"\"\n        if not self.is_read:\n            self.is_read = True\n            self.read_at = datetime.utcnow()\n            self.updated_at = datetime.utcnow()\n\n    def mark_as_unread(self):\n        \"\"\"Mark notification as unread\"\"\"\n        if self.is_read:\n            self.is_read = False\n            self.read_at = None\n            self.updated_at = datetime.utcnow()\n\n    def dismiss(self):\n        \"\"\"Dismiss notification\"\"\"\n        if not self.is_dismissed:\n            self.is_dismissed = True\n            self.dismissed_at = datetime.utcnow()\n            self.updated_at = datetime.utcnow()\n\n    def record_delivery(self, channel: str, success: bool, error: str = None):\n        \"\"\"Record delivery attempt\"\"\"\n        if success:\n            self.delivered_at[channel] = datetime.utcnow().isoformat()\n        else:\n            self.delivery_errors[channel] = {\n                'error': error,\n                'attempted_at': datetime.utcnow().isoformat()\n            }\n        self.updated_at = datetime.utcnow()\n\n    @classmethod\n    def create_notification(cls, user_id, notification_type, title, message,\n                           priority='normal', **kwargs):\n        \"\"\"Factory method for creating notifications\"\"\"\n        return cls(\n            user_id=user_id,\n            notification_type=notification_type,\n            title=title,\n            message=message,\n            priority=priority,\n            source_type=kwargs.pop('source_type', 'system'),\n            **kwargs\n        )\n```\n\n---\n\n## Privacy and Security Considerations\n\n### Access Control\n\n1. **Notification Visibility**\n   - Users can only see their own notifications\n   - Admin cannot read user notifications (privacy)\n   - System can create notifications for any user\n\n2. **Sensitive Information**\n   - Don't include passwords or tokens in messages\n   - Don't expose other users' data\n   - Careful with error messages (no system internals)\n\n3. **Delivery Security**\n   - Email delivery uses TLS\n   - Push notifications encrypted\n   - Webhook deliveries signed\n\n### Data Protection\n\n1. **Personal Information**\n   - Notifications may contain PII\n   - Respect user's notification preferences\n   - Allow opt-out of all non-critical notifications\n\n2. **Retention**\n   - Auto-expire old notifications\n   - User can delete notification history\n   - Dismissed notifications eligible for cleanup\n\n---\n\n## Validation Rules\n\n### On Creation\n\n```yaml\nuser_id:\n  - Must reference existing User\n  - Cannot be null\n\nnotification_type:\n  - Must be in allowed list\n  - Maximum 50 characters\n\ntitle:\n  - Minimum 1 character\n  - Maximum 200 characters\n\nmessage:\n  - Minimum 1 character\n  - Maximum 5000 characters\n\npriority:\n  - Must be: low, normal, high, urgent\n  - Defaults to normal\n\ndelivery_channels:\n  - Must include at least \"in_app\"\n  - Must be array of valid channel names\n\naction_url and action_label:\n  - If action_url set, action_label required\n  - action_url maximum 500 characters\n  - action_label maximum 100 characters\n```\n\n### Database Constraints\n\n```sql\n-- Check constraints\nCHECK (action_url IS NULL OR action_label IS NOT NULL)\nCHECK (LENGTH(title) > 0 AND LENGTH(title) <= 200)\nCHECK (LENGTH(message) > 0)\n\n-- Indexes\nCREATE INDEX idx_notification_user_read ON notifications(user_id, is_read, created_at);\nCREATE INDEX idx_notification_unread ON notifications(user_id, is_read, priority)\n  WHERE is_read = false AND is_dismissed = false;\nCREATE INDEX idx_notification_expired ON notifications(expires_at)\n  WHERE expires_at IS NOT NULL;\nCREATE INDEX idx_notification_related ON notifications(related_object_id, related_object_type);\n```\n\n---\n\n## Use Cases and Examples\n\n### Example 1: Sync Completion Notification\n\n```json\n{\n  \"id\": \"notif-550e8400-e29b-41d4-a716-446655440000\",\n  \"user_id\": \"user-123-uuid\",\n  \"notification_type\": \"sync_completed\",\n  \"title\": \"Instagram Sync Complete\",\n  \"message\": \"Successfully synced 25 new photos from your Instagram account 'My Personal Instagram'. All photos are now available in your Hypernet library.\",\n  \"priority\": \"normal\",\n  \"is_read\": false,\n  \"read_at\": null,\n  \"is_dismissed\": false,\n  \"dismissed_at\": null,\n  \"delivery_channels\": [\"in_app\"],\n  \"delivered_at\": {\n    \"in_app\": \"2026-02-09T10:00:00Z\"\n  },\n  \"delivery_errors\": {},\n  \"action_url\": \"/integrations/integration-uuid\",\n  \"action_label\": \"View Integration\",\n  \"related_object_id\": \"integration-uuid\",\n  \"related_object_type\": \"Integration\",\n  \"expires_at\": \"2026-02-16T10:00:00Z\",\n  \"metadata\": {\n    \"sync\": {\n      \"integration_name\": \"My Personal Instagram\",\n      \"integration_type\": \"instagram\",\n      \"items_synced\": 25,\n      \"duration_seconds\": 45\n    }\n  },\n  \"source_type\": \"integration\",\n  \"source_id\": \"integration-uuid\",\n  \"created_at\": \"2026-02-09T10:00:00Z\",\n  \"updated_at\": \"2026-02-09T10:00:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 2: Storage Warning (High Priority)\n\n```json\n{\n  \"id\": \"notif-550e8400-e29b-41d4-a716-446655440001\",\n  \"user_id\": \"user-123-uuid\",\n  \"notification_type\": \"storage_warning\",\n  \"title\": \"Storage Quota at 90%\",\n  \"message\": \"You're using 45 GB of your 50 GB storage quota (90%). At your current rate, you'll reach your limit in about 10 days. Consider upgrading your plan or managing your storage.\",\n  \"priority\": \"high\",\n  \"is_read\": false,\n  \"is_dismissed\": false,\n  \"delivery_channels\": [\"in_app\", \"email\"],\n  \"delivered_at\": {\n    \"in_app\": \"2026-02-09T10:00:00Z\",\n    \"email\": \"2026-02-09T10:01:15Z\"\n  },\n  \"action_url\": \"/settings/storage\",\n  \"action_label\": \"Manage Storage\",\n  \"expires_at\": null,\n  \"metadata\": {\n    \"storage\": {\n      \"used_bytes\": 48318382080,\n      \"quota_bytes\": 53687091200,\n      \"percent_used\": 90,\n      \"estimated_full_date\": \"2026-02-19\"\n    }\n  },\n  \"source_type\": \"system\",\n  \"created_at\": \"2026-02-09T10:00:00Z\",\n  \"updated_at\": \"2026-02-09T10:01:15Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 3: AI Discovery Notification\n\n```json\n{\n  \"id\": \"notif-550e8400-e29b-41d4-a716-446655440002\",\n  \"user_id\": \"user-123-uuid\",\n  \"notification_type\": \"ai_discovery\",\n  \"title\": \"AI Found 15 Duplicate Photos\",\n  \"message\": \"AI analyzed your photo library and discovered 15 potential duplicate photos. Reviewing and merging these duplicates could free up approximately 250 MB of storage.\",\n  \"priority\": \"low\",\n  \"is_read\": false,\n  \"is_dismissed\": false,\n  \"delivery_channels\": [\"in_app\"],\n  \"delivered_at\": {\n    \"in_app\": \"2026-02-09T11:00:00Z\"\n  },\n  \"action_url\": \"/media/duplicates\",\n  \"action_label\": \"Review Duplicates\",\n  \"expires_at\": \"2026-03-09T00:00:00Z\",\n  \"metadata\": {\n    \"ai_discovery\": {\n      \"discovery_type\": \"duplicates\",\n      \"count\": 15,\n      \"confidence\": 0.95,\n      \"estimated_storage_savings\": \"250 MB\"\n    }\n  },\n  \"source_type\": \"ai\",\n  \"created_at\": \"2026-02-09T11:00:00Z\",\n  \"updated_at\": \"2026-02-09T11:00:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 4: Security Alert (Urgent)\n\n```json\n{\n  \"id\": \"notif-550e8400-e29b-41d4-a716-446655440003\",\n  \"user_id\": \"user-123-uuid\",\n  \"notification_type\": \"login_new_device\",\n  \"title\": \"New Device Login Detected\",\n  \"message\": \"Your account was accessed from a new device: Windows 11 desktop using Chrome from San Francisco, CA. If this wasn't you, please secure your account immediately.\",\n  \"priority\": \"urgent\",\n  \"is_read\": false,\n  \"is_dismissed\": false,\n  \"delivery_channels\": [\"in_app\", \"email\", \"push\"],\n  \"delivered_at\": {\n    \"in_app\": \"2026-02-09T14:00:00Z\",\n    \"email\": \"2026-02-09T14:00:30Z\",\n    \"push\": \"2026-02-09T14:00:10Z\"\n  },\n  \"action_url\": \"/settings/security\",\n  \"action_label\": \"Review Activity\",\n  \"expires_at\": null,\n  \"metadata\": {\n    \"security\": {\n      \"event_type\": \"login\",\n      \"device\": {\n        \"type\": \"desktop\",\n        \"os\": \"Windows 11\",\n        \"browser\": \"Chrome 122\",\n        \"ip_address\": \"192.168.1.100\",\n        \"location\": \"San Francisco, CA\"\n      },\n      \"is_recognized\": false\n    }\n  },\n  \"source_type\": \"system\",\n  \"created_at\": \"2026-02-09T14:00:00Z\",\n  \"updated_at\": \"2026-02-09T14:00:30Z\",\n  \"deleted_at\": null\n}\n```\n\n---\n\n## Lifecycle States\n\nNotifications have a simple lifecycle:\n\n### 1. Unread (Initial State)\n\n```yaml\nstate: \"unread\"\nis_read: false\nis_dismissed: false\ncapabilities:\n  - Shows in notification center with badge\n  - Can be marked as read\n  - Can be dismissed\ntransitions:\n  - open -> Read\n  - dismiss -> Dismissed\n```\n\n### 2. Read\n\n```yaml\nstate: \"read\"\nis_read: true\nis_dismissed: false\ncapabilities:\n  - Shows in notification center (no badge)\n  - Can be marked as unread\n  - Can be dismissed\ntransitions:\n  - mark_unread -> Unread\n  - dismiss -> Dismissed\n```\n\n### 3. Dismissed\n\n```yaml\nstate: \"dismissed\"\nis_dismissed: true\ncapabilities:\n  - Hidden from notification center\n  - Still queryable in history\n  - Can be deleted\ntransitions:\n  - delete -> Deleted\n```\n\n### 4. Expired\n\n```yaml\nstate: \"expired\"\nexpires_at: past\ncapabilities:\n  - Auto-dismissed if not already read\n  - Hidden from notification center\n  - Eligible for cleanup\ntransitions:\n  - cleanup -> Deleted\n```\n\n### 5. Deleted\n\n```yaml\nstate: \"deleted\"\ndeleted_at: not null\ncapabilities:\n  - Soft deleted\n  - Excluded from all queries\n  - Can be hard deleted\n```\n\n---\n\n## Notes for Implementers\n\n### Notification Delivery Service\n\n```python\nclass NotificationService:\n    \"\"\"Service for creating and delivering notifications\"\"\"\n\n    async def send_notification(self, user_id: UUID, notification_type: str,\n                                title: str, message: str, **kwargs):\n        \"\"\"Create and deliver notification\"\"\"\n        # Create notification\n        notification = Notification.create_notification(\n            user_id=user_id,\n            notification_type=notification_type,\n            title=title,\n            message=message,\n            **kwargs\n        )\n        session.add(notification)\n        session.commit()\n\n        # Get user preferences\n        preferences = get_user_notification_preferences(user_id)\n\n        # Determine delivery channels\n        channels = self._determine_channels(\n            notification.priority,\n            notification_type,\n            preferences\n        )\n\n        # Deliver to each channel\n        for channel in channels:\n            try:\n                await self._deliver_to_channel(notification, channel)\n                notification.record_delivery(channel, success=True)\n            except Exception as e:\n                notification.record_delivery(channel, success=False, error=str(e))\n\n        session.commit()\n        return notification\n\n    async def _deliver_to_channel(self, notification: Notification, channel: str):\n        \"\"\"Deliver notification to specific channel\"\"\"\n        if channel == 'in_app':\n            # Already in database, just flag\n            pass\n        elif channel == 'email':\n            await send_email(\n                to=notification.recipient.email,\n                subject=notification.title,\n                body=notification.message,\n                action_url=notification.action_url\n            )\n        elif channel == 'push':\n            await send_push_notification(\n                user_id=notification.user_id,\n                title=notification.title,\n                body=notification.message,\n                data={'notification_id': str(notification.id)}\n            )\n\n    def _determine_channels(self, priority: str, notification_type: str,\n                          preferences: dict) -> list:\n        \"\"\"Determine delivery channels based on priority and preferences\"\"\"\n        # Always include in-app\n        channels = ['in_app']\n\n        # Check user preferences\n        type_prefs = preferences.get('types', {}).get(notification_type, [])\n\n        # High and urgent priorities force email\n        if priority in ['high', 'urgent']:\n            channels.append('email')\n            if priority == 'urgent':\n                channels.append('push')\n\n        # Add user-preferred channels\n        for channel in type_prefs:\n            if channel not in channels and preferences.get('channels', {}).get(channel, False):\n                channels.append(channel)\n\n        return channels\n```\n\n### Background Jobs\n\n```python\n# Cleanup expired notifications\n@scheduler.task('cron', hour='2', minute='0')\nasync def cleanup_expired_notifications():\n    \"\"\"Auto-dismiss expired notifications\"\"\"\n    expired = session.query(Notification).filter(\n        Notification.expires_at < datetime.utcnow(),\n        Notification.is_dismissed == False\n    ).all()\n\n    for notification in expired:\n        notification.dismiss()\n\n    session.commit()\n    print(f\"Dismissed {len(expired)} expired notifications\")\n\n# Delete old dismissed notifications (30 days)\n@scheduler.task('cron', hour='3', minute='0')\nasync def delete_old_notifications():\n    \"\"\"Hard delete old dismissed notifications\"\"\"\n    threshold = datetime.utcnow() - timedelta(days=30)\n\n    deleted_count = session.query(Notification).filter(\n        Notification.is_dismissed == True,\n        Notification.dismissed_at < threshold\n    ).delete()\n\n    session.commit()\n    print(f\"Deleted {deleted_count} old notifications\")\n```\n\n---\n\n**Status:** Active\n**Version:** 1.0\n**Authority:** 0.0.1 - Core Types\n**Created:** 2026-02-09\n**Owner:** Hypernet Core (0.*)\n"
  },
  "created_at": "2026-02-15T11:54:04.622115+00:00",
  "updated_at": "2026-02-15T11:54:04.622115+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:0.0.1.4-NOTIFICATION.md"
}