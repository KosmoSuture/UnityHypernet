{
  "address": "0.1.1.4.5.7",
  "type_address": null,
  "data": {
    "name": "emails.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\routes\\emails.py",
    "size": 9552,
    "content": "\"\"\"\nEmails Routes\n\nEndpoints for managing email messages.\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.user import User\nfrom app.models.email import Email\n\nrouter = APIRouter()\n\n\n# Request/Response Models\nclass EmailCreate(BaseModel):\n    \"\"\"Email creation request\"\"\"\n    subject: str = Field(..., max_length=500)\n    from_address: str = Field(..., max_length=255)\n    to_addresses: List[str]\n    cc_addresses: Optional[List[str]] = None\n    bcc_addresses: Optional[List[str]] = None\n    sent_at: datetime\n    direction: str = Field(..., description=\"sent, received, draft\")\n    body_text: Optional[str] = None\n    body_html: Optional[str] = None\n    thread_id: Optional[str] = Field(None, max_length=255)\n    message_id: Optional[str] = Field(None, max_length=255)\n    has_attachments: bool = Field(default=False)\n    is_read: bool = Field(default=False)\n    is_starred: bool = Field(default=False)\n\n\nclass EmailUpdate(BaseModel):\n    \"\"\"Email update request\"\"\"\n    is_read: Optional[bool] = None\n    is_starred: Optional[bool] = None\n\n\nclass EmailResponse(BaseModel):\n    \"\"\"Email response\"\"\"\n    id: str\n    user_id: str\n    subject: str\n    from_address: str\n    to_addresses: List[str]\n    cc_addresses: Optional[List[str]]\n    bcc_addresses: Optional[List[str]]\n    sent_at: datetime\n    direction: str\n    body_text: Optional[str]\n    body_html: Optional[str]\n    thread_id: Optional[str]\n    message_id: Optional[str]\n    has_attachments: bool\n    is_read: bool\n    is_starred: bool\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n\n\nclass EmailListResponse(BaseModel):\n    \"\"\"Paginated email list response\"\"\"\n    items: List[EmailResponse]\n    total: int\n    page: int\n    page_size: int\n\n\n@router.post(\"\", response_model=EmailResponse, status_code=status.HTTP_201_CREATED)\nasync def create_email(\n    request: EmailCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email record.\n\n    Typically used when importing emails from email providers.\n\n    - **subject**: Email subject (required)\n    - **from_address**: Sender email address (required)\n    - **to_addresses**: Recipient email addresses (required)\n    - **sent_at**: When email was sent (required)\n    - **direction**: sent, received, or draft (required)\n    \"\"\"\n    email = Email(\n        user_id=current_user.id,\n        subject=request.subject,\n        from_address=request.from_address,\n        to_addresses=request.to_addresses,\n        cc_addresses=request.cc_addresses,\n        bcc_addresses=request.bcc_addresses,\n        sent_at=request.sent_at,\n        direction=request.direction,\n        body_text=request.body_text,\n        body_html=request.body_html,\n        thread_id=request.thread_id,\n        message_id=request.message_id,\n        has_attachments=request.has_attachments,\n        is_read=request.is_read,\n        is_starred=request.is_starred\n    )\n\n    db.add(email)\n    db.commit()\n    db.refresh(email)\n\n    return EmailResponse.model_validate(email)\n\n\n@router.get(\"\", response_model=EmailListResponse)\nasync def list_emails(\n    direction: Optional[str] = Query(None, description=\"Filter by direction: sent, received, draft\"),\n    is_read: Optional[bool] = Query(None, description=\"Filter by read status\"),\n    is_starred: Optional[bool] = Query(None, description=\"Filter starred emails\"),\n    has_attachments: Optional[bool] = Query(None, description=\"Filter emails with attachments\"),\n    thread_id: Optional[str] = Query(None, description=\"Filter by thread ID\"),\n    search: Optional[str] = Query(None, description=\"Search in subject, from, to, body\"),\n    page: int = Query(1, ge=1),\n    page_size: int = Query(50, ge=1, le=100),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List emails for the current user.\n\n    Supports:\n    - Filter by direction (sent, received, draft)\n    - Filter by read status\n    - Filter starred emails\n    - Filter emails with attachments\n    - Filter by thread ID\n    - Full-text search\n    - Pagination\n\n    Results ordered by sent_at descending (newest first).\n    \"\"\"\n    query = db.query(Email).filter(\n        and_(\n            Email.user_id == current_user.id,\n            Email.deleted_at.is_(None)\n        )\n    )\n\n    if direction:\n        query = query.filter(Email.direction == direction)\n\n    if is_read is not None:\n        query = query.filter(Email.is_read == is_read)\n\n    if is_starred is not None:\n        query = query.filter(Email.is_starred == is_starred)\n\n    if has_attachments is not None:\n        query = query.filter(Email.has_attachments == has_attachments)\n\n    if thread_id:\n        query = query.filter(Email.thread_id == thread_id)\n\n    if search:\n        search_pattern = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Email.subject.ilike(search_pattern),\n                Email.from_address.ilike(search_pattern),\n                Email.body_text.ilike(search_pattern)\n            )\n        )\n\n    total = query.count()\n\n    offset = (page - 1) * page_size\n    items = query.order_by(Email.sent_at.desc()).offset(offset).limit(page_size).all()\n\n    return EmailListResponse(\n        items=[EmailResponse.model_validate(item) for item in items],\n        total=total,\n        page=page,\n        page_size=page_size\n    )\n\n\n@router.get(\"/{email_id}\", response_model=EmailResponse)\nasync def get_email(\n    email_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get a specific email by ID.\"\"\"\n    email = db.query(Email).filter(\n        and_(\n            Email.id == email_id,\n            Email.user_id == current_user.id,\n            Email.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not email:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Email not found\"\n        )\n\n    return EmailResponse.model_validate(email)\n\n\n@router.patch(\"/{email_id}\", response_model=EmailResponse)\nasync def update_email(\n    email_id: UUID,\n    request: EmailUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update email metadata.\n\n    Can update read status and starred status.\n    \"\"\"\n    email = db.query(Email).filter(\n        and_(\n            Email.id == email_id,\n            Email.user_id == current_user.id,\n            Email.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not email:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Email not found\"\n        )\n\n    if request.is_read is not None:\n        email.is_read = request.is_read\n    if request.is_starred is not None:\n        email.is_starred = request.is_starred\n\n    db.commit()\n    db.refresh(email)\n\n    return EmailResponse.model_validate(email)\n\n\n@router.post(\"/{email_id}/mark-read\", response_model=EmailResponse)\nasync def mark_email_read(\n    email_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Mark an email as read.\"\"\"\n    email = db.query(Email).filter(\n        and_(\n            Email.id == email_id,\n            Email.user_id == current_user.id,\n            Email.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not email:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Email not found\"\n        )\n\n    email.is_read = True\n    db.commit()\n    db.refresh(email)\n\n    return EmailResponse.model_validate(email)\n\n\n@router.post(\"/{email_id}/mark-unread\", response_model=EmailResponse)\nasync def mark_email_unread(\n    email_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Mark an email as unread.\"\"\"\n    email = db.query(Email).filter(\n        and_(\n            Email.id == email_id,\n            Email.user_id == current_user.id,\n            Email.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not email:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Email not found\"\n        )\n\n    email.is_read = False\n    db.commit()\n    db.refresh(email)\n\n    return EmailResponse.model_validate(email)\n\n\n@router.delete(\"/{email_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_email(\n    email_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Soft delete an email.\"\"\"\n    email = db.query(Email).filter(\n        and_(\n            Email.id == email_id,\n            Email.user_id == current_user.id,\n            Email.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not email:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Email not found\"\n        )\n\n    email.soft_delete()\n    db.commit()\n\n    return None\n"
  },
  "created_at": "2026-02-15T11:53:48.515128+00:00",
  "updated_at": "2026-02-15T11:53:48.515128+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:emails.py"
}