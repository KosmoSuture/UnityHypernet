{
  "address": "0.1.1.4.4.9",
  "type_address": null,
  "data": {
    "name": "link.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\models\\link.py",
    "size": 4518,
    "content": "\"\"\"\nLink Model\n\nSQLAlchemy model for the links table (first-class relationships between objects).\n\nImplements: 0.0.1 - Core Types / Link.md\n\"\"\"\n\nfrom sqlalchemy import Column, String, Integer, Float, Boolean, CheckConstraint, Index\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import relationship\n\nfrom app.models.base import OwnedObject\n\n\nclass Link(OwnedObject):\n    \"\"\"\n    First-class relationships between any two objects in Hypernet.\n\n    Links are not just foreign keys - they are objects themselves with metadata.\n    This enables graph queries, relationship tracking, and rich connections.\n    \"\"\"\n\n    __tablename__ = \"links\"\n\n    # ============================================================================\n    # LINK ENDPOINTS (Required)\n    # ============================================================================\n\n    from_object_id = Column(\n        UUID(as_uuid=True),\n        nullable=False,\n        index=True,\n        doc=\"Source object UUID (can be any type)\"\n    )\n\n    from_object_type = Column(\n        String(50),\n        nullable=False,\n        doc=\"Source object type (Photo, Album, User, etc.)\"\n    )\n\n    to_object_id = Column(\n        UUID(as_uuid=True),\n        nullable=False,\n        index=True,\n        doc=\"Target object UUID (can be any type)\"\n    )\n\n    to_object_type = Column(\n        String(50),\n        nullable=False,\n        doc=\"Target object type\"\n    )\n\n    # ============================================================================\n    # LINK TYPE (Required)\n    # ============================================================================\n\n    link_type = Column(\n        String(50),\n        nullable=False,\n        index=True,\n        doc=\"Link type: contains, source, duplicate_of, variant_of, related_to\"\n    )\n\n    # ============================================================================\n    # LINK PROPERTIES (Optional)\n    # ============================================================================\n\n    strength = Column(\n        Float,\n        nullable=False,\n        default=1.0,\n        doc=\"Confidence/weight of relationship (0.0 to 1.0)\"\n    )\n\n    is_bidirectional = Column(\n        Boolean,\n        nullable=False,\n        default=False,\n        doc=\"If true, relationship works both ways\"\n    )\n\n    sort_order = Column(\n        Integer,\n        nullable=True,\n        doc=\"For ordered relationships (e.g., photos in album)\"\n    )\n\n    # ============================================================================\n    # RELATIONSHIPS\n    # ============================================================================\n\n    user = relationship(\"User\", back_populates=\"links\", foreign_keys=[OwnedObject.user_id])\n\n    # ============================================================================\n    # CONSTRAINTS\n    # ============================================================================\n\n    __table_args__ = (\n        # Link type validation\n        CheckConstraint(\n            \"link_type IN ('contains', 'source', 'duplicate_of', 'variant_of', 'related_to')\",\n            name='chk_link_type'\n        ),\n        # Strength validation\n        CheckConstraint(\n            \"strength >= 0.0 AND strength <= 1.0\",\n            name='chk_strength'\n        ),\n        # Prevent self-links\n        CheckConstraint(\n            \"from_object_id != to_object_id OR from_object_type != to_object_type\",\n            name='chk_not_self_link'\n        ),\n        # Composite indexes for graph traversal\n        Index(\n            'idx_links_from',\n            'from_object_id', 'link_type',\n            postgresql_where=Column('deleted_at').is_(None)\n        ),\n        Index(\n            'idx_links_to',\n            'to_object_id', 'link_type',\n            postgresql_where=Column('deleted_at').is_(None)\n        ),\n        Index(\n            'idx_links_ordered',\n            'from_object_id', 'sort_order',\n            postgresql_where=Column('deleted_at').is_(None)\n        ),\n        # Unique constraint: No duplicate links\n        Index(\n            'idx_links_unique',\n            'from_object_id', 'to_object_id', 'link_type',\n            unique=True,\n            postgresql_where=Column('deleted_at').is_(None)\n        ),\n    )\n\n    def __repr__(self):\n        return f\"<Link(id={self.id}, type={self.link_type}, {self.from_object_type}\u2192{self.to_object_type})>\"\n"
  },
  "created_at": "2026-02-15T11:53:48.458128+00:00",
  "updated_at": "2026-02-15T11:53:48.458128+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:link.py"
}