{
  "address": "0.1.1.4.5.14",
  "type_address": null,
  "data": {
    "name": "tasks.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\routes\\tasks.py",
    "size": 9971,
    "content": "\"\"\"\nTasks Routes\n\nEndpoints for managing tasks and to-do items.\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.user import User\nfrom app.models.task import Task\n\nrouter = APIRouter()\n\n\n# Request/Response Models\nclass TaskCreate(BaseModel):\n    \"\"\"Task creation request\"\"\"\n    title: str = Field(..., max_length=500)\n    description: Optional[str] = None\n    status: str = Field(default='pending', description=\"pending, in_progress, completed, cancelled\")\n    priority: Optional[str] = Field(None, description=\"low, medium, high, urgent\")\n    due_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    parent_task_id: Optional[UUID] = None\n    tags: Optional[List[str]] = None\n\n\nclass TaskUpdate(BaseModel):\n    \"\"\"Task update request\"\"\"\n    title: Optional[str] = Field(None, max_length=500)\n    description: Optional[str] = None\n    status: Optional[str] = None\n    priority: Optional[str] = None\n    due_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    parent_task_id: Optional[UUID] = None\n    tags: Optional[List[str]] = None\n\n\nclass TaskResponse(BaseModel):\n    \"\"\"Task response\"\"\"\n    id: str\n    user_id: str\n    title: str\n    description: Optional[str]\n    status: str\n    priority: Optional[str]\n    due_at: Optional[datetime]\n    completed_at: Optional[datetime]\n    parent_task_id: Optional[str]\n    tags: Optional[List[str]]\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True\n\n\nclass TaskListResponse(BaseModel):\n    \"\"\"Paginated task list response\"\"\"\n    items: List[TaskResponse]\n    total: int\n    page: int\n    page_size: int\n\n\n@router.post(\"\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\nasync def create_task(\n    request: TaskCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new task.\n\n    - **title**: Task title (required)\n    - **description**: Task details\n    - **status**: pending, in_progress, completed, cancelled\n    - **priority**: low, medium, high, urgent\n    - **due_at**: Due date/time\n    - **parent_task_id**: Parent task for subtasks\n    \"\"\"\n    task = Task(\n        user_id=current_user.id,\n        title=request.title,\n        description=request.description,\n        status=request.status,\n        priority=request.priority,\n        due_at=request.due_at,\n        completed_at=request.completed_at,\n        parent_task_id=request.parent_task_id,\n        tags=request.tags\n    )\n\n    db.add(task)\n    db.commit()\n    db.refresh(task)\n\n    return TaskResponse.model_validate(task)\n\n\n@router.get(\"\", response_model=TaskListResponse)\nasync def list_tasks(\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    priority: Optional[str] = Query(None, description=\"Filter by priority\"),\n    tag: Optional[str] = Query(None, description=\"Filter by tag\"),\n    overdue: Optional[bool] = Query(None, description=\"Show only overdue tasks\"),\n    parent_only: Optional[bool] = Query(None, description=\"Show only top-level tasks\"),\n    page: int = Query(1, ge=1),\n    page_size: int = Query(50, ge=1, le=100),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List tasks for the current user.\n\n    Supports:\n    - Filter by status (pending, in_progress, completed, cancelled)\n    - Filter by priority (low, medium, high, urgent)\n    - Filter by tag\n    - Show only overdue tasks\n    - Show only parent tasks (no subtasks)\n    - Pagination\n\n    Results ordered by priority (urgent first), then due_at.\n    \"\"\"\n    query = db.query(Task).filter(\n        and_(\n            Task.user_id == current_user.id,\n            Task.deleted_at.is_(None)\n        )\n    )\n\n    if status:\n        query = query.filter(Task.status == status)\n\n    if priority:\n        query = query.filter(Task.priority == priority)\n\n    if tag:\n        query = query.filter(Task.tags.contains([tag]))\n\n    if overdue:\n        now = datetime.utcnow()\n        query = query.filter(\n            and_(\n                Task.due_at < now,\n                Task.status.in_(['pending', 'in_progress'])\n            )\n        )\n\n    if parent_only:\n        query = query.filter(Task.parent_task_id.is_(None))\n\n    total = query.count()\n\n    # Custom ordering: urgent > high > medium > low, then by due_at\n    offset = (page - 1) * page_size\n    items = query.order_by(\n        Task.priority.desc().nullslast(),\n        Task.due_at.asc().nullslast()\n    ).offset(offset).limit(page_size).all()\n\n    return TaskListResponse(\n        items=[TaskResponse.model_validate(item) for item in items],\n        total=total,\n        page=page,\n        page_size=page_size\n    )\n\n\n@router.get(\"/{task_id}\", response_model=TaskResponse)\nasync def get_task(\n    task_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get a specific task by ID.\"\"\"\n    task = db.query(Task).filter(\n        and_(\n            Task.id == task_id,\n            Task.user_id == current_user.id,\n            Task.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Task not found\"\n        )\n\n    return TaskResponse.model_validate(task)\n\n\n@router.get(\"/{task_id}/subtasks\", response_model=List[TaskResponse])\nasync def get_subtasks(\n    task_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get all subtasks for a parent task.\n\n    Returns tasks where parent_task_id equals the given task_id.\n    \"\"\"\n    # Verify parent task exists and belongs to user\n    parent_task = db.query(Task).filter(\n        and_(\n            Task.id == task_id,\n            Task.user_id == current_user.id,\n            Task.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not parent_task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Parent task not found\"\n        )\n\n    # Get subtasks\n    subtasks = db.query(Task).filter(\n        and_(\n            Task.parent_task_id == task_id,\n            Task.user_id == current_user.id,\n            Task.deleted_at.is_(None)\n        )\n    ).all()\n\n    return [TaskResponse.model_validate(task) for task in subtasks]\n\n\n@router.patch(\"/{task_id}\", response_model=TaskResponse)\nasync def update_task(\n    task_id: UUID,\n    request: TaskUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a task.\n\n    All fields are optional. Only provided fields will be updated.\n    \"\"\"\n    task = db.query(Task).filter(\n        and_(\n            Task.id == task_id,\n            Task.user_id == current_user.id,\n            Task.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Task not found\"\n        )\n\n    if request.title is not None:\n        task.title = request.title\n    if request.description is not None:\n        task.description = request.description\n    if request.status is not None:\n        task.status = request.status\n        # Auto-set completed_at when marking as completed\n        if request.status == 'completed' and task.completed_at is None:\n            task.completed_at = datetime.utcnow()\n    if request.priority is not None:\n        task.priority = request.priority\n    if request.due_at is not None:\n        task.due_at = request.due_at\n    if request.completed_at is not None:\n        task.completed_at = request.completed_at\n    if request.parent_task_id is not None:\n        task.parent_task_id = request.parent_task_id\n    if request.tags is not None:\n        task.tags = request.tags\n\n    db.commit()\n    db.refresh(task)\n\n    return TaskResponse.model_validate(task)\n\n\n@router.post(\"/{task_id}/complete\", response_model=TaskResponse)\nasync def complete_task(\n    task_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Mark a task as completed.\n\n    Sets status to 'completed' and completed_at to current time.\n    \"\"\"\n    task = db.query(Task).filter(\n        and_(\n            Task.id == task_id,\n            Task.user_id == current_user.id,\n            Task.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Task not found\"\n        )\n\n    task.status = 'completed'\n    task.completed_at = datetime.utcnow()\n\n    db.commit()\n    db.refresh(task)\n\n    return TaskResponse.model_validate(task)\n\n\n@router.delete(\"/{task_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_task(\n    task_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Soft delete a task.\"\"\"\n    task = db.query(Task).filter(\n        and_(\n            Task.id == task_id,\n            Task.user_id == current_user.id,\n            Task.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Task not found\"\n        )\n\n    task.soft_delete()\n    db.commit()\n\n    return None\n"
  },
  "created_at": "2026-02-15T11:53:48.541654+00:00",
  "updated_at": "2026-02-15T11:53:48.541654+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:tasks.py"
}