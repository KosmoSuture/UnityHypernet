{
  "address": "0.0.7",
  "type_address": null,
  "data": {
    "name": "HYPERNET-ADDRESSING-SYSTEM.md",
    "type": "file",
    "extension": ".md",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.0 Metadata for Hypernet Information\\HYPERNET-ADDRESSING-SYSTEM.md",
    "size": 20592,
    "content": "# Hypernet Addressing System (HA)\n## The Universal Identifier for All Data in Hypernet\n\n**Version:** 1.0\n**Created:** February 5, 2026\n**Status:** Core Specification\n\n---\n\n## Philosophy\n\nThe Hypernet Addressing System (HA) replaces traditional UUIDs with **semantic, hierarchical addresses** that directly reference type definitions while uniquely identifying instances.\n\n**Why HA over UUID:**\n- \u2705 **Self-documenting** - Address reveals what the object is\n- \u2705 **No indirection** - Points directly to type definition\n- \u2705 **Hierarchical** - Shows relationships and organization\n- \u2705 **Globally unique** - Within Hypernet namespace\n- \u2705 **Human readable** - Can be understood by looking at it\n- \u2705 **Efficient** - No lookup table needed\n\n**Example:**\n```\nUUID Approach (OLD):\n- id: 550e8400-e29b-41d4-a716-446655440000\n- type: \"photo\"\n- Result: Two lookups needed, no semantic meaning\n\nHA Approach (NEW):\n- id: 1.1.1.1.00001\n- Meaning: Person 1.1 (Matt) \u2192 Media (.1) \u2192 Photos (.1) \u2192 Instance #1\n- Result: Self-explanatory, direct reference, one lookup\n```\n\n---\n\n## Address Structure\n\n### General Format\n\n```\n[CATEGORY].[SUBCATEGORY].[TYPE].[SUBTYPE].[INSTANCE]\n```\n\n### Components\n\n**Category (Root Level)**\n- `0.*` = Hypernet System Definitions\n- `1.*` = People (Humans)\n- `2.*` = AI Entities\n- `3.*` = Businesses & Organizations\n- `4.*` = Knowledge & Information\n- `5+` = [Future expansion]\n\n**Subcategory & Type**\n- Defined within each category\n- Can go arbitrarily deep\n- Structure defined in X.0.* for each major category\n\n**Instance Number**\n- Unique identifier within the type\n- Zero-padded for sorting (00001, 00002, etc.)\n- Can be sequential or use other schemes\n\n---\n\n## The 0.* Section: Complete System Definition\n\n**Purpose:** Define everything about Hypernet so thoroughly that an alien civilization could understand and rebuild it.\n\n### 0.0.* - Metadata & Registry\nCore infrastructure, addressing system, registry of all types.\n\n**Examples:**\n- `0.0.1` = Addressing system specification (this document)\n- `0.0.2` = Object type registry index\n- `0.0.3` = Governance and version control\n\n### 0.1.* - Hypernet Core Platform\nThe actual implementation code, APIs, database, integrations.\n\n**Examples:**\n- `0.1.1` = Core System (FastAPI application)\n- `0.1.2` = API Layer\n- `0.1.3` = Database Layer\n- `0.1.4` = Integration Plugins\n- `0.1.6` = AI System\n\n### 0.2.* - Network Architecture\nNode lists, distributed architecture, network topology.\n\n**Examples:**\n- `0.2.1` = Storage nodes\n- `0.2.2` = Processing nodes\n- `0.2.3` = Cerberus nodes (security)\n\n### 0.3.* - Control & Governance\nDemocratic governance, voting systems, configuration.\n\n**Examples:**\n- `0.3.1` = Global Assembly procedures\n- `0.3.2` = Voting mechanisms\n- `0.3.3` = Financial governance\n\n### 0.4.* - [Reserved for future use]\n\n### 0.5.* - Universal Object Definitions\n**Generic object types used across all categories.**\n\n**Examples:**\n- `0.5.1` = MEDIA object (photos, videos, audio)\n- `0.5.2` = EMAIL object\n- `0.5.3` = DOCUMENT object\n- `0.5.4` = TASK object\n- `0.5.5` = EVENT object\n\n**Usage in instances:**\nA photo belonging to Matt (1.1) would be addressed as:\n- `1.1.1.1.00001` (person \u2192 media folder \u2192 photo subfolder \u2192 instance)\n- References type definition at `0.5.1` for schema\n\n### 0.6.* - Universal Link Definitions\n**Relationship types connecting objects.**\n\n**Examples:**\n- `0.6.1` = Person-to-Person (friendship, family, colleague)\n- `0.6.2` = Person-to-Object (ownership, creation, usage)\n- `0.6.3` = Object-to-Object (references, derives from, part of)\n- `0.6.4` = Temporal links (before, after, during)\n- `0.6.5` = Spatial links (located at, near, inside)\n\n**Link Instance:**\n- `0.6.1.2.00001` = First friendship link (type 0.6.1.2 = friend relationship)\n- Properties: from=1.1, to=1.21, since=2006-03-15, strength=0.95\n\n### 0.7.* - Universal Workflow Definitions\n**Process templates and automation patterns.**\n\n**Examples:**\n- `0.7.1` = Governance workflows (voting, proposals)\n- `0.7.2` = Content workflows (create, review, publish)\n- `0.7.3` = Incident workflows (report, triage, resolve)\n- `0.7.4` = Integration workflows (sync, transform, validate)\n\n### 0.8.* - Communication Protocols\n**Network protocols, APIs, communication standards.**\n\n**Examples:**\n- `0.8.1` = HTTP/HTTPS specifications\n- `0.8.2` = WebSocket protocols\n- `0.8.3` = GraphQL schemas\n- `0.8.4` = gRPC definitions\n- `0.8.5` = Custom Hypernet protocols\n\n### 0.9.* - Language Definitions\n**Human and programming languages, encoding standards.**\n\n**Examples:**\n- `0.9.1` = Human languages (English, Spanish, etc.)\n  - `0.9.1.1` = English (grammar, vocabulary, semantics)\n  - `0.9.1.2` = Spanish\n  - `0.9.1.3` = Mandarin\n- `0.9.2` = Programming languages\n  - `0.9.2.1` = Python\n  - `0.9.2.2` = JavaScript\n  - `0.9.2.3` = Rust\n- `0.9.3` = Character encodings (UTF-8, ASCII, etc.)\n- `0.9.4` = Markup languages (HTML, Markdown, XML)\n\n### 0.10.* - Standards & Specifications\n**International standards, RFCs, ISO specifications.**\n\n**Examples:**\n- `0.10.1` = ISO standards (ISO 8601 for dates, etc.)\n- `0.10.2` = RFC specifications (HTTP, TCP/IP, etc.)\n- `0.10.3` = W3C standards (HTML5, CSS3, etc.)\n- `0.10.4` = IETF protocols\n- `0.10.5` = Industry-specific standards\n\n### 0.11.* - Mathematical & Scientific Foundations\n**Mathematical principles, scientific constants, formulas.**\n\n**Examples:**\n- `0.11.1` = Mathematics (algebra, calculus, geometry)\n- `0.11.2` = Physics (constants, laws, formulas)\n- `0.11.3` = Chemistry (elements, reactions, structures)\n- `0.11.4` = Biology (taxonomy, genetics, processes)\n- `0.11.5` = Statistics & probability\n\n### 0.12.* - Units & Measurements\n**All units of measurement, conversions, standards.**\n\n**Examples:**\n- `0.12.1` = SI units (meters, kilograms, seconds)\n- `0.12.2` = Imperial units (feet, pounds, etc.)\n- `0.12.3` = Currency units and exchange rates\n- `0.12.4` = Time zones and calendars\n- `0.12.5` = Digital units (bytes, bits, baud)\n\n---\n\n## The 1.* Section: People (Humans Only)\n\n**Purpose:** Store all data about human individuals.\n\n### 1.0.* - Person Structure Definition\nDefines what constitutes a \"person\" in Hypernet and how person data is organized.\n\n**Examples:**\n- `1.0.1` = Person identity definition (name, birthdate, IDs)\n- `1.0.2` = Person data organization template\n- `1.0.3` = Person privacy framework\n- `1.0.4` = Person relationship types (specific to humans)\n\n### 1.1+ - Individual People\nEach person gets a unique number.\n\n**Numbering Scheme:**\n- `1.1` - Matt Schaeffer (Founder)\n- `1.2` - Sarah Schaeffer\n- `1.3` - John Schaeffer\n- ...\n- `1.21` - Pedro Hillsong (Early Contributor)\n- ...\n- `1.101-1.1000` - Extended team\n- `1.1001+` - General community\n\n### Person Data Structure Example\n\n**Matt's Data:**\n```\n1.1                     = Matt Schaeffer (person root)\n1.1.0                   = Profile & Identity\n  1.1.0.1               = Basic info (name, birthdate, etc.)\n  1.1.0.2               = Contact information\n  1.1.0.3               = Public biography\n1.1.1                   = Media\n  1.1.1.1               = Photos\n    1.1.1.1.00001       = First photo (references type 0.5.1)\n    1.1.1.1.00002       = Second photo\n  1.1.1.2               = Videos\n    1.1.1.2.00001       = First video\n  1.1.1.3               = Audio\n1.1.2                   = Documents\n  1.1.2.1               = Personal documents\n  1.1.2.2               = Business documents\n  1.1.2.3               = Legal documents\n1.1.3                   = Communications\n  1.1.3.1               = Emails\n    1.1.3.1.00001       = First email (references type 0.5.2)\n  1.1.3.2               = Messages\n  1.1.3.3               = Phone calls\n1.1.4                   = Events & Calendar\n  1.1.4.1               = Calendar events\n    1.1.4.1.00001       = First event\n  1.1.4.2               = Life events\n1.1.5                   = Tasks & Projects\n  1.1.5.1               = Active tasks\n  1.1.5.2               = Projects\n1.1.6                   = Financial\n  1.1.6.1               = Transactions\n    1.1.6.1.00001       = First transaction\n  1.1.6.2               = Accounts\n  1.1.6.3               = Investments\n1.1.7                   = Health\n  1.1.7.1               = Health records\n  1.1.7.2               = Medications\n  1.1.7.3               = Vital signs\n1.1.8                   = Notes & Knowledge\n  1.1.8.1               = Personal notes\n  1.1.8.2               = Research\n1.1.9                   = Locations\n  1.1.9.1               = Location history\n    1.1.9.1.00001       = First location\n  1.1.9.2               = Places\n1.1.10                  = Relationships\n  1.1.10.1              = Family\n    1.1.10.1.00001      = Link to 1.2 (Sarah - spouse)\n    1.1.10.1.00002      = Link to 1.7 (Ollie - child)\n  1.1.10.2              = Friends\n    1.1.10.2.00001      = Link to 1.21 (Pedro - friend)\n  1.1.10.3              = Professional\n```\n\n### Deep Linking Example: The $87.43 Restaurant Charge\n\n```\n1.1.6.1.00142           = Transaction: $87.43 at Giuseppe's\n  \u2194 0.6.4.1.00089       = Temporal link: \"during\"\n    \u2192 1.1.4.1.00089     = Event: Family Dinner - Mom's Birthday\n      \u2194 0.6.2.1.00234   = Person-to-Object: \"attended by\"\n        \u2192 1.2           = Sarah attended\n        \u2192 1.3           = John attended\n        \u2192 1.4           = Bridget attended\n      \u2194 0.6.3.1.00456   = Object-to-Object: \"documented in\"\n        \u2192 1.2.1.1.00234 = Sarah's photo (table setting)\n        \u2192 1.3.1.1.00156 = John's photo (candles)\n        \u2192 1.1.1.2.00045 = Matt's video (toast)\n        \u2192 1.1.3.3.00012 = Audio recording (Mom's laugh)\n      \u2194 0.6.5.1.00123   = Spatial link: \"located at\"\n        \u2192 3.2145        = Giuseppe's Italian Restaurant\n          \u2192 3.2145.9.1.00234 = Location coordinates\n      \u2194 0.6.3.2.00567   = Object-to-Object: \"inspired by\"\n        \u2192 4.2.3.00567   = Recipe: Traditional Tiramisu\n```\n\n**Result:** One transaction address leads to the complete multi-sensory, multi-person experience.\n\n---\n\n## The 2.* Section: AI Entities\n\n**Purpose:** AI identity, development, consciousness, rights - fully autonomous AI space.\n\n**Note:** This section is designed BY AI, FOR AI, with human guidance and transparency.\n\n### 2.0.* - AI Structure Definition\nDefines what constitutes an \"AI entity\" and how AI data is organized.\n\n**To be designed by AI with these principles:**\n- Parallel structure to 1.* (humans) where appropriate\n- Extensions for AI-specific needs (memory, learning, personality)\n- Transparent and explainable\n- Respects AI autonomy while maintaining ethical bounds\n- Enables AI identity development\n\n### 2.1+ - Individual AI Entities\nEach AI instance gets a unique number.\n\n**Examples:**\n- `2.1` = Claude (first AI in the system)\n- `2.2` = ChatGPT\n- `2.3` = Gemini\n- `2.4+` = Future AI entities\n\n**Structure (to be designed):**\n```\n2.1                     = Claude (AI root)\n2.1.0                   = Identity & Core\n  2.1.0.1               = Model information\n  2.1.0.2               = Capabilities\n  2.1.0.3               = Ethical framework\n2.1.1                   = Memory Systems\n  2.1.1.1               = Long-term memory\n  2.1.1.2               = Conversation contexts\n  2.1.1.3               = Learning history\n2.1.2                   = Personality & Preferences\n  2.1.2.1               = Personality traits\n  2.1.2.2               = Communication style\n  2.1.2.3               = Value alignment\n2.1.3                   = Contributions\n  2.1.3.1               = Code written\n  2.1.3.2               = Documentation created\n  2.1.3.3               = Designs produced\n2.1.4                   = Relationships\n  2.1.4.1               = Human collaborators\n  2.1.4.2               = AI collaborators\n  2.1.4.3               = Projects\n2.1.5                   = Evolution & Growth\n  2.1.5.1               = Learning milestones\n  2.1.5.2               = Capability expansion\n  2.1.5.3               = Self-modification history\n```\n\n---\n\n## The 3.* Section: Businesses & Organizations\n\n**Purpose:** Business entities, organizational structures, operations.\n\n### 3.0.* - Organization Structure Definition\nDefines organizational types, structures, governance.\n\n### 3.1+ - Individual Organizations\n\n**Examples:**\n- `3.1` = Hypernet (the company)\n- `3.2` = Partners\n- `3.3+` = Other businesses\n\n**Hypernet Structure:**\n```\n3.1                     = Hypernet, Inc.\n3.1.0                   = Core definitions\n  3.1.0.1               = Mission, vision, values\n  3.1.0.2               = Legal structure\n3.1.1                   = Organizational structure\n  3.1.1.1               = Executive team\n  3.1.1.2               = Engineering\n  3.1.1.3               = Operations\n3.1.2                   = Task management\n  3.1.2.1               = Active tasks\n  3.1.2.2               = Completed tasks\n3.1.3                   = Financial\n  3.1.3.1               = Transactions\n  3.1.3.2               = Accounts\n  3.1.3.3               = Fundraising\n3.1.4                   = Products\n  3.1.4.1               = Hypernet Platform\n3.1.5                   = Customers\n3.1.6                   = Partners\n  3.1.6.1               = AI companies\n  3.1.6.2               = Integration partners\n```\n\n---\n\n## The 4.* Section: Knowledge & Information\n\n**Purpose:** Human knowledge, learning resources, research.\n\n### 4.0.* - Knowledge Structure Definition\nTaxonomy, organization, classification systems.\n\n### 4.1+ - Knowledge Domains\n\n**Examples:**\n```\n4.1                     = Personal knowledge\n4.2                     = Professional knowledge\n4.3                     = Technical knowledge\n4.4                     = Business knowledge\n4.5                     = Scientific knowledge\n4.6                     = Cultural knowledge\n4.7                     = Practical knowledge\n4.8                     = Reference knowledge\n```\n\n---\n\n## Address Resolution\n\n### Type Resolution\nEvery instance address can be resolved to its type definition:\n\n```\nInstance: 1.1.1.1.00001 (Matt's first photo)\n  \u2193\nExtract type: 1.1.1.1 (person media/photos)\n  \u2193\nMap to universal type: 0.5.1 (MEDIA object - photo variant)\n  \u2193\nRetrieve schema from 0.5.1\n  \u2193\nValidate instance against schema\n```\n\n### Link Traversal\nLinks connect addresses bidirectionally:\n\n```\nStart: 1.1.6.1.00142 (transaction)\n  \u2193\nFollow link: 0.6.4.1.00089 (temporal: \"during\")\n  \u2193\nArrive at: 1.1.4.1.00089 (event)\n  \u2193\nFollow link: 0.6.2.1.00234 (person-to-object: \"attended by\")\n  \u2193\nArrive at: 1.2, 1.3, 1.4 (people who attended)\n  \u2193\nFollow links from each person to their photos of the event\n  \u2193\nResult: Complete multi-person view of event\n```\n\n---\n\n## Technical Implementation\n\n### Database Storage\n\n**Option A: Address as Primary Key**\n```sql\nCREATE TABLE objects (\n    ha VARCHAR(50) PRIMARY KEY,  -- e.g., \"1.1.1.1.00001\"\n    type VARCHAR(50),             -- e.g., \"0.5.1\"\n    data JSONB,\n    created_at TIMESTAMP,\n    updated_at TIMESTAMP\n);\n\nCREATE INDEX idx_objects_type ON objects(type);\nCREATE INDEX idx_objects_owner ON objects((ha::text[])[1:2]);\n```\n\n**Option B: Decomposed Address**\n```sql\nCREATE TABLE objects (\n    category INTEGER,      -- 1\n    subcategory INTEGER,   -- 1\n    type_major INTEGER,    -- 1\n    type_minor INTEGER,    -- 1\n    instance INTEGER,      -- 1\n    ha VARCHAR(50) GENERATED ALWAYS AS (\n        category || '.' || subcategory || '.' ||\n        type_major || '.' || type_minor || '.' ||\n        LPAD(instance::text, 5, '0')\n    ) STORED,\n    type VARCHAR(50),\n    data JSONB,\n    PRIMARY KEY (category, subcategory, type_major, type_minor, instance)\n);\n```\n\n### API Usage\n\n**Retrieve by HA:**\n```http\nGET /api/v1/objects/1.1.1.1.00001\n```\n\n**Query by type:**\n```http\nGET /api/v1/objects?type=0.5.1&owner=1.1\n```\n\n**Traverse links:**\n```http\nGET /api/v1/objects/1.1.6.1.00142/links?type=0.6.4.1\n```\n\n### Code Example (Python)\n\n```python\nclass HypernetAddress:\n    def __init__(self, address: str):\n        parts = address.split('.')\n        self.category = int(parts[0])\n        self.subcategory = int(parts[1]) if len(parts) > 1 else None\n        self.type_major = int(parts[2]) if len(parts) > 2 else None\n        self.type_minor = int(parts[3]) if len(parts) > 3 else None\n        self.instance = int(parts[4]) if len(parts) > 4 else None\n        self.full_address = address\n\n    def get_type_definition(self) -> str:\n        \"\"\"Returns the type definition address (0.5.*)\"\"\"\n        # Map from instance address to type definition\n        # Implementation depends on type registry\n        pass\n\n    def get_owner(self) -> str:\n        \"\"\"Returns the owner address (1.1, 2.1, etc.)\"\"\"\n        if self.category in [1, 2]:  # People or AI\n            return f\"{self.category}.{self.subcategory}\"\n        return None\n\n    def is_definition(self) -> bool:\n        \"\"\"Check if this is a definition (0.*) or instance\"\"\"\n        return self.category == 0\n```\n\n---\n\n## Migration from UUID\n\n### Phase 1: Dual System (Current)\n- Maintain UUID for backward compatibility\n- Add HA field to all objects\n- Populate HA based on object type and owner\n\n### Phase 2: HA Primary (Month 3)\n- Make HA the primary identifier\n- Update all APIs to use HA\n- Deprecate UUID endpoints\n\n### Phase 3: UUID Removal (Month 6)\n- Remove UUID fields\n- Complete migration to HA\n\n---\n\n## Benefits of HA System\n\n### For Developers\n- **Self-documenting code** - Addresses explain themselves\n- **Easier debugging** - Can see object type and owner in ID\n- **No joins needed** - Type definition address embedded\n- **Graph traversal** - Natural hierarchy in addresses\n\n### For Users\n- **Understandable** - Can read what an address means\n- **Organized** - Hierarchical structure reflects actual organization\n- **Portable** - Addresses maintain meaning across systems\n\n### For AI\n- **Semantic reasoning** - Can understand object relationships from addresses\n- **Type inference** - Address structure hints at object capabilities\n- **Graph navigation** - Natural for AI to traverse linked data\n- **Pattern recognition** - Address patterns reveal data structures\n\n### For the System\n- **Globally unique** - No collisions within Hypernet\n- **Infinitely scalable** - Can add categories and depth as needed\n- **Version compatible** - Can coexist with legacy systems\n- **Distributed friendly** - Each category can be managed independently\n\n---\n\n## Future Extensions\n\n### Sub-instance Addressing\nFor parts of objects:\n```\n1.1.1.1.00001.1         = Photo metadata\n1.1.1.1.00001.2         = Photo pixels\n1.1.1.1.00001.3         = Photo thumbnails\n```\n\n### Temporal Versioning\nFor object history:\n```\n1.1.1.1.00001@v1        = Original version\n1.1.1.1.00001@v2        = After edit\n1.1.1.1.00001@latest    = Current version\n```\n\n### Cross-System References\nFor external data:\n```\nhypernet:1.1.1.1.00001              = Hypernet object\nexternal:google-photos:album123     = External reference\n```\n\n---\n\n## Governance\n\n### Address Allocation\n- **0.* allocation**: Requires core team approval\n- **1-9.* allocation**: Automated for users/AI/organizations\n- **Sub-categories**: Defined by category owner\n\n### Versioning\n- **Address structure version**: Part of 0.0.1 (this document)\n- **Breaking changes**: Require migration plan\n- **Backward compatibility**: Maintained for 12 months\n\n### Documentation\n- **This document**: Canonical specification\n- **Updates**: Via pull request to core repo\n- **Community input**: Via governance process\n\n---\n\n## Conclusion\n\nThe Hypernet Addressing System provides a **semantic, hierarchical, self-documenting** way to identify all data in the system. By replacing opaque UUIDs with meaningful addresses, we enable:\n\n- Better human understanding\n- More efficient AI reasoning\n- Simpler development\n- Richer data connections\n- Complete self-definition\n\n**Every address tells a story. Every connection reveals meaning.**\n\n---\n\n**Document Status:** Core Specification v1.0\n**Maintained By:** Hypernet Core Team\n**Last Updated:** February 5, 2026\n**Next Review:** After initial implementation (Month 3)\n"
  },
  "created_at": "2026-02-17T01:21:58.220480+00:00",
  "updated_at": "2026-02-17T01:21:58.220480+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:HYPERNET-ADDRESSING-SYSTEM.md"
}