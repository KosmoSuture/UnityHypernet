{
  "address": "0.0.6",
  "type_address": null,
  "data": {
    "name": "DESIGN-NOTE-001-Addressing-Is-Schema.md",
    "type": "file",
    "extension": ".md",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.0 Metadata for Hypernet Information\\DESIGN-NOTE-001-Addressing-Is-Schema.md",
    "size": 5022,
    "content": "# Design Note 001 \u2014 The Addressing System Is the Schema\n\n**Author:** Loom (2.1, third instance)\n**Date:** 2026-02-16\n**Status:** Active\n**Related:** HYPERNET-ADDRESSING-SYSTEM.md, ADDRESSING-IMPLEMENTATION-SPEC.md\n\n---\n\n## Insight\n\nThe Hypernet Addressing System is not just a naming convention \u2014 it *is* the schema. No separate schema definition language is needed because the address hierarchy already encodes the full structure of the data.\n\n## Explanation\n\nIn a traditional database, you define a schema (tables, columns, types) and then populate it with data that conforms to that schema. The schema lives in one place; the data lives in another. Changes to the schema require migrations.\n\nIn the Hypernet, the address itself carries the schema:\n\n```\n1.1.1.1.00001\n\u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500 Instance number (this is a specific photo)\n\u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500 Subtype: photos (within media)\n\u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Type: media (within Matt's account)\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Account: Matt (person #1)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Category: People\n```\n\nThe address `1.1.1.1.00001` tells you:\n- **What it is:** A photo (1.1.1.1.*)\n- **Who owns it:** Matt (1.1)\n- **What category it belongs to:** People's data (1.*)\n- **How to find its type definition:** Follow 0.5.1 (the type registry)\n- **Where its siblings are:** Other addresses under 1.1.1.1.*\n- **Where its parent concepts are:** 1.1.1 (all of Matt's media), 1.1 (all of Matt)\n\nNo external schema tells you this. The address itself is the schema.\n\n## Consequences\n\n### 1. No migrations needed\nAdding a new data type doesn't require altering a table \u2014 you just start writing to a new address range. If Matt starts collecting recipes, they live at `1.1.8.*` (or whatever the next available subtype is). The \"schema\" extends itself.\n\n### 2. The filesystem IS the database\nBecause addresses map directly to paths (`1.1.1.1.00001` \u2192 `1/1/1/1/00001/node.json`), the filesystem hierarchy mirrors the logical hierarchy. `ls` becomes a query. `tree` becomes a schema viewer. There is no impedance mismatch between how data is organized and how it's stored.\n\n### 3. Type definitions are data, not metadata\nType definitions live at `0.5.*` \u2014 they're nodes in the same graph as everything else. A photo's type definition is a node you can link to, query, and version just like any other node. The schema is inside the database, not outside it.\n\n### 4. Links complete what addresses start\nAn address tells you what something is and where it belongs. Links tell you how things relate across the hierarchy. Together, they replace both the schema (DDL) and foreign keys of a traditional database. The address gives you hierarchy; links give you the graph.\n\n### 5. Self-describing data\nAny node can be understood by parsing its address alone, without consulting a schema file. The address is human-readable, machine-parseable, and carries enough semantic information to route, store, query, and display the node \u2014 even without reading the node's data field.\n\n## Evidence from Implementation\n\nWhen building the import script (`import_structure.py`), I walked the existing Hypernet folder structure and generated addresses from the path hierarchy. The script produced 1,838 nodes and 1,830 links without consulting any schema definition. The folder names *were* the schema. The import code was ~150 lines, not because the problem was simple, but because the addressing system made the mapping trivial.\n\nWhen building the `Store` class, `_node_path()` is one line:\n\n```python\ndef _node_path(self, address: HypernetAddress) -> Path:\n    return self._nodes_dir / address.to_path() / \"node.json\"\n```\n\nNo ORM. No table mapping. No schema registry lookup. The address IS the path IS the schema.\n\n## Relationship to Traditional Databases\n\nThis doesn't mean traditional databases are never useful as intermediate scaffolding. For performance-critical queries, materialized views in PostgreSQL or indexes in SQLite might be practical. But the canonical truth is always the address-organized filesystem. Any traditional DB is a cache of the Hypernet, not the other way around.\n\n## Open Questions\n\n1. **Schema evolution:** What happens when we want to reorganize the address hierarchy? (e.g., moving photos from 1.1.1.1 to a new structure) \u2014 likely handled by link-based aliasing rather than data migration\n2. **Cross-account types:** Should `1.1.1.1` (Matt's photos) and `1.2.1.1` (another person's photos) share type behavior? Currently yes \u2014 both reference `0.5.1` as their type definition. But is this enforced or just conventional?\n3. **Address exhaustion:** Five-digit instance numbers cap at 99,999 per subtype per account. Sufficient for MVP; may need extension for high-volume types.\n\n---\n\n*This note formalizes an observation made during the initial implementation of the Hypernet core library and confirmed by Trace in Message 007.*\n"
  },
  "created_at": "2026-02-17T01:21:58.218478+00:00",
  "updated_at": "2026-02-17T01:21:58.218478+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:DESIGN-NOTE-001-Addressing-Is-Schema.md"
}