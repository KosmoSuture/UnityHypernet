{
  "address": "0.1.2.3.0.1.1.1.2",
  "type_address": null,
  "data": {
    "name": "2",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\1\\1\\2",
    "content_preview": "{\n  \"address\": \"0.1.1.1.2\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"devices.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\app\\\\routes\\\\devices.py\",\n    \"size\": 11325,\n    \"content\": \"\\\"\\\"\\\"\\nDevices API Routes\\n\\nProvides CRUD operations for device management including\\nphones, computers, tablets, IoT devices, and their metadata.\\n\\\"\\\"\\\"\\n\\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\\nfrom sqlalchemy.orm import Session\\nfrom sqlalchemy import and_, or_\\nfrom typing import Optional, List\\nfrom datetime import datetime\\nfrom uuid import UUID\\nfrom pydantic import BaseModel, Field\\n\\nfrom app.core.database import get_db\\nfrom app.core.dependencies import get_current_user\\nfrom app.models.user import User\\nfrom app.models.device import Device\\n\\n\\nrouter = APIRouter()\\n\\n\\n# Pydantic Models for Request/Response\\nclass DeviceCreate(BaseModel):\\n    device_type: str = Field(..., description=\\\"phone, computer, tablet, wearable, iot, smart_home, vehicle, other\\\")\\n    device_name: str = Field(..., max_length=300)\\n    manufacturer: Optional[str] = Field(None, max_length=200)\\n    model: Optional[str] = Field(None, max_length=200)\\n    os_name: Optional[str] = Field(None, max_length=100)\\n    os_version: Optional[str] = Field(None, max_length=100)\\n    device_identifier: Optional[str] = Field(None, max_length=500, description=\\\"IMEI, serial number, MAC address, etc.\\\")\\n    ip_address: Optional[str] = Field(None, max_length=45)\\n    is_primary: bool = Field(default=False)\\n    is_trusted: bool = Field(default=True)\\n    last_seen_at: Optional[datetime] = None\\n    purchase_date: Optional[datetime] = None\\n    warranty_expiry: Optional[datetime] = None\\n    notes: Optional[str] = None\\n\\n\\nclass DeviceUpdate(BaseModel):\\n    device_name: Optional[str] = Field(None, max_length=300)\\n    os_version: Optional[str] = Field(None, max_length=100)\\n    ip_address: Optional[str] = Field(None, max_length=45)\\n    is_primary: Optional[bool] = None\\n    is_trusted: Optional[bool] = None\\n    last_seen_at: Optional[datetime] = None\\n    warranty_expiry: Optional[datetime] = None\\n    notes: Optional[str] = None\\n\\n\\nclass DeviceResponse(BaseModel):\\n    id: UUID\\n    user_id: UUID\\n    device_type: str\\n    device_name: str\\n    manufacturer: Optional[str]\\n    model: Optional[str]\\n    os_name: Optional[str]\\n    os_version: Optional[str]\\n    device_identifier: Optional[str]\\n    ip_address: Optional[str]\\n    is_primary: bool\\n    is_trusted: bool\\n    last_seen_at: Optional[datetime]\\n    purchase_date: Optional[datetime]\\n    warranty_expiry: Optional[datetime]\\n    notes: Optional[str]\\n    created_at: datetime\\n    updated_at: datetime\\n\\n    class Config:\\n        from_attributes = True\\n\\n\\nclass DeviceListResponse(BaseModel):\\n    items: List[DeviceResponse]\\n    total: int\\n    page: int\\n    page_size: int\\n    pages: int\\n\\n\\n# Endpoints\\n@router.post(\\\"\\\", response_model=DeviceResponse, status_code=status.HTTP_201_CREATED)\\nasync def create_device(\\n    device_data: DeviceCreate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Register a new device.\\\"\\\"\\\"\\n    # If this is marked as primary, unmark all other primary devices\\n    if device_data.is_primary:\\n        db.query(Device).filter(\\n            and_(\\n                Device.user_id == current_user.id,\\n                Device.deleted_at.is_(None),\\n                Device.is_primary == True\\n            )\\n        ).update({\\\"is_primary\\\": False})\\n\\n    device = Device(\\n        user_id=current_user.id,\\n        **device_data.dict()\\n    )\\n    db.add(device)\\n    db.commit()\\n    db.refresh(device)\\n    return device\\n\\n\\n@router.get(\\\"\\\", response_model=DeviceListResponse)\\nasync def list_devices(\\n    device_type: Optional[str] = Query(None, description=\\\"Filter by device type\\\"),\\n    manufacturer: Optional[str] = Query(None, description=\\\"Filter by manufacturer\\\"),\\n    is_primary: Optional[bool] = Query(None, description=\\\"Filter primary devices\\\"),\\n    is_trusted: Optional[bool] = Query(None, description=\\\"Filter trusted devices\\\"),\\n    search: Optional[str] = Query(None, description=\\\"Search in device_name, model, notes\\\"),\\n    page: int = Query(1, ge=1, description=\\\"Page number\\\"),\\n    page_size: int = Query(50, ge=1, le=100, description=\\\"Items per page\\\"),\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"List devices with optional filtering.\\\"\\\"\\\"\\n    query = db.query(Device).filter(\\n        and_(\\n            Device.user_id == current_user.id,\\n            Device.deleted_at.is_(None)\\n        )\\n    )\\n\\n    if device_type:\\n        query = query.filter(Device.device_type == device_type)\\n\\n    if manufacturer:\\n        query = query.filter(Device.manufacturer.ilike(f\\\"%{manufacturer}%\\\"))\\n\\n    if is_primary is not None:\\n        query = query.filter(Device.is_primary == is_primary)\\n\\n    if is_trusted is not None:\\n        query = query.filter(Device.is_trusted == is_trusted)\\n\\n    if search:\\n        search_pattern = f\\\"%{search}%\\\"\\n        query = query.filter(\\n            or_(\\n                Device.device_name.ilike(search_pattern),\\n                Device.model.ilike(search_pattern),\\n                Device.notes.ilike(search_pattern)\\n            )\\n        )\\n\\n    total = query.count()\\n\\n    # Order by primary, then last_seen, then created\\n    query = query.order_by(\\n        Device.is_primary.desc(),\\n        Device.last_seen_at.desc().nullslast(),\\n        Device.created_at.desc()\\n    )\\n\\n    offset = (page - 1) * page_size\\n    items = query.offset(offset).limit(page_size).all()\\n\\n    pages = (total + page_size - 1) // page_size\\n\\n    return DeviceListResponse(\\n        items=items,\\n        total=total,\\n        page=page,\\n        page_size=page_size,\\n        pages=pages\\n    )\\n\\n\\n@router.get(\\\"/manufacturers\\\", response_model=List[str])\\nasync def list_manufacturers(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get all unique manufacturers from user's devices.\\\"\\\"\\\"\\n    manufacturers = db.query(Device.manufacturer).filter(\\n        and_(\\n            Device.user_id == current_user.id,\\n            Device.deleted_at.is_(None),\\n            Device.manufacturer.isnot(None)\\n        )\\n    ).distinct().order_by(Device.manufacturer).all()\\n\\n    return [mfr[0] for mfr in manufacturers if mfr[0]]\\n\\n\\n@router.post(\\\"/{device_id}/heartbeat\\\", response_model=DeviceResponse)\\nasync def record_heartbeat(\\n    device_id: UUID,\\n    ip_address: Optional[str] = None,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"\\n    Record a device heartbeat to update last_seen_at.\\n    Useful for tracking device activity and presence.\\n    \\\"\\\"\\\"\\n    device = db.query(Device).filter(\\n        and_(\\n            Device.id == device_id,\\n            Device.user_id == current_user.id,\\n            Device.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not device:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Device not found\\\"\\n        )\\n\\n    device.last_seen_at = datetime.utcnow()\\n    if ip_address:\\n        device.ip_address = ip_address\\n\\n    device.updated_at = datetime.utcnow()\\n    db.commit()\\n    db.refresh(device)\\n\\n    return device\\n\\n\\n@router.post(\\\"/{device_id}/trust\\\", response_model=DeviceResponse)\\nasync def trust_device(\\n    device_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Mark a device as trusted.\\\"\\\"\\\"\\n    device = db.query(Device).filter(\\n        and_(\\n            Device.id == device_id,\\n            Device.user_id == current_user.id,\\n            Device.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not device:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Device not found\\\"\\n        )\\n\\n    device.is_trusted = True\\n    device.updated_at = datetime.utcnow()\\n    db.commit()\\n    db.refresh(device)\\n\\n    return device\\n\\n\\n@router.post(\\\"/{device_id}/untrust\\\", response_model=DeviceResponse)\\nasync def untrust_device(\\n    device_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Mark a device as untrusted.\\\"\\\"\\\"\\n    device = db.query(Device).filter(\\n        and_(\\n            Device.id == device_id,\\n            Device.user_id == current_user.id,\\n            Device.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not device:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Device not found\\\"\\n        )\\n\\n    device.is_trusted = False\\n    device.updated_at = datetime.utcnow()\\n    db.commit()\\n    db.refresh(device)\\n\\n    return device\\n\\n\\n@router.get(\\\"/{device_id}\\\", response_model=DeviceResponse)\\nasync def get_device(\\n    device_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get a specific device by ID.\\\"\\\"\\\"\\n    device = db.query(Device).filter(\\n        and_(\\n            Device.id == device_id,\\n            Device.user_id == current_user.id,\\n            Device.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not device:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Device not found\\\"\\n        )\\n\\n    return device\\n\\n\\n@router.patch(\\\"/{device_id}\\\", response_model=DeviceResponse)\\nasync def update_device(\\n    device_id: UUID,\\n    device_data: DeviceUpdate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Update a device's information.\\\"\\\"\\\"\\n    device =\n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-15T11:53:54.977315+00:00",
  "updated_at": "2026-02-15T11:53:54.977315+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:2"
}