{
  "address": "0.1.2.3.0.1.0.5.2",
  "type_address": null,
  "data": {
    "name": "2",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\0\\5\\2",
    "content_preview": "{\n  \"address\": \"0.1.0.5.2\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"02-Link-Model-Specification.md\",\n    \"type\": \"file\",\n    \"extension\": \".md\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.0 - Planning & Documentation\\\\API-Design\\\\02-Link-Model-Specification.md\",\n    \"size\": 26297,\n    \"content\": \"# Hypernet Core - Link Model Specification\\n\\n**Version:** 0.1.0\\n**Last Updated:** 2026-02-03\\n**Status:** Design Phase\\n**Related:** 01-Object-Model-Specification.md, Database-Design/\\n\\n---\\n\\n## Table of Contents\\n\\n1. [Overview](#overview)\\n2. [Design Philosophy](#design-philosophy)\\n3. [Link Types](#link-types)\\n4. [Link Semantics](#link-semantics)\\n5. [Link Operations](#link-operations)\\n6. [Querying Links](#querying-links)\\n7. [Link Constraints](#link-constraints)\\n8. [Examples](#examples)\\n\\n---\\n\\n## Overview\\n\\nLinks represent **relationships between objects** in Hypernet. Unlike traditional foreign keys, links are **first-class objects** with their own properties, metadata, and lifecycle.\\n\\n### Why First-Class Links?\\n\\n**Traditional Approach (Foreign Keys):**\\n```python\\nclass Media:\\n    album_id: UUID  # Can only be in one album\\n```\\n\\n**Problems:**\\n- Media can only belong to one album\\n- Can't represent many-to-many relationships\\n- Can't add metadata to relationships (when added, why, confidence)\\n- Hard to query \\\"all relationships for object X\\\"\\n\\n**Hypernet Approach (Link Objects):**\\n```python\\nclass Link:\\n    from_object_id: UUID  # Album\\n    to_object_id: UUID    # Media\\n    link_type: \\\"contains\\\"\\n    strength: 1.0\\n    metadata: {\\\"added_by\\\": \\\"user\\\", \\\"date\\\": \\\"...\\\"}\\n```\\n\\n**Benefits:**\\n- \\u2705 Media can be in multiple albums\\n- \\u2705 Rich metadata on relationships (who, when, why, confidence)\\n- \\u2705 Flexible relationship types without schema changes\\n- \\u2705 Easy to query all relationships for an object\\n- \\u2705 Can represent complex graphs (not just trees)\\n\\n---\\n\\n## Design Philosophy\\n\\n### Principles\\n\\n1. **Links are Objects**\\n   - Have unique IDs, timestamps, metadata\\n   - Can be created, read, updated, deleted\\n   - Belong to a user (same as from/to objects)\\n\\n2. **Directionality**\\n   - Links have direction: `from_object \\u2192 to_object`\\n   - Can be marked bidirectional if semantics are symmetric\\n   - Examples:\\n     - `Album \\u2192 Media` (unidirectional: album contains media)\\n     - `Media \\u2194 Media` (bidirectional: duplicate_of is symmetric)\\n\\n3. **Type Safety**\\n   - Link types define allowed from/to object types\\n   - Validation enforced at API level\\n   - Examples:\\n     - `contains`: Only `Album \\u2192 Media` or `Album \\u2192 Album`\\n     - `source`: Only `Media \\u2192 Integration`\\n\\n4. **Cardinality**\\n   - Link types define allowed cardinality (one-to-one, one-to-many, many-to-many)\\n   - Enforced by database constraints or application logic\\n   - Examples:\\n     - `Album \\u2192 Media`: One-to-many (album can have many media)\\n     - `Media \\u2192 Integration`: Many-to-one (media has one source)\\n\\n5. **Ordering**\\n   - Links can be ordered via `sort_order` field\\n   - Used for sequences (photos in album, slides in presentation)\\n   - Null `sort_order` means unordered\\n\\n6. **Strength/Confidence**\\n   - Links have `strength` field (0.0 to 1.0)\\n   - Used for:\\n     - Confidence in automated links (AI-detected duplicates: 0.85)\\n     - User-confirmed links (user says \\\"this is a duplicate\\\": 1.0)\\n     - Weak suggestions (might be related: 0.3)\\n\\n---\\n\\n## Link Types\\n\\n### Phase 1 Link Types\\n\\n| Link Type | From \\u2192 To | Bidirectional | Cardinality | Description |\\n|-----------|-----------|---------------|-------------|-------------|\\n| **contains** | Album \\u2192 Media | No | 1:N | Album contains media items |\\n| **contains** | Album \\u2192 Album | No | 1:N | Album contains sub-albums (nested) |\\n| **source** | Media \\u2192 Integration | No | N:1 | Media sourced from integration |\\n| **duplicate_of** | Media \\u2192 Media | Yes | N:N | Media is duplicate of another |\\n| **variant_of** | Media \\u2192 Media | No | N:1 | Media is variant (thumbnail, edited) |\\n\\n### Phase 2+ Link Types (Future)\\n\\n| Link Type | From \\u2192 To | Bidirectional | Cardinality | Description |\\n|-----------|-----------|---------------|-------------|-------------|\\n| **tagged_with** | Media \\u2192 Tag | No | N:N | Media has tag |\\n| **depicts** | Media \\u2192 Contact | No | N:N | Media shows person (face detection) |\\n| **taken_at** | Media \\u2192 Location | No | N:1 | Media taken at location |\\n| **posted_to** | Media \\u2192 Post | No | 1:N | Media shared in social post |\\n| **sent_in** | Media \\u2192 Message | No | N:N | Media attached to message |\\n| **related_to** | Any \\u2192 Any | Yes | N:N | Generic relationship (user-defined) |\\n\\n---\\n\\n## Link Semantics\\n\\n### `contains` (Album \\u2192 Media)\\n\\n**Meaning:** Album contains media item\\n\\n**Properties:**\\n- **Directionality:** Unidirectional (Album owns the relationship)\\n- **Cardinality:** One-to-many (album can have many media, media can be in many albums)\\n- **Ordered:** Yes (via `sort_order` field)\\n- **Strength:** Always 1.0 (user explicitly added to album)\\n\\n**Use Cases:**\\n- User creates album \\\"Vacation 2026\\\" and adds photos\\n- Photos displayed in album order (sorted by `sort_order`)\\n- Deleting link removes photo from album (but doesn't delete photo)\\n\\n**Validation:**\\n- `from_object_type` must be \\\"album\\\"\\n- `to_object_type` must be \\\"media\\\"\\n- Both objects must belong to same user\\n- `sort_order` must be unique within album (no two photos at same position)\\n\\n**Database Constraints:**\\n- Unique: `(from_object_id, to_object_id)` - can't add same photo twice\\n- Check: `from_object_type = 'album' AND to_object_type = 'media'`\\n\\n**Example:**\\n```json\\n{\\n  \\\"from_object_id\\\": \\\"album-uuid\\\",\\n  \\\"from_object_type\\\": \\\"album\\\",\\n  \\\"to_object_id\\\": \\\"photo-uuid\\\",\\n  \\\"to_object_type\\\": \\\"media\\\",\\n  \\\"link_type\\\": \\\"contains\\\",\\n  \\\"strength\\\": 1.0,\\n  \\\"is_bidirectional\\\": false,\\n  \\\"sort_order\\\": 5,\\n  \\\"metadata\\\": {\\n    \\\"created_by\\\": \\\"user\\\",\\n    \\\"added_at\\\": \\\"2026-02-03T12:00:00Z\\\"\\n  }\\n}\\n```\\n\\n---\\n\\n### `contains` (Album \\u2192 Album)\\n\\n**Meaning:** Album contains sub-album (nested albums)\\n\\n**Properties:**\\n- **Directionality:** Unidirectional (parent album owns relationship)\\n- **Cardinality:** One-to-many (album can have many sub-albums)\\n- **Ordered:** Yes (via `sort_order`)\\n- **Strength:** Always 1.0\\n\\n**Use Cases:**\\n- User organizes albums hierarchically:\\n  - \\\"Vacations\\\" (parent album)\\n    - \\\"Europe 2025\\\" (sub-album)\\n    - \\\"Asia 2026\\\" (sub-album)\\n\\n**Validation:**\\n- `from_object_type` must be \\\"album\\\"\\n- `to_object_type` must be \\\"album\\\"\\n- Both albums must belong to same user\\n- **Circular Reference Prevention:** Album can't contain itself (directly or indirectly)\\n\\n**Circular Reference Check:**\\n```python\\ndef can_add_subalbum(parent_id, child_id):\\n    \\\"\\\"\\\"Prevent circular references in album hierarchy\\\"\\\"\\\"\\n    # Check if child is ancestor of parent\\n    ancestors = get_ancestor_albums(parent_id)\\n    if child_id in ancestors:\\n        raise ValueError(\\\"Would create circular reference\\\")\\n    return True\\n```\\n\\n---\\n\\n### `source` (Media \\u2192 Integration)\\n\\n**Meaning:** Media was imported from external integration\\n\\n**Properties:**\\n- **Directionality:** Unidirectional (media points to source)\\n- **Cardinality:** Many-to-one (many media from one integration)\\n- **Ordered:** No\\n- **Strength:** Always 1.0 (definitive source tracking)\\n\\n**Use Cases:**\\n- Track which integration a photo came from (Instagram, Google Photos, etc.)\\n- Enable re-sync or update from source\\n- Prevent duplicate imports (check if media with same source_id exists)\\n\\n**Validation:**\\n- `from_object_type` must be \\\"media\\\"\\n- `to_object_type` must be \\\"integration\\\"\\n- Both objects must belong to same user\\n- Media can only have **one source** (enforced by unique constraint)\\n\\n**Database Constraints:**\\n- Unique: `(from_object_id)` - media can only have one source\\n- Check: `from_object_type = 'media' AND to_object_type = 'integration'`\\n\\n**Example:**\\n```json\\n{\\n  \\\"from_object_id\\\": \\\"photo-uuid\\\",\\n  \\\"from_object_type\\\": \\\"media\\\",\\n  \\\"to_object_id\\\": \\\"instagram-integration-uuid\\\",\\n  \\\"to_object_type\\\": \\\"integration\\\",\\n  \\\"link_type\\\": \\\"source\\\",\\n  \\\"strength\\\": 1.0,\\n  \\\"is_bidirectional\\\": false,\\n  \\\"sort_order\\\": null,\\n  \\\"metadata\\\": {\\n    \\\"created_by\\\": \\\"system\\\",\\n    \\\"sync_timestamp\\\": \\\"2026-02-03T10:30:00Z\\\",\\n    \\\"external_id\\\": \\\"instagram_post_abc123\\\"\\n  }\\n}\\n```\\n\\n---\\n\\n### `duplicate_of` (Media \\u2192 Media)\\n\\n**Meaning:** Media is a duplicate of another media\\n\\n**Properties:**\\n- **Directionality:** Bidirectional (if A is duplicate of B, then B is duplicate of A)\\n- **Cardinality:** Many-to-many (complex duplicate graphs possible)\\n- **Ordered:** No\\n- **Strength:** 0.0 to 1.0 (confidence in duplicate detection)\\n\\n**Use Cases:**\\n- Automatic duplicate detection (same hash or perceptual hash)\\n- User confirms/rejects duplicates\\n- Display deduplicated media views\\n- Bulk operations (delete all duplicates)\\n\\n**Validation:**\\n- `from_object_type` and `to_object_type` must both be \\\"media\\\"\\n- Both objects must belong to same user\\n- Objects must be different (`from_object_id != to_object_id`)\\n- When creating A \\u2192 B, automatically create B \\u2192 A (bidirectional)\\n\\n**Strength Values:**\\n- `1.0`: User confirmed duplicate\\n- `0.9-0.99`: Identical hash (definite duplicate)\\n- `0.7-0.89`: High perceptual similarity (very likely duplicate)\\n- `0.5-0.69`: Moderate similarity (possible duplicate, needs review)\\n- `< 0.5`: Low confidence (suggestion only)\\n\\n**Example:**\\n```json\\n// Link 1: Photo A \\u2192 Photo B\\n{\\n  \\\"from_object_id\\\": \\\"photo-a-uuid\\\",\\n  \\\"from_object_type\\\": \\\"media\\\",\\n  \\\"to_object_id\\\": \\\"photo-b-uuid\\\",\\n  \\\"to_object_type\\\": \\\"media\\\",\\n  \\\"link_type\\\": \\\"d\n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-15T11:53:54.521673+00:00",
  "updated_at": "2026-02-15T11:53:54.521673+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:2"
}