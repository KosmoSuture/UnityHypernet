{
  "address": "0.1.12.4.0.1.1.1.7.1",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\1\\1\\7\\node.json",
    "size": 12039,
    "content": "{\n  \"address\": \"0.1.1.1.7\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"profile_attributes.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\app\\\\routes\\\\profile_attributes.py\",\n    \"size\": 11410,\n    \"content\": \"\\\"\\\"\\\"\\nProfile Attributes API Routes\\n\\nProvides CRUD operations for user profile attributes including\\npreferences, settings, skills, interests, and custom data fields.\\n\\\"\\\"\\\"\\n\\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\\nfrom sqlalchemy.orm import Session\\nfrom sqlalchemy import and_, or_\\nfrom typing import Optional, List, Any, Dict\\nfrom datetime import datetime\\nfrom uuid import UUID\\nfrom pydantic import BaseModel, Field\\n\\nfrom app.core.database import get_db\\nfrom app.core.dependencies import get_current_user\\nfrom app.models.user import User\\nfrom app.models.profile_attribute import ProfileAttribute\\n\\n\\nrouter = APIRouter()\\n\\n\\n# Pydantic Models for Request/Response\\nclass ProfileAttributeCreate(BaseModel):\\n    attribute_type: str = Field(..., description=\\\"preference, skill, interest, certification, education, work_experience, custom\\\")\\n    key: str = Field(..., max_length=200, description=\\\"Attribute key/name\\\")\\n    value: Any = Field(..., description=\\\"Attribute value (can be string, number, boolean, object)\\\")\\n    category: Optional[str] = Field(None, max_length=100)\\n    is_public: bool = Field(default=False, description=\\\"Whether this attribute is publicly visible\\\")\\n    is_verified: bool = Field(default=False, description=\\\"Whether this attribute has been verified\\\")\\n    verification_source: Optional[str] = Field(None, max_length=200)\\n    priority: int = Field(default=0, description=\\\"Display priority (higher = more important)\\\")\\n    tags: List[str] = Field(default_factory=list)\\n    notes: Optional[str] = None\\n\\n\\nclass ProfileAttributeUpdate(BaseModel):\\n    value: Optional[Any] = None\\n    category: Optional[str] = Field(None, max_length=100)\\n    is_public: Optional[bool] = None\\n    is_verified: Optional[bool] = None\\n    verification_source: Optional[str] = Field(None, max_length=200)\\n    priority: Optional[int] = None\\n    tags: Optional[List[str]] = None\\n    notes: Optional[str] = None\\n\\n\\nclass ProfileAttributeResponse(BaseModel):\\n    id: UUID\\n    user_id: UUID\\n    attribute_type: str\\n    key: str\\n    value: Any\\n    category: Optional[str]\\n    is_public: bool\\n    is_verified: bool\\n    verification_source: Optional[str]\\n    priority: int\\n    tags: List[str]\\n    notes: Optional[str]\\n    created_at: datetime\\n    updated_at: datetime\\n\\n    class Config:\\n        from_attributes = True\\n\\n\\nclass ProfileAttributeListResponse(BaseModel):\\n    items: List[ProfileAttributeResponse]\\n    total: int\\n    page: int\\n    page_size: int\\n    pages: int\\n\\n\\nclass ProfileSummary(BaseModel):\\n    \\\"\\\"\\\"Summary of profile attributes grouped by type.\\\"\\\"\\\"\\n    attribute_type: str\\n    count: int\\n    public_count: int\\n    verified_count: int\\n\\n\\n# Endpoints\\n@router.post(\\\"\\\", response_model=ProfileAttributeResponse, status_code=status.HTTP_201_CREATED)\\nasync def create_profile_attribute(\\n    attribute_data: ProfileAttributeCreate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Create a new profile attribute.\\\"\\\"\\\"\\n    attribute = ProfileAttribute(\\n        user_id=current_user.id,\\n        **attribute_data.dict()\\n    )\\n    db.add(attribute)\\n    db.commit()\\n    db.refresh(attribute)\\n    return attribute\\n\\n\\n@router.get(\\\"\\\", response_model=ProfileAttributeListResponse)\\nasync def list_profile_attributes(\\n    attribute_type: Optional[str] = Query(None, description=\\\"Filter by attribute type\\\"),\\n    category: Optional[str] = Query(None, description=\\\"Filter by category\\\"),\\n    is_public: Optional[bool] = Query(None, description=\\\"Filter by public visibility\\\"),\\n    is_verified: Optional[bool] = Query(None, description=\\\"Filter by verification status\\\"),\\n    tag: Optional[str] = Query(None, description=\\\"Filter by tag\\\"),\\n    search: Optional[str] = Query(None, description=\\\"Search in key, value, notes\\\"),\\n    page: int = Query(1, ge=1, description=\\\"Page number\\\"),\\n    page_size: int = Query(50, ge=1, le=100, description=\\\"Items per page\\\"),\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"List profile attributes with optional filtering.\\\"\\\"\\\"\\n    query = db.query(ProfileAttribute).filter(\\n        and_(\\n            ProfileAttribute.user_id == current_user.id,\\n            ProfileAttribute.deleted_at.is_(None)\\n        )\\n    )\\n\\n    if attribute_type:\\n        query = query.filter(ProfileAttribute.attribute_type == attribute_type)\\n\\n    if category:\\n        query = query.filter(ProfileAttribute.category == category)\\n\\n    if is_public is not None:\\n        query = query.filter(ProfileAttribute.is_public == is_public)\\n\\n    if is_verified is not None:\\n        query = query.filter(ProfileAttribute.is_verified == is_verified)\\n\\n    if tag:\\n        query = query.filter(ProfileAttribute.tags.contains([tag]))\\n\\n    if search:\\n        search_pattern = f\\\"%{search}%\\\"\\n        # Convert value JSONB to text for searching\\n        from sqlalchemy import cast, Text\\n        query = query.filter(\\n            or_(\\n                ProfileAttribute.key.ilike(search_pattern),\\n                cast(ProfileAttribute.value, Text).ilike(search_pattern),\\n                ProfileAttribute.notes.ilike(search_pattern)\\n            )\\n        )\\n\\n    total = query.count()\\n\\n    # Order by priority descending, then created_at\\n    query = query.order_by(\\n        ProfileAttribute.priority.desc(),\\n        ProfileAttribute.created_at.desc()\\n    )\\n\\n    offset = (page - 1) * page_size\\n    items = query.offset(offset).limit(page_size).all()\\n\\n    pages = (total + page_size - 1) // page_size\\n\\n    return ProfileAttributeListResponse(\\n        items=items,\\n        total=total,\\n        page=page,\\n        page_size=page_size,\\n        pages=pages\\n    )\\n\\n\\n@router.get(\\\"/summary\\\", response_model=List[ProfileSummary])\\nasync def get_profile_summary(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get summary of profile attributes grouped by type.\\\"\\\"\\\"\\n    from sqlalchemy import func, case\\n\\n    results = db.query(\\n        ProfileAttribute.attribute_type,\\n        func.count(ProfileAttribute.id).label('count'),\\n        func.sum(case((ProfileAttribute.is_public == True, 1), else_=0)).label('public_count'),\\n        func.sum(case((ProfileAttribute.is_verified == True, 1), else_=0)).label('verified_count')\\n    ).filter(\\n        and_(\\n            ProfileAttribute.user_id == current_user.id,\\n            ProfileAttribute.deleted_at.is_(None)\\n        )\\n    ).group_by(ProfileAttribute.attribute_type).all()\\n\\n    return [\\n        ProfileSummary(\\n            attribute_type=row.attribute_type,\\n            count=row.count,\\n            public_count=row.public_count or 0,\\n            verified_count=row.verified_count or 0\\n        )\\n        for row in results\\n    ]\\n\\n\\n@router.get(\\\"/public\\\", response_model=ProfileAttributeListResponse)\\nasync def list_public_attributes(\\n    user_id: UUID = Query(..., description=\\\"User ID to get public attributes for\\\"),\\n    attribute_type: Optional[str] = Query(None, description=\\\"Filter by attribute type\\\"),\\n    page: int = Query(1, ge=1, description=\\\"Page number\\\"),\\n    page_size: int = Query(50, ge=1, le=100, description=\\\"Items per page\\\"),\\n    db: Session = Depends(get_db)\\n):\\n    \\\"\\\"\\\"\\n    List public profile attributes for any user.\\n    This endpoint doesn't require authentication and only returns public attributes.\\n    \\\"\\\"\\\"\\n    query = db.query(ProfileAttribute).filter(\\n        and_(\\n            ProfileAttribute.user_id == user_id,\\n            ProfileAttribute.deleted_at.is_(None),\\n            ProfileAttribute.is_public == True\\n        )\\n    )\\n\\n    if attribute_type:\\n        query = query.filter(ProfileAttribute.attribute_type == attribute_type)\\n\\n    total = query.count()\\n\\n    query = query.order_by(\\n        ProfileAttribute.priority.desc(),\\n        ProfileAttribute.created_at.desc()\\n    )\\n\\n    offset = (page - 1) * page_size\\n    items = query.offset(offset).limit(page_size).all()\\n\\n    pages = (total + page_size - 1) // page_size\\n\\n    return ProfileAttributeListResponse(\\n        items=items,\\n        total=total,\\n        page=page,\\n        page_size=page_size,\\n        pages=pages\\n    )\\n\\n\\n@router.get(\\\"/categories\\\", response_model=List[str])\\nasync def list_categories(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get all unique categories from user's profile attributes.\\\"\\\"\\\"\\n    categories = db.query(ProfileAttribute.category).filter(\\n        and_(\\n            ProfileAttribute.user_id == current_user.id,\\n            ProfileAttribute.deleted_at.is_(None),\\n            ProfileAttribute.category.isnot(None)\\n        )\\n    ).distinct().order_by(ProfileAttribute.category).all()\\n\\n    return [cat[0] for cat in categories if cat[0]]\\n\\n\\n@router.get(\\\"/{attribute_id}\\\", response_model=ProfileAttributeResponse)\\nasync def get_profile_attribute(\\n    attribute_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get a specific profile attribute by ID.\\\"\\\"\\\"\\n    attribute = db.query(ProfileAttribute).filter(\\n        and_(\\n            ProfileAttribute.id == attribute_id,\\n            ProfileAttribute.user_id == current_user.id,\\n            ProfileAttribute.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not attribute:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Profile attribute not found\\\"\\n        )\\n\\n    return attribute\\n\\n\\n@router.patch(\\\"/{attribute_id}\\\", response_model=ProfileAttributeResponse)\\nasync def update_profile_attribute(\\n    attribute_id: UUID,\\n    attribute_data: ProfileAttributeUpdate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Update a profile attribute.\\\"\\\"\\\"\\n    attribute = db.query(ProfileAttribute).filter(\\n        and_(\\n            ProfileAttribute.id == attribute_id,\\n            ProfileAttribute.user_id == current_user.id,\\n            ProfileAttribute.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not attribute:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Profile attribute not found\\\"\\n        )\\n\\n    update_data = attribute_data.dict(exclude_unset=True)\\n    for field, value in update_data.items():\\n        setattr(attribute, field, value)\\n\\n    attribute.updated_at = datetime.utcnow()\\n    db.commit()\\n    db.refresh(attribute)\\n\\n    return attribute\\n\\n\\n@router.delete(\\\"/{attribute_id}\\\", status_code=status.HTTP_204_NO_CONTENT)\\nasync def delete_profile_attribute(\\n    attribute_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Soft delete a profile attribute.\\\"\\\"\\\"\\n    attribute = db.query(ProfileAttribute).filter(\\n        and_(\\n            ProfileAttribute.id == attribute_id,\\n            ProfileAttribute.user_id == current_user.id,\\n            ProfileAttribute.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not attribute:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Profile attribute not found\\\"\\n        )\\n\\n    attribute.deleted_at = datetime.utcnow()\\n    db.commit()\\n\\n    return None\\n\"\n  },\n  \"created_at\": \"2026-02-15T11:53:48.887349+00:00\",\n  \"updated_at\": \"2026-02-15T11:53:48.887349+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"file:profile_attributes.py\"\n}"
  },
  "created_at": "2026-02-17T01:23:12.551319+00:00",
  "updated_at": "2026-02-17T01:23:12.551319+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}