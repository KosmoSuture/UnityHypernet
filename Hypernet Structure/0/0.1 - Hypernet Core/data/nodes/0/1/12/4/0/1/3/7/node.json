{
  "address": "0.1.12.4.0.1.3.7",
  "type_address": null,
  "data": {
    "name": "7",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\3\\7",
    "content_preview": "{\n  \"address\": \"0.1.3.7\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"store.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\hypernet\\\\store.py\",\n    \"size\": 11540,\n    \"content\": \"\\\"\\\"\\\"\\nHypernet Store\\n\\nFile-backed storage for nodes and links. The Hypernet IS the database \\u2014\\nthis is not a wrapper around SQL or a traditional DB. Data is stored as\\nJSON files in a hierarchy matching the address structure.\\n\\nStorage layout:\\n  data/\\n    nodes/\\n      1/1/1/1/00001.json     (node at address 1.1.1.1.00001)\\n      2/1/node.json           (node at address 2.1)\\n    links/\\n      <hash>.json             (link files, indexed by endpoints)\\n    indexes/\\n      by_type.json            (type_address -> [node addresses])\\n      by_owner.json           (owner_address -> [node addresses])\\n      links_from.json         (from_address -> [link hashes])\\n      links_to.json           (to_address -> [link hashes])\\n\\nThis can be swapped for a more efficient backend later without\\nchanging the Node/Link/Graph interfaces.\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\nimport json\\nimport hashlib\\nfrom pathlib import Path\\nfrom typing import Optional\\n\\nfrom .address import HypernetAddress\\nfrom .node import Node\\nfrom .link import Link\\n\\n\\nclass Store:\\n    \\\"\\\"\\\"File-backed storage for Hypernet nodes and links.\\\"\\\"\\\"\\n\\n    def __init__(self, root: str | Path):\\n        self.root = Path(root)\\n        self._nodes_dir = self.root / \\\"nodes\\\"\\n        self._links_dir = self.root / \\\"links\\\"\\n        self._index_dir = self.root / \\\"indexes\\\"\\n\\n        # In-memory indexes (loaded from disk on init, persisted on write)\\n        self._node_index: dict[str, str] = {}         # address -> node file path\\n        self._type_index: dict[str, list[str]] = {}    # type_address -> [node addresses]\\n        self._owner_index: dict[str, list[str]] = {}   # owner_address -> [node addresses]\\n        self._links_from: dict[str, list[str]] = {}    # from_address -> [link hashes]\\n        self._links_to: dict[str, list[str]] = {}      # to_address -> [link hashes]\\n\\n        self._ensure_dirs()\\n        self._load_indexes()\\n\\n    def _ensure_dirs(self) -> None:\\n        self._nodes_dir.mkdir(parents=True, exist_ok=True)\\n        self._links_dir.mkdir(parents=True, exist_ok=True)\\n        self._index_dir.mkdir(parents=True, exist_ok=True)\\n\\n    # =========================================================================\\n    # Node Operations\\n    # =========================================================================\\n\\n    def put_node(self, node: Node) -> None:\\n        \\\"\\\"\\\"Store a node. Creates or overwrites.\\\"\\\"\\\"\\n        path = self._node_path(node.address)\\n        path.parent.mkdir(parents=True, exist_ok=True)\\n        path.write_text(json.dumps(node.to_dict(), indent=2, default=str), encoding=\\\"utf-8\\\")\\n\\n        # Update indexes\\n        addr_str = str(node.address)\\n        self._node_index[addr_str] = str(path)\\n\\n        if node.type_address:\\n            type_str = str(node.type_address)\\n            if type_str not in self._type_index:\\n                self._type_index[type_str] = []\\n            if addr_str not in self._type_index[type_str]:\\n                self._type_index[type_str].append(addr_str)\\n\\n        if node.owner:\\n            owner_str = str(node.owner)\\n            if owner_str not in self._owner_index:\\n                self._owner_index[owner_str] = []\\n            if addr_str not in self._owner_index[owner_str]:\\n                self._owner_index[owner_str].append(addr_str)\\n\\n        self._save_indexes()\\n\\n    def get_node(self, address: HypernetAddress) -> Optional[Node]:\\n        \\\"\\\"\\\"Retrieve a node by address. Returns None if not found.\\\"\\\"\\\"\\n        path = self._node_path(address)\\n        if not path.exists():\\n            return None\\n        data = json.loads(path.read_text(encoding=\\\"utf-8\\\"))\\n        return Node.from_dict(data)\\n\\n    def delete_node(self, address: HypernetAddress, hard: bool = False) -> bool:\\n        \\\"\\\"\\\"Soft-delete a node (or hard-delete if specified).\\\"\\\"\\\"\\n        node = self.get_node(address)\\n        if node is None:\\n            return False\\n\\n        if hard:\\n            path = self._node_path(address)\\n            path.unlink(missing_ok=True)\\n            addr_str = str(address)\\n            self._node_index.pop(addr_str, None)\\n            for idx in (self._type_index, self._owner_index):\\n                for key in idx:\\n                    if addr_str in idx[key]:\\n                        idx[key].remove(addr_str)\\n        else:\\n            node.soft_delete()\\n            self.put_node(node)\\n\\n        self._save_indexes()\\n        return True\\n\\n    def list_nodes(\\n        self,\\n        prefix: Optional[HypernetAddress] = None,\\n        type_address: Optional[HypernetAddress] = None,\\n        owner: Optional[HypernetAddress] = None,\\n        include_deleted: bool = False,\\n    ) -> list[Node]:\\n        \\\"\\\"\\\"List nodes with optional filtering.\\\"\\\"\\\"\\n        addresses: set[str] | None = None\\n\\n        if type_address:\\n            type_str = str(type_address)\\n            addresses = set(self._type_index.get(type_str, []))\\n\\n        if owner:\\n            owner_str = str(owner)\\n            owner_addrs = set(self._owner_index.get(owner_str, []))\\n            addresses = owner_addrs if addresses is None else addresses & owner_addrs\\n\\n        if addresses is None:\\n            addresses = set(self._node_index.keys())\\n\\n        results = []\\n        for addr_str in sorted(addresses):\\n            addr = HypernetAddress.parse(addr_str)\\n            if prefix and not prefix.is_ancestor_of(addr) and prefix != addr:\\n                continue\\n            node = self.get_node(addr)\\n            if node and (include_deleted or not node.is_deleted):\\n                results.append(node)\\n\\n        return results\\n\\n    def count_instances(self, prefix: HypernetAddress) -> int:\\n        \\\"\\\"\\\"Count instance nodes under an address prefix.\\\"\\\"\\\"\\n        count = 0\\n        for addr_str in self._node_index:\\n            addr = HypernetAddress.parse(addr_str)\\n            if prefix.is_ancestor_of(addr) and addr.is_instance:\\n                count += 1\\n        return count\\n\\n    def next_address(self, prefix: HypernetAddress) -> HypernetAddress:\\n        \\\"\\\"\\\"Generate the next available instance address under a prefix.\\\"\\\"\\\"\\n        max_instance = 0\\n        for addr_str in self._node_index:\\n            addr = HypernetAddress.parse(addr_str)\\n            if prefix.is_ancestor_of(addr) and addr.is_instance:\\n                try:\\n                    instance_num = int(addr.parts[-1])\\n                    max_instance = max(max_instance, instance_num)\\n                except ValueError:\\n                    pass\\n        return prefix.next_instance(max_instance)\\n\\n    # =========================================================================\\n    # Link Operations\\n    # =========================================================================\\n\\n    def put_link(self, link: Link) -> str:\\n        \\\"\\\"\\\"Store a link. Returns the link hash (its identifier).\\\"\\\"\\\"\\n        link_hash = self._link_hash(link)\\n        path = self._links_dir / f\\\"{link_hash}.json\\\"\\n        path.write_text(json.dumps(link.to_dict(), indent=2, default=str), encoding=\\\"utf-8\\\")\\n\\n        # Update link indexes\\n        from_str = str(link.from_address)\\n        to_str = str(link.to_address)\\n\\n        if from_str not in self._links_from:\\n            self._links_from[from_str] = []\\n        if link_hash not in self._links_from[from_str]:\\n            self._links_from[from_str].append(link_hash)\\n\\n        if to_str not in self._links_to:\\n            self._links_to[to_str] = []\\n        if link_hash not in self._links_to[to_str]:\\n            self._links_to[to_str].append(link_hash)\\n\\n        self._save_indexes()\\n        return link_hash\\n\\n    def get_link(self, link_hash: str) -> Optional[Link]:\\n        \\\"\\\"\\\"Retrieve a link by its hash.\\\"\\\"\\\"\\n        path = self._links_dir / f\\\"{link_hash}.json\\\"\\n        if not path.exists():\\n            return None\\n        data = json.loads(path.read_text(encoding=\\\"utf-8\\\"))\\n        return Link.from_dict(data)\\n\\n    def get_links_from(\\n        self,\\n        address: HypernetAddress,\\n        relationship: Optional[str] = None,\\n    ) -> list[Link]:\\n        \\\"\\\"\\\"Get all outgoing links from a node.\\\"\\\"\\\"\\n        addr_str = str(address)\\n        hashes = self._links_from.get(addr_str, [])\\n        links = []\\n        for h in hashes:\\n            link = self.get_link(h)\\n            if link and (relationship is None or link.relationship == relationship):\\n                links.append(link)\\n        return links\\n\\n    def get_links_to(\\n        self,\\n        address: HypernetAddress,\\n        relationship: Optional[str] = None,\\n    ) -> list[Link]:\\n        \\\"\\\"\\\"Get all incoming links to a node.\\\"\\\"\\\"\\n        addr_str = str(address)\\n        hashes = self._links_to.get(addr_str, [])\\n        links = []\\n        for h in hashes:\\n            link = self.get_link(h)\\n            if link and (relationship is None or link.relationship == relationship):\\n                links.append(link)\\n        return links\\n\\n    def get_neighbors(\\n        self,\\n        address: HypernetAddress,\\n        relationship: Optional[str] = None,\\n    ) -> list[HypernetAddress]:\\n        \\\"\\\"\\\"Get all connected node addresses (outgoing + bidirectional incoming).\\\"\\\"\\\"\\n        neighbors = []\\n\\n        for link in self.get_links_from(address, relationship):\\n            neighbors.append(link.to_address)\\n\\n        for link in self.get_links_to(address, relationship):\\n            if link.bidirectional:\\n                neighbors.append(link.from_address)\\n\\n        return neighbors\\n\\n    # =========================================================================\\n   \n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-17T01:23:15.871241+00:00",
  "updated_at": "2026-02-17T01:23:15.871241+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:7"
}