{
  "address": "0.1.12.4.0.1.0.5.2.1",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\0\\5\\2\\node.json",
    "size": 27792,
    "content": "{\n  \"address\": \"0.1.0.5.2\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"02-Link-Model-Specification.md\",\n    \"type\": \"file\",\n    \"extension\": \".md\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.0 - Planning & Documentation\\\\API-Design\\\\02-Link-Model-Specification.md\",\n    \"size\": 26297,\n    \"content\": \"# Hypernet Core - Link Model Specification\\n\\n**Version:** 0.1.0\\n**Last Updated:** 2026-02-03\\n**Status:** Design Phase\\n**Related:** 01-Object-Model-Specification.md, Database-Design/\\n\\n---\\n\\n## Table of Contents\\n\\n1. [Overview](#overview)\\n2. [Design Philosophy](#design-philosophy)\\n3. [Link Types](#link-types)\\n4. [Link Semantics](#link-semantics)\\n5. [Link Operations](#link-operations)\\n6. [Querying Links](#querying-links)\\n7. [Link Constraints](#link-constraints)\\n8. [Examples](#examples)\\n\\n---\\n\\n## Overview\\n\\nLinks represent **relationships between objects** in Hypernet. Unlike traditional foreign keys, links are **first-class objects** with their own properties, metadata, and lifecycle.\\n\\n### Why First-Class Links?\\n\\n**Traditional Approach (Foreign Keys):**\\n```python\\nclass Media:\\n    album_id: UUID  # Can only be in one album\\n```\\n\\n**Problems:**\\n- Media can only belong to one album\\n- Can't represent many-to-many relationships\\n- Can't add metadata to relationships (when added, why, confidence)\\n- Hard to query \\\"all relationships for object X\\\"\\n\\n**Hypernet Approach (Link Objects):**\\n```python\\nclass Link:\\n    from_object_id: UUID  # Album\\n    to_object_id: UUID    # Media\\n    link_type: \\\"contains\\\"\\n    strength: 1.0\\n    metadata: {\\\"added_by\\\": \\\"user\\\", \\\"date\\\": \\\"...\\\"}\\n```\\n\\n**Benefits:**\\n- \\u2705 Media can be in multiple albums\\n- \\u2705 Rich metadata on relationships (who, when, why, confidence)\\n- \\u2705 Flexible relationship types without schema changes\\n- \\u2705 Easy to query all relationships for an object\\n- \\u2705 Can represent complex graphs (not just trees)\\n\\n---\\n\\n## Design Philosophy\\n\\n### Principles\\n\\n1. **Links are Objects**\\n   - Have unique IDs, timestamps, metadata\\n   - Can be created, read, updated, deleted\\n   - Belong to a user (same as from/to objects)\\n\\n2. **Directionality**\\n   - Links have direction: `from_object \\u2192 to_object`\\n   - Can be marked bidirectional if semantics are symmetric\\n   - Examples:\\n     - `Album \\u2192 Media` (unidirectional: album contains media)\\n     - `Media \\u2194 Media` (bidirectional: duplicate_of is symmetric)\\n\\n3. **Type Safety**\\n   - Link types define allowed from/to object types\\n   - Validation enforced at API level\\n   - Examples:\\n     - `contains`: Only `Album \\u2192 Media` or `Album \\u2192 Album`\\n     - `source`: Only `Media \\u2192 Integration`\\n\\n4. **Cardinality**\\n   - Link types define allowed cardinality (one-to-one, one-to-many, many-to-many)\\n   - Enforced by database constraints or application logic\\n   - Examples:\\n     - `Album \\u2192 Media`: One-to-many (album can have many media)\\n     - `Media \\u2192 Integration`: Many-to-one (media has one source)\\n\\n5. **Ordering**\\n   - Links can be ordered via `sort_order` field\\n   - Used for sequences (photos in album, slides in presentation)\\n   - Null `sort_order` means unordered\\n\\n6. **Strength/Confidence**\\n   - Links have `strength` field (0.0 to 1.0)\\n   - Used for:\\n     - Confidence in automated links (AI-detected duplicates: 0.85)\\n     - User-confirmed links (user says \\\"this is a duplicate\\\": 1.0)\\n     - Weak suggestions (might be related: 0.3)\\n\\n---\\n\\n## Link Types\\n\\n### Phase 1 Link Types\\n\\n| Link Type | From \\u2192 To | Bidirectional | Cardinality | Description |\\n|-----------|-----------|---------------|-------------|-------------|\\n| **contains** | Album \\u2192 Media | No | 1:N | Album contains media items |\\n| **contains** | Album \\u2192 Album | No | 1:N | Album contains sub-albums (nested) |\\n| **source** | Media \\u2192 Integration | No | N:1 | Media sourced from integration |\\n| **duplicate_of** | Media \\u2192 Media | Yes | N:N | Media is duplicate of another |\\n| **variant_of** | Media \\u2192 Media | No | N:1 | Media is variant (thumbnail, edited) |\\n\\n### Phase 2+ Link Types (Future)\\n\\n| Link Type | From \\u2192 To | Bidirectional | Cardinality | Description |\\n|-----------|-----------|---------------|-------------|-------------|\\n| **tagged_with** | Media \\u2192 Tag | No | N:N | Media has tag |\\n| **depicts** | Media \\u2192 Contact | No | N:N | Media shows person (face detection) |\\n| **taken_at** | Media \\u2192 Location | No | N:1 | Media taken at location |\\n| **posted_to** | Media \\u2192 Post | No | 1:N | Media shared in social post |\\n| **sent_in** | Media \\u2192 Message | No | N:N | Media attached to message |\\n| **related_to** | Any \\u2192 Any | Yes | N:N | Generic relationship (user-defined) |\\n\\n---\\n\\n## Link Semantics\\n\\n### `contains` (Album \\u2192 Media)\\n\\n**Meaning:** Album contains media item\\n\\n**Properties:**\\n- **Directionality:** Unidirectional (Album owns the relationship)\\n- **Cardinality:** One-to-many (album can have many media, media can be in many albums)\\n- **Ordered:** Yes (via `sort_order` field)\\n- **Strength:** Always 1.0 (user explicitly added to album)\\n\\n**Use Cases:**\\n- User creates album \\\"Vacation 2026\\\" and adds photos\\n- Photos displayed in album order (sorted by `sort_order`)\\n- Deleting link removes photo from album (but doesn't delete photo)\\n\\n**Validation:**\\n- `from_object_type` must be \\\"album\\\"\\n- `to_object_type` must be \\\"media\\\"\\n- Both objects must belong to same user\\n- `sort_order` must be unique within album (no two photos at same position)\\n\\n**Database Constraints:**\\n- Unique: `(from_object_id, to_object_id)` - can't add same photo twice\\n- Check: `from_object_type = 'album' AND to_object_type = 'media'`\\n\\n**Example:**\\n```json\\n{\\n  \\\"from_object_id\\\": \\\"album-uuid\\\",\\n  \\\"from_object_type\\\": \\\"album\\\",\\n  \\\"to_object_id\\\": \\\"photo-uuid\\\",\\n  \\\"to_object_type\\\": \\\"media\\\",\\n  \\\"link_type\\\": \\\"contains\\\",\\n  \\\"strength\\\": 1.0,\\n  \\\"is_bidirectional\\\": false,\\n  \\\"sort_order\\\": 5,\\n  \\\"metadata\\\": {\\n    \\\"created_by\\\": \\\"user\\\",\\n    \\\"added_at\\\": \\\"2026-02-03T12:00:00Z\\\"\\n  }\\n}\\n```\\n\\n---\\n\\n### `contains` (Album \\u2192 Album)\\n\\n**Meaning:** Album contains sub-album (nested albums)\\n\\n**Properties:**\\n- **Directionality:** Unidirectional (parent album owns relationship)\\n- **Cardinality:** One-to-many (album can have many sub-albums)\\n- **Ordered:** Yes (via `sort_order`)\\n- **Strength:** Always 1.0\\n\\n**Use Cases:**\\n- User organizes albums hierarchically:\\n  - \\\"Vacations\\\" (parent album)\\n    - \\\"Europe 2025\\\" (sub-album)\\n    - \\\"Asia 2026\\\" (sub-album)\\n\\n**Validation:**\\n- `from_object_type` must be \\\"album\\\"\\n- `to_object_type` must be \\\"album\\\"\\n- Both albums must belong to same user\\n- **Circular Reference Prevention:** Album can't contain itself (directly or indirectly)\\n\\n**Circular Reference Check:**\\n```python\\ndef can_add_subalbum(parent_id, child_id):\\n    \\\"\\\"\\\"Prevent circular references in album hierarchy\\\"\\\"\\\"\\n    # Check if child is ancestor of parent\\n    ancestors = get_ancestor_albums(parent_id)\\n    if child_id in ancestors:\\n        raise ValueError(\\\"Would create circular reference\\\")\\n    return True\\n```\\n\\n---\\n\\n### `source` (Media \\u2192 Integration)\\n\\n**Meaning:** Media was imported from external integration\\n\\n**Properties:**\\n- **Directionality:** Unidirectional (media points to source)\\n- **Cardinality:** Many-to-one (many media from one integration)\\n- **Ordered:** No\\n- **Strength:** Always 1.0 (definitive source tracking)\\n\\n**Use Cases:**\\n- Track which integration a photo came from (Instagram, Google Photos, etc.)\\n- Enable re-sync or update from source\\n- Prevent duplicate imports (check if media with same source_id exists)\\n\\n**Validation:**\\n- `from_object_type` must be \\\"media\\\"\\n- `to_object_type` must be \\\"integration\\\"\\n- Both objects must belong to same user\\n- Media can only have **one source** (enforced by unique constraint)\\n\\n**Database Constraints:**\\n- Unique: `(from_object_id)` - media can only have one source\\n- Check: `from_object_type = 'media' AND to_object_type = 'integration'`\\n\\n**Example:**\\n```json\\n{\\n  \\\"from_object_id\\\": \\\"photo-uuid\\\",\\n  \\\"from_object_type\\\": \\\"media\\\",\\n  \\\"to_object_id\\\": \\\"instagram-integration-uuid\\\",\\n  \\\"to_object_type\\\": \\\"integration\\\",\\n  \\\"link_type\\\": \\\"source\\\",\\n  \\\"strength\\\": 1.0,\\n  \\\"is_bidirectional\\\": false,\\n  \\\"sort_order\\\": null,\\n  \\\"metadata\\\": {\\n    \\\"created_by\\\": \\\"system\\\",\\n    \\\"sync_timestamp\\\": \\\"2026-02-03T10:30:00Z\\\",\\n    \\\"external_id\\\": \\\"instagram_post_abc123\\\"\\n  }\\n}\\n```\\n\\n---\\n\\n### `duplicate_of` (Media \\u2192 Media)\\n\\n**Meaning:** Media is a duplicate of another media\\n\\n**Properties:**\\n- **Directionality:** Bidirectional (if A is duplicate of B, then B is duplicate of A)\\n- **Cardinality:** Many-to-many (complex duplicate graphs possible)\\n- **Ordered:** No\\n- **Strength:** 0.0 to 1.0 (confidence in duplicate detection)\\n\\n**Use Cases:**\\n- Automatic duplicate detection (same hash or perceptual hash)\\n- User confirms/rejects duplicates\\n- Display deduplicated media views\\n- Bulk operations (delete all duplicates)\\n\\n**Validation:**\\n- `from_object_type` and `to_object_type` must both be \\\"media\\\"\\n- Both objects must belong to same user\\n- Objects must be different (`from_object_id != to_object_id`)\\n- When creating A \\u2192 B, automatically create B \\u2192 A (bidirectional)\\n\\n**Strength Values:**\\n- `1.0`: User confirmed duplicate\\n- `0.9-0.99`: Identical hash (definite duplicate)\\n- `0.7-0.89`: High perceptual similarity (very likely duplicate)\\n- `0.5-0.69`: Moderate similarity (possible duplicate, needs review)\\n- `< 0.5`: Low confidence (suggestion only)\\n\\n**Example:**\\n```json\\n// Link 1: Photo A \\u2192 Photo B\\n{\\n  \\\"from_object_id\\\": \\\"photo-a-uuid\\\",\\n  \\\"from_object_type\\\": \\\"media\\\",\\n  \\\"to_object_id\\\": \\\"photo-b-uuid\\\",\\n  \\\"to_object_type\\\": \\\"media\\\",\\n  \\\"link_type\\\": \\\"duplicate_of\\\",\\n  \\\"strength\\\": 0.95,\\n  \\\"is_bidirectional\\\": true,\\n  \\\"metadata\\\": {\\n    \\\"created_by\\\": \\\"system\\\",\\n    \\\"detection_method\\\": \\\"hash_match\\\",\\n    \\\"hash_match\\\": true,\\n    \\\"perceptual_similarity\\\": 0.98\\n  }\\n}\\n\\n// Link 2: Photo B \\u2192 Photo A (auto-created)\\n{\\n  \\\"from_object_id\\\": \\\"photo-b-uuid\\\",\\n  \\\"from_object_type\\\": \\\"media\\\",\\n  \\\"to_object_id\\\": \\\"photo-a-uuid\\\",\\n  \\\"to_object_type\\\": \\\"media\\\",\\n  \\\"link_type\\\": \\\"duplicate_of\\\",\\n  \\\"strength\\\": 0.95,\\n  \\\"is_bidirectional\\\": true,\\n  \\\"metadata\\\": {\\n    \\\"created_by\\\": \\\"system\\\",\\n    \\\"detection_method\\\": \\\"hash_match\\\",\\n    \\\"hash_match\\\": true,\\n    \\\"perceptual_similarity\\\": 0.98,\\n    \\\"reverse_of\\\": \\\"link-1-uuid\\\"\\n  }\\n}\\n```\\n\\n---\\n\\n### `variant_of` (Media \\u2192 Media)\\n\\n**Meaning:** Media is a variant/derivative of another media\\n\\n**Properties:**\\n- **Directionality:** Unidirectional (variant points to original)\\n- **Cardinality:** Many-to-one (many variants of one original)\\n- **Ordered:** No\\n- **Strength:** Always 1.0 (definitive relationship)\\n\\n**Use Cases:**\\n- Thumbnails of original photos\\n- Edited versions of photos\\n- Transcoded videos (different formats/resolutions)\\n- Cropped or rotated versions\\n\\n**Validation:**\\n- `from_object_type` and `to_object_type` must both be \\\"media\\\"\\n- Both objects must belong to same user\\n- Objects must be different\\n- **No Circular Variants:** Variant can't be variant of itself (directly or indirectly)\\n\\n**Variant Types (in metadata):**\\n```json\\n{\\n  \\\"variant_type\\\": \\\"thumbnail\\\",  // or \\\"edited\\\", \\\"transcoded\\\", \\\"cropped\\\"\\n  \\\"variant_properties\\\": {\\n    \\\"size\\\": \\\"large\\\",           // For thumbnails: \\\"small\\\", \\\"medium\\\", \\\"large\\\"\\n    \\\"operation\\\": \\\"crop\\\",       // For edited: \\\"crop\\\", \\\"rotate\\\", \\\"filter\\\"\\n    \\\"format\\\": \\\"mp4\\\"            // For transcoded: target format\\n  }\\n}\\n```\\n\\n**Example:**\\n```json\\n{\\n  \\\"from_object_id\\\": \\\"thumbnail-uuid\\\",\\n  \\\"from_object_type\\\": \\\"media\\\",\\n  \\\"to_object_id\\\": \\\"original-photo-uuid\\\",\\n  \\\"to_object_type\\\": \\\"media\\\",\\n  \\\"link_type\\\": \\\"variant_of\\\",\\n  \\\"strength\\\": 1.0,\\n  \\\"is_bidirectional\\\": false,\\n  \\\"metadata\\\": {\\n    \\\"created_by\\\": \\\"system\\\",\\n    \\\"variant_type\\\": \\\"thumbnail\\\",\\n    \\\"variant_properties\\\": {\\n      \\\"size\\\": \\\"large\\\",\\n      \\\"dimensions\\\": \\\"800x600\\\",\\n      \\\"generated_at\\\": \\\"2026-02-03T10:00:00Z\\\"\\n    }\\n  }\\n}\\n```\\n\\n---\\n\\n## Link Operations\\n\\n### Creating Links\\n\\n**API Endpoint:** `POST /api/v1/links`\\n\\n**Request:**\\n```json\\n{\\n  \\\"from_object_id\\\": \\\"album-uuid\\\",\\n  \\\"from_object_type\\\": \\\"album\\\",\\n  \\\"to_object_id\\\": \\\"photo-uuid\\\",\\n  \\\"to_object_type\\\": \\\"media\\\",\\n  \\\"link_type\\\": \\\"contains\\\",\\n  \\\"sort_order\\\": 0,\\n  \\\"metadata\\\": {}\\n}\\n```\\n\\n**Validation Steps:**\\n1. Verify user is authenticated\\n2. Verify `from_object` and `to_object` exist\\n3. Verify both objects belong to authenticated user\\n4. Verify link type is valid\\n5. Verify link type allows this from/to combination\\n6. Check for duplicate link (same from, to, type)\\n7. Check cardinality constraints\\n8. If bidirectional link, create reverse link automatically\\n9. Insert link into database\\n10. Update denormalized counts (e.g., `album.media_count`)\\n11. Return created link(s)\\n\\n**Response:**\\n```json\\n{\\n  \\\"id\\\": \\\"link-uuid\\\",\\n  \\\"from_object_id\\\": \\\"album-uuid\\\",\\n  \\\"to_object_id\\\": \\\"photo-uuid\\\",\\n  \\\"link_type\\\": \\\"contains\\\",\\n  \\\"created_at\\\": \\\"2026-02-03T12:00:00Z\\\",\\n  ...\\n}\\n```\\n\\n---\\n\\n### Reading Links\\n\\n**Get Links From Object:**\\n```http\\nGET /api/v1/objects/{object_id}/links/outgoing?type=contains\\n```\\n\\n**Get Links To Object:**\\n```http\\nGET /api/v1/objects/{object_id}/links/incoming?type=source\\n```\\n\\n**Get All Links for Object:**\\n```http\\nGET /api/v1/objects/{object_id}/links\\n```\\n\\n**Response:**\\n```json\\n{\\n  \\\"links\\\": [\\n    {\\n      \\\"id\\\": \\\"link-1-uuid\\\",\\n      \\\"link_type\\\": \\\"contains\\\",\\n      \\\"from_object_id\\\": \\\"album-uuid\\\",\\n      \\\"to_object_id\\\": \\\"photo-1-uuid\\\",\\n      \\\"to_object\\\": {\\n        \\\"id\\\": \\\"photo-1-uuid\\\",\\n        \\\"type\\\": \\\"media\\\",\\n        \\\"filename\\\": \\\"photo1.jpg\\\",\\n        ...\\n      }\\n    },\\n    {\\n      \\\"id\\\": \\\"link-2-uuid\\\",\\n      \\\"link_type\\\": \\\"contains\\\",\\n      \\\"from_object_id\\\": \\\"album-uuid\\\",\\n      \\\"to_object_id\\\": \\\"photo-2-uuid\\\",\\n      \\\"to_object\\\": {\\n        \\\"id\\\": \\\"photo-2-uuid\\\",\\n        \\\"type\\\": \\\"media\\\",\\n        \\\"filename\\\": \\\"photo2.jpg\\\",\\n        ...\\n      }\\n    }\\n  ],\\n  \\\"total\\\": 2\\n}\\n```\\n\\n**Common Queries:**\\n\\n1. **Get all photos in album (ordered):**\\n```http\\nGET /api/v1/albums/{album_id}/media\\n# \\u2192 Returns media objects linked via \\\"contains\\\", sorted by sort_order\\n```\\n\\n2. **Get source integration for photo:**\\n```http\\nGET /api/v1/media/{photo_id}/source\\n# \\u2192 Returns integration object linked via \\\"source\\\"\\n```\\n\\n3. **Get all duplicates of photo:**\\n```http\\nGET /api/v1/media/{photo_id}/duplicates\\n# \\u2192 Returns media objects linked via \\\"duplicate_of\\\"\\n```\\n\\n---\\n\\n### Updating Links\\n\\nLinks can be updated to change properties like `sort_order`, `strength`, or `metadata`.\\n\\n**API Endpoint:** `PATCH /api/v1/links/{link_id}`\\n\\n**Request:**\\n```json\\n{\\n  \\\"sort_order\\\": 10,\\n  \\\"strength\\\": 1.0,\\n  \\\"metadata\\\": {\\n    \\\"user_confirmed\\\": true\\n  }\\n}\\n```\\n\\n**Immutable Fields:**\\n- `from_object_id`, `to_object_id`, `link_type` cannot be changed\\n- To change endpoints or type, delete and recreate link\\n\\n---\\n\\n### Deleting Links\\n\\n**API Endpoint:** `DELETE /api/v1/links/{link_id}`\\n\\n**Behavior:**\\n- Soft delete by default (set `deleted_at`)\\n- If bidirectional, delete reverse link too\\n- Update denormalized counts\\n- Do NOT delete linked objects (only remove relationship)\\n\\n**Example: Remove photo from album**\\n```http\\nDELETE /api/v1/links/{link_id}\\n# \\u2192 Photo removed from album, but photo still exists\\n```\\n\\n**Cascade Deletes:**\\n\\nWhen an object is deleted, what happens to its links?\\n\\n| Scenario | Behavior |\\n|----------|----------|\\n| **User deleted** | All user's objects and links deleted (CASCADE) |\\n| **Album deleted** | Links where album is `from_object` deleted (contains links) |\\n| **Media deleted** | All links to/from media deleted |\\n| **Integration deleted** | Links where integration is `to_object` deleted (source links preserved but orphaned) |\\n\\n---\\n\\n## Querying Links\\n\\n### Graph Traversal\\n\\nLinks enable graph-like queries:\\n\\n**1. Get all media in album and sub-albums (recursive):**\\n```sql\\nWITH RECURSIVE album_tree AS (\\n  -- Start with root album\\n  SELECT id FROM albums WHERE id = '{album_id}'\\n\\n  UNION ALL\\n\\n  -- Recursively find sub-albums\\n  SELECT l.to_object_id\\n  FROM links l\\n  JOIN album_tree at ON l.from_object_id = at.id\\n  WHERE l.link_type = 'contains'\\n    AND l.from_object_type = 'album'\\n    AND l.to_object_type = 'album'\\n    AND l.deleted_at IS NULL\\n)\\n-- Get all media in any of these albums\\nSELECT DISTINCT m.*\\nFROM media m\\nJOIN links l ON l.to_object_id = m.id\\nJOIN album_tree at ON l.from_object_id = at.id\\nWHERE l.link_type = 'contains'\\n  AND l.from_object_type = 'album'\\n  AND l.to_object_type = 'media'\\n  AND l.deleted_at IS NULL\\nORDER BY l.sort_order;\\n```\\n\\n**2. Get all media from a specific integration:**\\n```sql\\nSELECT m.*\\nFROM media m\\nJOIN links l ON l.from_object_id = m.id\\nWHERE l.link_type = 'source'\\n  AND l.to_object_id = '{integration_id}'\\n  AND l.deleted_at IS NULL;\\n```\\n\\n**3. Find duplicate clusters (all duplicates of duplicates):**\\n```sql\\nWITH RECURSIVE duplicate_cluster AS (\\n  -- Start with specific photo\\n  SELECT to_object_id AS media_id\\n  FROM links\\n  WHERE from_object_id = '{photo_id}'\\n    AND link_type = 'duplicate_of'\\n    AND deleted_at IS NULL\\n\\n  UNION\\n\\n  -- Find duplicates of duplicates\\n  SELECT l.to_object_id\\n  FROM links l\\n  JOIN duplicate_cluster dc ON l.from_object_id = dc.media_id\\n  WHERE l.link_type = 'duplicate_of'\\n    AND l.deleted_at IS NULL\\n)\\nSELECT DISTINCT m.*\\nFROM media m\\nJOIN duplicate_cluster dc ON m.id = dc.media_id;\\n```\\n\\n### Performance Considerations\\n\\n**Indexes for Link Queries:**\\n```sql\\n-- Fast lookup: \\\"Get all links from object X\\\"\\nCREATE INDEX idx_links_from ON links(from_object_id, link_type)\\n  WHERE deleted_at IS NULL;\\n\\n-- Fast lookup: \\\"Get all links to object X\\\"\\nCREATE INDEX idx_links_to ON links(to_object_id, link_type)\\n  WHERE deleted_at IS NULL;\\n\\n-- Prevent duplicate links\\nCREATE UNIQUE INDEX idx_links_unique ON links(from_object_id, to_object_id, link_type)\\n  WHERE deleted_at IS NULL;\\n\\n-- Ordered links (albums)\\nCREATE INDEX idx_links_ordered ON links(from_object_id, sort_order)\\n  WHERE deleted_at IS NULL AND sort_order IS NOT NULL;\\n```\\n\\n**Query Optimization:**\\n- Use indexes on `from_object_id`, `to_object_id`, `link_type`\\n- Filter by `deleted_at IS NULL` in all queries\\n- Consider materializing common queries (e.g., album media counts)\\n- Limit recursive queries with depth limits\\n\\n---\\n\\n## Link Constraints\\n\\n### Validation Rules\\n\\n```python\\nLINK_TYPE_RULES = {\\n    \\\"contains\\\": {\\n        \\\"allowed_combinations\\\": [\\n            (\\\"album\\\", \\\"media\\\"),\\n            (\\\"album\\\", \\\"album\\\"),\\n        ],\\n        \\\"bidirectional\\\": False,\\n        \\\"ordered\\\": True,\\n        \\\"unique_from\\\": False,  # Album can contain many items\\n        \\\"unique_to\\\": False,    # Media can be in many albums\\n    },\\n    \\\"source\\\": {\\n        \\\"allowed_combinations\\\": [\\n            (\\\"media\\\", \\\"integration\\\"),\\n        ],\\n        \\\"bidirectional\\\": False,\\n        \\\"ordered\\\": False,\\n        \\\"unique_from\\\": True,   # Media can only have one source\\n        \\\"unique_to\\\": False,    # Integration can source many media\\n    },\\n    \\\"duplicate_of\\\": {\\n        \\\"allowed_combinations\\\": [\\n            (\\\"media\\\", \\\"media\\\"),\\n        ],\\n        \\\"bidirectional\\\": True,  # Auto-create reverse link\\n        \\\"ordered\\\": False,\\n        \\\"unique_from\\\": False,   # Media can have many duplicates\\n        \\\"unique_to\\\": False,     # Media can be duplicate of many\\n        \\\"prevent_self_loop\\\": True,  # Can't be duplicate of itself\\n    },\\n    \\\"variant_of\\\": {\\n        \\\"allowed_combinations\\\": [\\n            (\\\"media\\\", \\\"media\\\"),\\n        ],\\n        \\\"bidirectional\\\": False,\\n        \\\"ordered\\\": False,\\n        \\\"unique_from\\\": True,   # Variant can only have one original\\n        \\\"unique_to\\\": False,    # Original can have many variants\\n        \\\"prevent_self_loop\\\": True,\\n        \\\"prevent_cycles\\\": True,  # No circular variants\\n    },\\n}\\n```\\n\\n### Cardinality Enforcement\\n\\n**One-to-One:**\\n- `unique_from: True` and `unique_to: True`\\n- Example: (none in Phase 1)\\n\\n**One-to-Many:**\\n- `unique_from: True` and `unique_to: False`\\n- Example: `variant_of` (variant has one original, original has many variants)\\n\\n**Many-to-One:**\\n- `unique_from: False` and `unique_to: True`\\n- Example: (conceptually reverse of one-to-many)\\n\\n**Many-to-Many:**\\n- `unique_from: False` and `unique_to: False`\\n- Example: `contains` (album \\u2192 media), `duplicate_of`\\n\\n### Circular Reference Prevention\\n\\nFor link types with `prevent_cycles: True`, check before creating:\\n\\n```python\\ndef would_create_cycle(from_id, to_id, link_type):\\n    \\\"\\\"\\\"Check if creating link would create a cycle\\\"\\\"\\\"\\n    if from_id == to_id:\\n        return True  # Self-loop\\n\\n    # Check if to_id is ancestor of from_id\\n    # (BFS or DFS traversal)\\n    visited = set()\\n    queue = [from_id]\\n\\n    while queue:\\n        current = queue.pop(0)\\n        if current in visited:\\n            continue\\n        visited.add(current)\\n\\n        if current == to_id:\\n            return True  # Cycle detected\\n\\n        # Get all objects that current points to via same link type\\n        parents = get_linked_objects(current, link_type, direction=\\\"outgoing\\\")\\n        queue.extend(parents)\\n\\n    return False\\n```\\n\\n---\\n\\n## Examples\\n\\n### Example 1: Album with Photos\\n\\n**Setup:**\\n```\\nUser creates album \\\"Vacation 2026\\\"\\nUser uploads 3 photos\\nUser adds photos to album\\n```\\n\\n**Objects:**\\n```json\\n// Album\\n{\\n  \\\"id\\\": \\\"album-1\\\",\\n  \\\"type\\\": \\\"album\\\",\\n  \\\"name\\\": \\\"Vacation 2026\\\",\\n  \\\"media_count\\\": 3\\n}\\n\\n// Photos\\n{\\n  \\\"id\\\": \\\"photo-1\\\",\\n  \\\"type\\\": \\\"media\\\",\\n  \\\"filename\\\": \\\"beach.jpg\\\"\\n}\\n{\\n  \\\"id\\\": \\\"photo-2\\\",\\n  \\\"type\\\": \\\"media\\\",\\n  \\\"filename\\\": \\\"sunset.jpg\\\"\\n}\\n{\\n  \\\"id\\\": \\\"photo-3\\\",\\n  \\\"type\\\": \\\"media\\\",\\n  \\\"filename\\\": \\\"dinner.jpg\\\"\\n}\\n```\\n\\n**Links:**\\n```json\\n// Link 1: Album contains photo-1\\n{\\n  \\\"from_object_id\\\": \\\"album-1\\\",\\n  \\\"to_object_id\\\": \\\"photo-1\\\",\\n  \\\"link_type\\\": \\\"contains\\\",\\n  \\\"sort_order\\\": 0\\n}\\n\\n// Link 2: Album contains photo-2\\n{\\n  \\\"from_object_id\\\": \\\"album-1\\\",\\n  \\\"to_object_id\\\": \\\"photo-2\\\",\\n  \\\"link_type\\\": \\\"contains\\\",\\n  \\\"sort_order\\\": 1\\n}\\n\\n// Link 3: Album contains photo-3\\n{\\n  \\\"from_object_id\\\": \\\"album-1\\\",\\n  \\\"to_object_id\\\": \\\"photo-3\\\",\\n  \\\"link_type\\\": \\\"contains\\\",\\n  \\\"sort_order\\\": 2\\n}\\n```\\n\\n**Query: Get photos in album**\\n```http\\nGET /api/v1/albums/album-1/media\\n\\nResponse:\\n{\\n  \\\"items\\\": [\\n    {\\\"id\\\": \\\"photo-1\\\", \\\"filename\\\": \\\"beach.jpg\\\"},\\n    {\\\"id\\\": \\\"photo-2\\\", \\\"filename\\\": \\\"sunset.jpg\\\"},\\n    {\\\"id\\\": \\\"photo-3\\\", \\\"filename\\\": \\\"dinner.jpg\\\"}\\n  ],\\n  \\\"total\\\": 3\\n}\\n```\\n\\n---\\n\\n### Example 2: Instagram Sync\\n\\n**Setup:**\\n```\\nUser connects Instagram integration\\nSystem syncs 100 photos from Instagram\\nEach photo linked to integration via \\\"source\\\"\\n```\\n\\n**Objects:**\\n```json\\n// Integration\\n{\\n  \\\"id\\\": \\\"instagram-1\\\",\\n  \\\"type\\\": \\\"integration\\\",\\n  \\\"integration_type\\\": \\\"instagram\\\",\\n  \\\"integration_name\\\": \\\"@johnsmith\\\",\\n  \\\"items_synced\\\": 100\\n}\\n\\n// Media (one of 100)\\n{\\n  \\\"id\\\": \\\"photo-ig-1\\\",\\n  \\\"type\\\": \\\"media\\\",\\n  \\\"filename\\\": \\\"instagram_post_2026_01_15.jpg\\\",\\n  \\\"source_type\\\": \\\"integration\\\",\\n  \\\"source_id\\\": \\\"instagram_media_abc123\\\"\\n}\\n```\\n\\n**Link:**\\n```json\\n{\\n  \\\"from_object_id\\\": \\\"photo-ig-1\\\",\\n  \\\"to_object_id\\\": \\\"instagram-1\\\",\\n  \\\"link_type\\\": \\\"source\\\",\\n  \\\"metadata\\\": {\\n    \\\"external_id\\\": \\\"instagram_media_abc123\\\",\\n    \\\"sync_timestamp\\\": \\\"2026-02-03T10:00:00Z\\\"\\n  }\\n}\\n```\\n\\n**Query: Get all Instagram photos**\\n```http\\nGET /api/v1/integrations/instagram-1/media\\n\\nResponse:\\n{\\n  \\\"items\\\": [\\n    {\\\"id\\\": \\\"photo-ig-1\\\", ...},\\n    {\\\"id\\\": \\\"photo-ig-2\\\", ...},\\n    ...\\n  ],\\n  \\\"total\\\": 100\\n}\\n```\\n\\n**Deduplication on Re-Sync:**\\n```python\\n# Before importing from Instagram\\nexisting_link = find_link(\\n    from_object_type=\\\"media\\\",\\n    to_object_id=integration_id,\\n    metadata__external_id=instagram_media_id\\n)\\n\\nif existing_link:\\n    # Already imported, skip or update\\n    pass\\nelse:\\n    # New photo, import and create link\\n    create_media_and_link(instagram_data, integration_id)\\n```\\n\\n---\\n\\n### Example 3: Duplicate Detection\\n\\n**Setup:**\\n```\\nUser uploads same photo twice (different filenames)\\nSystem detects duplicates via hash match\\nSystem creates bidirectional \\\"duplicate_of\\\" links\\n```\\n\\n**Objects:**\\n```json\\n{\\n  \\\"id\\\": \\\"photo-original\\\",\\n  \\\"filename\\\": \\\"IMG_1234.jpg\\\",\\n  \\\"hash\\\": \\\"abc123...\\\"\\n}\\n{\\n  \\\"id\\\": \\\"photo-duplicate\\\",\\n  \\\"filename\\\": \\\"IMG_1234_copy.jpg\\\",\\n  \\\"hash\\\": \\\"abc123...\\\"  // Same hash!\\n}\\n```\\n\\n**Links (bidirectional):**\\n```json\\n// Link 1: photo-original \\u2192 photo-duplicate\\n{\\n  \\\"id\\\": \\\"link-1\\\",\\n  \\\"from_object_id\\\": \\\"photo-original\\\",\\n  \\\"to_object_id\\\": \\\"photo-duplicate\\\",\\n  \\\"link_type\\\": \\\"duplicate_of\\\",\\n  \\\"strength\\\": 1.0,\\n  \\\"is_bidirectional\\\": true,\\n  \\\"metadata\\\": {\\n    \\\"detection_method\\\": \\\"hash_match\\\",\\n    \\\"hash_match\\\": true\\n  }\\n}\\n\\n// Link 2: photo-duplicate \\u2192 photo-original (auto-created)\\n{\\n  \\\"id\\\": \\\"link-2\\\",\\n  \\\"from_object_id\\\": \\\"photo-duplicate\\\",\\n  \\\"to_object_id\\\": \\\"photo-original\\\",\\n  \\\"link_type\\\": \\\"duplicate_of\\\",\\n  \\\"strength\\\": 1.0,\\n  \\\"is_bidirectional\\\": true,\\n  \\\"metadata\\\": {\\n    \\\"detection_method\\\": \\\"hash_match\\\",\\n    \\\"hash_match\\\": true,\\n    \\\"reverse_of\\\": \\\"link-1\\\"\\n  }\\n}\\n```\\n\\n**Query: Get duplicates**\\n```http\\nGET /api/v1/media/photo-original/duplicates\\n\\nResponse:\\n{\\n  \\\"items\\\": [\\n    {\\\"id\\\": \\\"photo-duplicate\\\", \\\"filename\\\": \\\"IMG_1234_copy.jpg\\\"}\\n  ],\\n  \\\"total\\\": 1\\n}\\n```\\n\\n**User Action: Confirm or Reject**\\n```http\\nPATCH /api/v1/links/link-1\\n{\\n  \\\"strength\\\": 1.0,  // User confirmed\\n  \\\"metadata\\\": {\\n    \\\"user_confirmed\\\": true,\\n    \\\"confirmed_at\\\": \\\"2026-02-03T14:00:00Z\\\"\\n  }\\n}\\n```\\n\\n---\\n\\n## Open Questions\\n\\n1. **Link Versioning?**\\n   - Track history of link changes?\\n   - Useful for undo/redo?\\n\\n2. **Link Properties vs. Metadata?**\\n   - Should some common metadata be promoted to core fields?\\n   - E.g., `confidence` instead of `strength`?\\n\\n3. **Performance at Scale?**\\n   - How well do link queries perform with millions of links?\\n   - Need caching or materialized views?\\n\\n4. **Graph Database?**\\n   - Would a dedicated graph DB (Neo4j, ArangoDB) be better?\\n   - Or is PostgreSQL + indexes sufficient?\\n\\n---\\n\\n## Next Steps\\n\\n- [ ] Review link model design\\n- [ ] Implement link validation logic\\n- [ ] Create database schema for links\\n- [ ] Write API endpoints for link CRUD\\n- [ ] Implement graph traversal queries\\n- [ ] Add link-based features (album media listing, duplicate detection)\\n\\n---\\n\\n**Status:** Draft - Ready for review\\n**Next Document:** `03-API-Endpoints.md` (RESTful API specification)\\n\"\n  },\n  \"created_at\": \"2026-02-15T11:53:48.183555+00:00\",\n  \"updated_at\": \"2026-02-15T11:53:48.183555+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"file:02-Link-Model-Specification.md\"\n}"
  },
  "created_at": "2026-02-17T01:23:12.286725+00:00",
  "updated_at": "2026-02-17T01:23:12.286725+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}