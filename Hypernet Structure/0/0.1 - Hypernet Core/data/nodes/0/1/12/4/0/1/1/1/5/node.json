{
  "address": "0.1.12.4.0.1.1.1.5",
  "type_address": null,
  "data": {
    "name": "5",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\1\\1\\5",
    "content_preview": "{\n  \"address\": \"0.1.1.1.5\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"locations.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\app\\\\routes\\\\locations.py\",\n    \"size\": 11249,\n    \"content\": \"\\\"\\\"\\\"\\nLocations API Routes\\n\\nProvides CRUD operations for location history and place management\\nincluding GPS coordinates, addresses, and location tracking.\\n\\\"\\\"\\\"\\n\\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\\nfrom sqlalchemy.orm import Session\\nfrom sqlalchemy import and_, or_, func\\nfrom typing import Optional, List\\nfrom datetime import datetime, date\\nfrom uuid import UUID\\nfrom decimal import Decimal\\nfrom pydantic import BaseModel, Field\\n\\nfrom app.core.database import get_db\\nfrom app.core.dependencies import get_current_user\\nfrom app.models.user import User\\nfrom app.models.location import Location\\n\\n\\nrouter = APIRouter()\\n\\n\\n# Pydantic Models for Request/Response\\nclass LocationCreate(BaseModel):\\n    location_type: str = Field(..., description=\\\"gps_point, address, place, checkin, route\\\")\\n    latitude: Optional[Decimal] = Field(None, ge=-90, le=90, description=\\\"GPS latitude\\\")\\n    longitude: Optional[Decimal] = Field(None, ge=-180, le=180, description=\\\"GPS longitude\\\")\\n    altitude: Optional[Decimal] = Field(None, description=\\\"Altitude in meters\\\")\\n    accuracy: Optional[Decimal] = Field(None, ge=0, description=\\\"Accuracy in meters\\\")\\n    address: Optional[str] = Field(None, max_length=500)\\n    city: Optional[str] = Field(None, max_length=200)\\n    state: Optional[str] = Field(None, max_length=200)\\n    country: Optional[str] = Field(None, max_length=200)\\n    postal_code: Optional[str] = Field(None, max_length=20)\\n    place_name: Optional[str] = Field(None, max_length=300)\\n    place_category: Optional[str] = Field(None, max_length=100)\\n    timestamp: datetime\\n    source_app: Optional[str] = Field(None, max_length=100)\\n    activity_type: Optional[str] = Field(None, max_length=100)\\n    notes: Optional[str] = None\\n\\n\\nclass LocationUpdate(BaseModel):\\n    place_name: Optional[str] = Field(None, max_length=300)\\n    place_category: Optional[str] = Field(None, max_length=100)\\n    notes: Optional[str] = None\\n\\n\\nclass LocationResponse(BaseModel):\\n    id: UUID\\n    user_id: UUID\\n    location_type: str\\n    latitude: Optional[Decimal]\\n    longitude: Optional[Decimal]\\n    altitude: Optional[Decimal]\\n    accuracy: Optional[Decimal]\\n    address: Optional[str]\\n    city: Optional[str]\\n    state: Optional[str]\\n    country: Optional[str]\\n    postal_code: Optional[str]\\n    place_name: Optional[str]\\n    place_category: Optional[str]\\n    timestamp: datetime\\n    source_app: Optional[str]\\n    activity_type: Optional[str]\\n    notes: Optional[str]\\n    created_at: datetime\\n    updated_at: datetime\\n\\n    class Config:\\n        from_attributes = True\\n\\n\\nclass LocationListResponse(BaseModel):\\n    items: List[LocationResponse]\\n    total: int\\n    page: int\\n    page_size: int\\n    pages: int\\n\\n\\nclass NearbyLocation(BaseModel):\\n    \\\"\\\"\\\"Location with distance from query point.\\\"\\\"\\\"\\n    location: LocationResponse\\n    distance_km: float\\n\\n\\n# Endpoints\\n@router.post(\\\"\\\", response_model=LocationResponse, status_code=status.HTTP_201_CREATED)\\nasync def create_location(\\n    location_data: LocationCreate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Create a new location record.\\\"\\\"\\\"\\n    location = Location(\\n        user_id=current_user.id,\\n        **location_data.dict()\\n    )\\n    db.add(location)\\n    db.commit()\\n    db.refresh(location)\\n    return location\\n\\n\\n@router.get(\\\"\\\", response_model=LocationListResponse)\\nasync def list_locations(\\n    location_type: Optional[str] = Query(None, description=\\\"Filter by location type\\\"),\\n    city: Optional[str] = Query(None, description=\\\"Filter by city\\\"),\\n    state: Optional[str] = Query(None, description=\\\"Filter by state\\\"),\\n    country: Optional[str] = Query(None, description=\\\"Filter by country\\\"),\\n    place_category: Optional[str] = Query(None, description=\\\"Filter by place category\\\"),\\n    start_date: Optional[date] = Query(None, description=\\\"Start date (YYYY-MM-DD)\\\"),\\n    end_date: Optional[date] = Query(None, description=\\\"End date (YYYY-MM-DD)\\\"),\\n    search: Optional[str] = Query(None, description=\\\"Search in address, place_name, notes\\\"),\\n    page: int = Query(1, ge=1, description=\\\"Page number\\\"),\\n    page_size: int = Query(50, ge=1, le=100, description=\\\"Items per page\\\"),\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"List locations with optional filtering.\\\"\\\"\\\"\\n    query = db.query(Location).filter(\\n        and_(\\n            Location.user_id == current_user.id,\\n            Location.deleted_at.is_(None)\\n        )\\n    )\\n\\n    if location_type:\\n        query = query.filter(Location.location_type == location_type)\\n\\n    if city:\\n        query = query.filter(Location.city.ilike(f\\\"%{city}%\\\"))\\n\\n    if state:\\n        query = query.filter(Location.state.ilike(f\\\"%{state}%\\\"))\\n\\n    if country:\\n        query = query.filter(Location.country.ilike(f\\\"%{country}%\\\"))\\n\\n    if place_category:\\n        query = query.filter(Location.place_category == place_category)\\n\\n    if start_date:\\n        query = query.filter(Location.timestamp >= datetime.combine(start_date, datetime.min.time()))\\n\\n    if end_date:\\n        query = query.filter(Location.timestamp <= datetime.combine(end_date, datetime.max.time()))\\n\\n    if search:\\n        search_pattern = f\\\"%{search}%\\\"\\n        query = query.filter(\\n            or_(\\n                Location.address.ilike(search_pattern),\\n                Location.place_name.ilike(search_pattern),\\n                Location.notes.ilike(search_pattern)\\n            )\\n        )\\n\\n    total = query.count()\\n\\n    # Order by timestamp descending (most recent first)\\n    query = query.order_by(Location.timestamp.desc())\\n\\n    offset = (page - 1) * page_size\\n    items = query.offset(offset).limit(page_size).all()\\n\\n    pages = (total + page_size - 1) // page_size\\n\\n    return LocationListResponse(\\n        items=items,\\n        total=total,\\n        page=page,\\n        page_size=page_size,\\n        pages=pages\\n    )\\n\\n\\n@router.get(\\\"/nearby\\\", response_model=List[NearbyLocation])\\nasync def find_nearby_locations(\\n    latitude: Decimal = Query(..., ge=-90, le=90, description=\\\"Center latitude\\\"),\\n    longitude: Decimal = Query(..., ge=-180, le=180, description=\\\"Center longitude\\\"),\\n    radius_km: float = Query(5.0, gt=0, le=100, description=\\\"Search radius in kilometers\\\"),\\n    limit: int = Query(20, ge=1, le=100, description=\\\"Maximum results\\\"),\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"\\n    Find locations near a given point using Haversine formula.\\n    Returns locations sorted by distance.\\n    \\\"\\\"\\\"\\n    # Haversine formula for distance calculation\\n    # This is a simplified version - for production, use PostGIS\\n    lat1 = func.radians(latitude)\\n    lon1 = func.radians(longitude)\\n    lat2 = func.radians(Location.latitude)\\n    lon2 = func.radians(Location.longitude)\\n\\n    dlat = lat2 - lat1\\n    dlon = lon2 - lon1\\n\\n    a = func.sin(dlat / 2) ** 2 + func.cos(lat1) * func.cos(lat2) * func.sin(dlon / 2) ** 2\\n    c = 2 * func.asin(func.sqrt(a))\\n    distance_km = 6371 * c  # Earth's radius in km\\n\\n    query = db.query(\\n        Location,\\n        distance_km.label('distance')\\n    ).filter(\\n        and_(\\n            Location.user_id == current_user.id,\\n            Location.deleted_at.is_(None),\\n            Location.latitude.isnot(None),\\n            Location.longitude.isnot(None)\\n        )\\n    ).having(\\n        distance_km <= radius_km\\n    ).order_by(\\n        distance_km\\n    ).limit(limit)\\n\\n    results = query.all()\\n\\n    return [\\n        NearbyLocation(\\n            location=LocationResponse.from_orm(row.Location),\\n            distance_km=float(row.distance)\\n        )\\n        for row in results\\n    ]\\n\\n\\n@router.get(\\\"/cities\\\", response_model=List[str])\\nasync def list_cities(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get all unique cities from user's locations.\\\"\\\"\\\"\\n    cities = db.query(Location.city).filter(\\n        and_(\\n            Location.user_id == current_user.id,\\n            Location.deleted_at.is_(None),\\n            Location.city.isnot(None)\\n        )\\n    ).distinct().order_by(Location.city).all()\\n\\n    return [city[0] for city in cities if city[0]]\\n\\n\\n@router.get(\\\"/countries\\\", response_model=List[str])\\nasync def list_countries(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get all unique countries from user's locations.\\\"\\\"\\\"\\n    countries = db.query(Location.country).filter(\\n        and_(\\n            Location.user_id == current_user.id,\\n            Location.deleted_at.is_(None),\\n            Location.country.isnot(None)\\n        )\\n    ).distinct().order_by(Location.country).all()\\n\\n    return [country[0] for country in countries if country[0]]\\n\\n\\n@router.get(\\\"/{location_id}\\\", response_model=LocationResponse)\\nasync def get_location(\\n    location_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get a specific location by ID.\\\"\\\"\\\"\\n    location = db.query(Location).filter(\\n        and_(\\n            Location.id == location_id,\\n            Location.user_id == current_user.id,\\n            Location.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not location:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Location not found\\\"\\n        )\\n\\n    return location\\n\\n\\n@router.patc\n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-17T01:23:12.520320+00:00",
  "updated_at": "2026-02-17T01:23:12.520320+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:5"
}