{
  "address": "0.1.12.4.0.1.6",
  "type_address": null,
  "data": {
    "name": "6",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\6",
    "content_preview": "{\n  \"address\": \"0.1.6\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"test_hypernet.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\test_hypernet.py\",\n    \"size\": 10304,\n    \"content\": \"\\\"\\\"\\\"\\nHypernet Core Tests\\n\\nRun with: python test_hypernet.py\\nNo external dependencies needed \\u2014 uses only the standard library.\\n\\\"\\\"\\\"\\n\\nimport sys\\nimport tempfile\\nimport shutil\\nfrom pathlib import Path\\n\\n# Add the parent directory to the path so we can import hypernet\\nsys.path.insert(0, str(Path(__file__).parent))\\n\\nfrom hypernet.address import HypernetAddress\\nfrom hypernet.node import Node\\nfrom hypernet.link import Link\\nfrom hypernet.store import Store\\nfrom hypernet.graph import Graph\\n\\n\\ndef test_address_parsing():\\n    \\\"\\\"\\\"Test HypernetAddress parsing and properties.\\\"\\\"\\\"\\n    print(\\\"  Testing address parsing...\\\")\\n\\n    # Basic parsing\\n    addr = HypernetAddress.parse(\\\"1.1.1.1.00001\\\")\\n    assert str(addr) == \\\"1.1.1.1.00001\\\"\\n    assert addr.category == \\\"1\\\"\\n    assert addr.depth == 5\\n    assert addr.is_instance is True\\n    assert addr.is_definition is False\\n\\n    # Owner extraction\\n    assert str(addr.owner) == \\\"1.1\\\"\\n\\n    # Parent navigation\\n    assert str(addr.parent) == \\\"1.1.1.1\\\"\\n    assert str(addr.parent.parent) == \\\"1.1.1\\\"\\n\\n    # Root\\n    assert str(addr.root) == \\\"1\\\"\\n\\n    # System definition\\n    sys_addr = HypernetAddress.parse(\\\"0.5.1\\\")\\n    assert sys_addr.is_definition is True\\n    assert sys_addr.owner is None\\n\\n    # Hierarchy\\n    parent = HypernetAddress.parse(\\\"1.1\\\")\\n    child = HypernetAddress.parse(\\\"1.1.1.1.00001\\\")\\n    assert parent.is_ancestor_of(child) is True\\n    assert child.is_descendant_of(parent) is True\\n    assert child.is_ancestor_of(parent) is False\\n\\n    # Child creation\\n    base = HypernetAddress.parse(\\\"1.1.1.1\\\")\\n    next_addr = base.next_instance(0)\\n    assert str(next_addr) == \\\"1.1.1.1.00001\\\"\\n    next_addr = base.next_instance(42)\\n    assert str(next_addr) == \\\"1.1.1.1.00043\\\"\\n\\n    # Path conversion\\n    assert addr.to_path() == \\\"1/1/1/1/00001\\\"\\n\\n    print(\\\"    PASS\\\")\\n\\n\\ndef test_node_creation():\\n    \\\"\\\"\\\"Test Node creation and serialization.\\\"\\\"\\\"\\n    print(\\\"  Testing node creation...\\\")\\n\\n    node = Node(\\n        address=HypernetAddress.parse(\\\"1.1\\\"),\\n        type_address=HypernetAddress.parse(\\\"0.5.1\\\"),\\n        data={\\\"name\\\": \\\"Matt Schaeffer\\\", \\\"role\\\": \\\"Founder\\\"},\\n        source_type=\\\"api\\\",\\n    )\\n\\n    assert str(node.address) == \\\"1.1\\\"\\n    assert node.data[\\\"name\\\"] == \\\"Matt Schaeffer\\\"\\n    assert node.is_deleted is False\\n    assert str(node.owner) == \\\"1.1\\\"\\n\\n    # Serialization round-trip\\n    d = node.to_dict()\\n    restored = Node.from_dict(d)\\n    assert str(restored.address) == \\\"1.1\\\"\\n    assert restored.data[\\\"name\\\"] == \\\"Matt Schaeffer\\\"\\n\\n    # Soft delete\\n    node.soft_delete()\\n    assert node.is_deleted is True\\n    node.restore()\\n    assert node.is_deleted is False\\n\\n    print(\\\"    PASS\\\")\\n\\n\\ndef test_link_creation():\\n    \\\"\\\"\\\"Test Link creation and properties.\\\"\\\"\\\"\\n    print(\\\"  Testing link creation...\\\")\\n\\n    link = Link(\\n        from_address=HypernetAddress.parse(\\\"1.1\\\"),\\n        to_address=HypernetAddress.parse(\\\"1.2\\\"),\\n        link_type=\\\"0.6.1\\\",\\n        relationship=\\\"spouse\\\",\\n        bidirectional=True,\\n        data={\\\"since\\\": \\\"2015-06-20\\\"},\\n    )\\n\\n    assert link.connects(HypernetAddress.parse(\\\"1.1\\\")) is True\\n    assert link.connects(HypernetAddress.parse(\\\"1.2\\\")) is True  # bidirectional\\n    assert link.connects(HypernetAddress.parse(\\\"1.3\\\")) is False\\n\\n    other = link.other_end(HypernetAddress.parse(\\\"1.1\\\"))\\n    assert str(other) == \\\"1.2\\\"\\n\\n    other = link.other_end(HypernetAddress.parse(\\\"1.2\\\"))\\n    assert str(other) == \\\"1.1\\\"  # bidirectional\\n\\n    # Serialization round-trip\\n    d = link.to_dict()\\n    restored = Link.from_dict(d)\\n    assert str(restored.from_address) == \\\"1.1\\\"\\n    assert restored.relationship == \\\"spouse\\\"\\n    assert restored.bidirectional is True\\n\\n    print(\\\"    PASS\\\")\\n\\n\\ndef test_store():\\n    \\\"\\\"\\\"Test file-backed storage operations.\\\"\\\"\\\"\\n    print(\\\"  Testing store...\\\")\\n\\n    # Use a temp directory for test storage\\n    tmpdir = tempfile.mkdtemp(prefix=\\\"hypernet_test_\\\")\\n\\n    try:\\n        store = Store(tmpdir)\\n\\n        # Create nodes\\n        matt = Node(\\n            address=HypernetAddress.parse(\\\"1.1\\\"),\\n            data={\\\"name\\\": \\\"Matt Schaeffer\\\", \\\"type\\\": \\\"person\\\"},\\n        )\\n        store.put_node(matt)\\n\\n        claude = Node(\\n            address=HypernetAddress.parse(\\\"2.1\\\"),\\n            data={\\\"name\\\": \\\"Claude Opus\\\", \\\"type\\\": \\\"ai\\\"},\\n        )\\n        store.put_node(claude)\\n\\n        photo = Node(\\n            address=HypernetAddress.parse(\\\"1.1.1.1.00001\\\"),\\n            type_address=HypernetAddress.parse(\\\"0.5.1\\\"),\\n            data={\\\"filename\\\": \\\"sunset.jpg\\\", \\\"size\\\": 2048000},\\n        )\\n        store.put_node(photo)\\n\\n        # Retrieve\\n        retrieved = store.get_node(HypernetAddress.parse(\\\"1.1\\\"))\\n        assert retrieved is not None\\n        assert retrieved.data[\\\"name\\\"] == \\\"Matt Schaeffer\\\"\\n\\n        retrieved = store.get_node(HypernetAddress.parse(\\\"1.1.1.1.00001\\\"))\\n        assert retrieved is not None\\n        assert retrieved.data[\\\"filename\\\"] == \\\"sunset.jpg\\\"\\n\\n        # Missing node\\n        missing = store.get_node(HypernetAddress.parse(\\\"9.9.9\\\"))\\n        assert missing is None\\n\\n        # Create and retrieve links\\n        link = Link(\\n            from_address=HypernetAddress.parse(\\\"1.1\\\"),\\n            to_address=HypernetAddress.parse(\\\"2.1\\\"),\\n            link_type=\\\"0.6.2\\\",\\n            relationship=\\\"collaborates_with\\\",\\n            bidirectional=True,\\n        )\\n        store.put_link(link)\\n\\n        ownership = Link(\\n            from_address=HypernetAddress.parse(\\\"1.1\\\"),\\n            to_address=HypernetAddress.parse(\\\"1.1.1.1.00001\\\"),\\n            link_type=\\\"0.6.2\\\",\\n            relationship=\\\"owns\\\",\\n        )\\n        store.put_link(ownership)\\n\\n        # Query links\\n        from_matt = store.get_links_from(HypernetAddress.parse(\\\"1.1\\\"))\\n        assert len(from_matt) == 2\\n\\n        collab_links = store.get_links_from(\\n            HypernetAddress.parse(\\\"1.1\\\"), relationship=\\\"collaborates_with\\\"\\n        )\\n        assert len(collab_links) == 1\\n\\n        # Neighbors\\n        neighbors = store.get_neighbors(HypernetAddress.parse(\\\"1.1\\\"))\\n        assert len(neighbors) == 2  # 2.1 and 1.1.1.1.00001\\n\\n        # Stats\\n        stats = store.stats()\\n        assert stats[\\\"total_nodes\\\"] == 3\\n        assert stats[\\\"total_links\\\"] == 2\\n\\n        # Next address generation\\n        next_photo = store.next_address(HypernetAddress.parse(\\\"1.1.1.1\\\"))\\n        assert str(next_photo) == \\\"1.1.1.1.00002\\\"\\n\\n        # Persistence: create a new store pointing to same directory\\n        store2 = Store(tmpdir)\\n        retrieved2 = store2.get_node(HypernetAddress.parse(\\\"1.1\\\"))\\n        assert retrieved2 is not None\\n        assert retrieved2.data[\\\"name\\\"] == \\\"Matt Schaeffer\\\"\\n\\n        print(\\\"    PASS\\\")\\n\\n    finally:\\n        shutil.rmtree(tmpdir)\\n\\n\\ndef test_graph():\\n    \\\"\\\"\\\"Test graph traversal operations.\\\"\\\"\\\"\\n    print(\\\"  Testing graph traversal...\\\")\\n\\n    tmpdir = tempfile.mkdtemp(prefix=\\\"hypernet_test_\\\")\\n\\n    try:\\n        store = Store(tmpdir)\\n        graph = Graph(store)\\n\\n        # Build a small graph:\\n        # Matt (1.1) --collaborates_with--> Claude (2.1)\\n        # Matt (1.1) --owns--> Photo1 (1.1.1.1.00001)\\n        # Matt (1.1) --owns--> Photo2 (1.1.1.1.00002)\\n        # Photo1 --related_to--> Photo2 (bidirectional)\\n        # Matt (1.1) --spouse--> Sarah (1.2) (bidirectional)\\n\\n        for addr, data in [\\n            (\\\"1.1\\\", {\\\"name\\\": \\\"Matt\\\"}),\\n            (\\\"1.2\\\", {\\\"name\\\": \\\"Sarah\\\"}),\\n            (\\\"2.1\\\", {\\\"name\\\": \\\"Claude\\\"}),\\n            (\\\"1.1.1.1.00001\\\", {\\\"filename\\\": \\\"sunset.jpg\\\"}),\\n            (\\\"1.1.1.1.00002\\\", {\\\"filename\\\": \\\"beach.jpg\\\"}),\\n        ]:\\n            store.put_node(Node(\\n                address=HypernetAddress.parse(addr),\\n                data=data,\\n            ))\\n\\n        for from_a, to_a, lt, rel, bidir in [\\n            (\\\"1.1\\\", \\\"2.1\\\", \\\"0.6.2\\\", \\\"collaborates_with\\\", True),\\n            (\\\"1.1\\\", \\\"1.1.1.1.00001\\\", \\\"0.6.2\\\", \\\"owns\\\", False),\\n            (\\\"1.1\\\", \\\"1.1.1.1.00002\\\", \\\"0.6.2\\\", \\\"owns\\\", False),\\n            (\\\"1.1.1.1.00001\\\", \\\"1.1.1.1.00002\\\", \\\"0.6.3\\\", \\\"related_to\\\", True),\\n            (\\\"1.1\\\", \\\"1.2\\\", \\\"0.6.1\\\", \\\"spouse\\\", True),\\n        ]:\\n            store.put_link(Link(\\n                from_address=HypernetAddress.parse(from_a),\\n                to_address=HypernetAddress.parse(to_a),\\n                link_type=lt,\\n                relationship=rel,\\n                bidirectional=bidir,\\n            ))\\n\\n        # Traverse from Matt, depth 1\\n        one_hop = graph.traverse(HypernetAddress.parse(\\\"1.1\\\"), max_depth=1)\\n        one_hop_names = {n.data.get(\\\"name\\\", n.data.get(\\\"filename\\\")) for n in one_hop}\\n        assert \\\"Claude\\\" in one_hop_names\\n        assert \\\"Sarah\\\" in one_hop_names\\n        assert \\\"sunset.jpg\\\" in one_hop_names\\n\\n        # Traverse with relationship filter\\n        photos = graph.linked_to(HypernetAddress.parse(\\\"1.1\\\"), \\\"owns\\\")\\n        assert len(photos) == 2\\n\\n        # Find path: Sarah -> Photo1 (through Matt)\\n        path = graph.find_path(\\n            HypernetAddress.parse(\\\"1.2\\\"),\\n            HypernetAddress.parse(\\\"1.1.1.1.00001\\\"),\\n        )\\n        assert path is not None\\n        assert len(path) == 3  # Sarah -> Matt -> Photo1\\n        assert str(path[1]) == \\\"1.1\\\"  # Through Matt\\n\\n        # Subgraph\\n        sg = graph.subgraph(HypernetAddress.parse(\\\"1.1\\\"), max_depth=1)\\n        assert len(sg[\\\"nodes\\\"]) >= 4  \n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-17T01:23:15.948764+00:00",
  "updated_at": "2026-02-17T01:23:15.948764+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:6"
}