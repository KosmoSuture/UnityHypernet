{
  "address": "0.1.12.4.0.1.3.2.1",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\3\\2\\node.json",
    "size": 5293,
    "content": "{\n  \"address\": \"0.1.3.2\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"address.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\hypernet\\\\address.py\",\n    \"size\": 4685,\n    \"content\": \"\\\"\\\"\\\"\\nHypernet Addressing System (HA)\\n\\nSemantic, hierarchical addresses that replace UUIDs.\\nFormat: [CATEGORY].[SUBCATEGORY].[TYPE].[SUBTYPE].[INSTANCE]\\n\\nAddresses are variable-depth:\\n  1         = People category\\n  1.1       = Matt (specific person)\\n  1.1.1     = Matt's media\\n  1.1.1.1   = Matt's photos\\n  1.1.1.1.00001 = Matt's first photo\\n\\nCategories:\\n  0.* = Hypernet System Definitions\\n  1.* = People (Humans)\\n  2.* = AI Entities\\n  3.* = Businesses & Organizations\\n  4.* = Knowledge & Information\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\nfrom dataclasses import dataclass, field\\nfrom typing import Optional\\n\\n\\n@dataclass(frozen=True)\\nclass HypernetAddress:\\n    \\\"\\\"\\\"A semantic, hierarchical address in the Hypernet.\\\"\\\"\\\"\\n\\n    parts: tuple[str, ...]\\n\\n    def __post_init__(self):\\n        if not self.parts:\\n            raise ValueError(\\\"Address cannot be empty\\\")\\n        for part in self.parts:\\n            if not part:\\n                raise ValueError(f\\\"Address parts cannot be empty strings: {self.parts}\\\")\\n\\n    @classmethod\\n    def parse(cls, address: str) -> HypernetAddress:\\n        \\\"\\\"\\\"Parse a dot-separated address string.\\\"\\\"\\\"\\n        if not address or not address.strip():\\n            raise ValueError(\\\"Address string cannot be empty\\\")\\n        raw_parts = address.strip().split(\\\".\\\")\\n        return cls(parts=tuple(raw_parts))\\n\\n    @property\\n    def category(self) -> str:\\n        \\\"\\\"\\\"Root category (0=System, 1=People, 2=AI, 3=Business, 4=Knowledge).\\\"\\\"\\\"\\n        return self.parts[0]\\n\\n    @property\\n    def depth(self) -> int:\\n        \\\"\\\"\\\"How many levels deep this address goes.\\\"\\\"\\\"\\n        return len(self.parts)\\n\\n    @property\\n    def parent(self) -> Optional[HypernetAddress]:\\n        \\\"\\\"\\\"Parent address (one level up). None if root.\\\"\\\"\\\"\\n        if self.depth <= 1:\\n            return None\\n        return HypernetAddress(parts=self.parts[:-1])\\n\\n    @property\\n    def root(self) -> HypernetAddress:\\n        \\\"\\\"\\\"Root category address.\\\"\\\"\\\"\\n        return HypernetAddress(parts=(self.parts[0],))\\n\\n    @property\\n    def owner(self) -> Optional[HypernetAddress]:\\n        \\\"\\\"\\\"Owner address for categories 1-4 (e.g., 1.1 for Matt, 2.1 for Claude).\\\"\\\"\\\"\\n        cat = self.parts[0]\\n        if cat in (\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\") and self.depth >= 2:\\n            return HypernetAddress(parts=self.parts[:2])\\n        return None\\n\\n    @property\\n    def is_definition(self) -> bool:\\n        \\\"\\\"\\\"True if this is a system definition (0.*).\\\"\\\"\\\"\\n        return self.parts[0] == \\\"0\\\"\\n\\n    @property\\n    def is_instance(self) -> bool:\\n        \\\"\\\"\\\"True if the last part looks like an instance number (zero-padded).\\\"\\\"\\\"\\n        last = self.parts[-1]\\n        return last.isdigit() and len(last) >= 5\\n\\n    def is_ancestor_of(self, other: HypernetAddress) -> bool:\\n        \\\"\\\"\\\"True if this address is a parent/ancestor of the other.\\\"\\\"\\\"\\n        if self.depth >= other.depth:\\n            return False\\n        return other.parts[:self.depth] == self.parts\\n\\n    def is_descendant_of(self, other: HypernetAddress) -> bool:\\n        \\\"\\\"\\\"True if this address is a child/descendant of the other.\\\"\\\"\\\"\\n        return other.is_ancestor_of(self)\\n\\n    def child(self, part: str) -> HypernetAddress:\\n        \\\"\\\"\\\"Create a child address by appending a part.\\\"\\\"\\\"\\n        return HypernetAddress(parts=self.parts + (part,))\\n\\n    def next_instance(self, current_max: int = 0) -> HypernetAddress:\\n        \\\"\\\"\\\"Generate the next instance address under this prefix.\\\"\\\"\\\"\\n        instance_num = str(current_max + 1).zfill(5)\\n        return self.child(instance_num)\\n\\n    def to_path(self) -> str:\\n        \\\"\\\"\\\"Convert to a filesystem-friendly path (e.g., '1/1/1/1/00001').\\\"\\\"\\\"\\n        return \\\"/\\\".join(self.parts)\\n\\n    def __str__(self) -> str:\\n        return \\\".\\\".join(self.parts)\\n\\n    def __repr__(self) -> str:\\n        return f\\\"HA({self})\\\"\\n\\n    def __hash__(self) -> int:\\n        return hash(self.parts)\\n\\n    def __eq__(self, other: object) -> bool:\\n        if isinstance(other, HypernetAddress):\\n            return self.parts == other.parts\\n        return NotImplemented\\n\\n    def __lt__(self, other: HypernetAddress) -> bool:\\n        \\\"\\\"\\\"Sort addresses hierarchically.\\\"\\\"\\\"\\n        return self.parts < other.parts\\n\\n\\n# Category constants\\nSYSTEM = HypernetAddress.parse(\\\"0\\\")\\nPEOPLE = HypernetAddress.parse(\\\"1\\\")\\nAI = HypernetAddress.parse(\\\"2\\\")\\nBUSINESS = HypernetAddress.parse(\\\"3\\\")\\nKNOWLEDGE = HypernetAddress.parse(\\\"4\\\")\\n\\n# Well-known addresses\\nTYPE_REGISTRY = HypernetAddress.parse(\\\"0.4\\\")\\nUNIVERSAL_OBJECTS = HypernetAddress.parse(\\\"0.5\\\")\\nUNIVERSAL_LINKS = HypernetAddress.parse(\\\"0.6\\\")\\nWORKFLOWS = HypernetAddress.parse(\\\"0.7\\\")\\n\"\n  },\n  \"created_at\": \"2026-02-15T11:54:04.101159+00:00\",\n  \"updated_at\": \"2026-02-15T11:54:04.101159+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"file:address.py\"\n}"
  },
  "created_at": "2026-02-17T01:23:15.785719+00:00",
  "updated_at": "2026-02-17T01:23:15.785719+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}