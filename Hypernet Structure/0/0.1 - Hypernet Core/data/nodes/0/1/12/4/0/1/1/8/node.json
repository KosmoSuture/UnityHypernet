{
  "address": "0.1.12.4.0.1.1.8",
  "type_address": null,
  "data": {
    "name": "8",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\1\\8",
    "content_preview": "{\n  \"address\": \"0.1.1.8\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"mvp_models.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.1 - Core System\\\\mvp_models.py\",\n    \"size\": 16988,\n    \"content\": \"\\\"\\\"\\\"\\nHypernet MVP Data Models\\nPython models for the minimal viable database schema\\nUsing Pydantic for validation and FastAPI integration\\n\\\"\\\"\\\"\\n\\nfrom datetime import datetime\\nfrom typing import Optional, List, Dict, Any\\nfrom enum import Enum\\nfrom pydantic import BaseModel, Field, field_validator\\nimport json\\n\\n\\n# ============================================================================\\n# ENUMS\\n# ============================================================================\\n\\nclass PrivacyLevel(str, Enum):\\n    \\\"\\\"\\\"Privacy levels for objects\\\"\\\"\\\"\\n    PRIVATE = \\\"private\\\"\\n    FAMILY = \\\"family\\\"\\n    FRIENDS = \\\"friends\\\"\\n    PROFESSIONAL = \\\"professional\\\"\\n    PUBLIC = \\\"public\\\"\\n    AI_ACCESS = \\\"ai_access\\\"\\n    LEGACY = \\\"legacy\\\"\\n\\n\\nclass ObjectStatus(str, Enum):\\n    \\\"\\\"\\\"Status of objects\\\"\\\"\\\"\\n    ACTIVE = \\\"active\\\"\\n    ARCHIVED = \\\"archived\\\"\\n    DELETED = \\\"deleted\\\"\\n\\n\\nclass ObjectType(str, Enum):\\n    \\\"\\\"\\\"Types of objects in Hypernet\\\"\\\"\\\"\\n    PHOTO = \\\"photo\\\"\\n    EMAIL = \\\"email\\\"\\n    PERSON = \\\"person\\\"\\n    EVENT = \\\"event\\\"\\n    LOCATION = \\\"location\\\"\\n    DOCUMENT = \\\"document\\\"\\n    NOTE = \\\"note\\\"\\n    TASK = \\\"task\\\"\\n\\n\\nclass LinkType(str, Enum):\\n    \\\"\\\"\\\"Types of relationships between objects\\\"\\\"\\\"\\n    DEPICTS = \\\"depicts\\\"  # Photo depicts a person\\n    MENTIONS = \\\"mentions\\\"  # Email mentions a person\\n    LOCATED_AT = \\\"located_at\\\"  # Photo taken at location\\n    RELATED_TO = \\\"related_to\\\"  # Generic relationship\\n    PARENT_OF = \\\"parent_of\\\"  # Person is parent of person\\n    CHILD_OF = \\\"child_of\\\"  # Person is child of person\\n    SPOUSE_OF = \\\"spouse_of\\\"  # Person is spouse of person\\n    OCCURRED_AT = \\\"occurred_at\\\"  # Event occurred at location\\n    ATTENDED_BY = \\\"attended_by\\\"  # Event attended by person\\n    ATTACHED_TO = \\\"attached_to\\\"  # Document attached to email\\n\\n\\n# ============================================================================\\n# BASE MODELS\\n# ============================================================================\\n\\nclass HypernetObject(BaseModel):\\n    \\\"\\\"\\\"Base model for all Hypernet objects\\\"\\\"\\\"\\n    id: Optional[int] = None\\n    hypernet_address: str\\n    object_type: ObjectType\\n    owner_address: str\\n    status: ObjectStatus = ObjectStatus.ACTIVE\\n\\n    title: Optional[str] = None\\n    description: Optional[str] = None\\n    privacy_level: PrivacyLevel = PrivacyLevel.PRIVATE\\n\\n    created_at: datetime = Field(default_factory=datetime.now)\\n    updated_at: datetime = Field(default_factory=datetime.now)\\n    original_date: Optional[datetime] = None\\n\\n    file_path: Optional[str] = None\\n    file_size: Optional[int] = None\\n    mime_type: Optional[str] = None\\n\\n    metadata: Optional[Dict[str, Any]] = None\\n    search_text: Optional[str] = None\\n\\n    class Config:\\n        use_enum_values = True\\n        json_encoders = {\\n            datetime: lambda v: v.isoformat()\\n        }\\n\\n    def to_db_dict(self) -> dict:\\n        \\\"\\\"\\\"Convert to dictionary for database insertion\\\"\\\"\\\"\\n        data = self.model_dump()\\n        # Convert datetime to ISO string\\n        if data.get('created_at'):\\n            data['created_at'] = data['created_at'].isoformat()\\n        if data.get('updated_at'):\\n            data['updated_at'] = data['updated_at'].isoformat()\\n        if data.get('original_date'):\\n            data['original_date'] = data['original_date'].isoformat()\\n        # Convert metadata dict to JSON string\\n        if data.get('metadata'):\\n            data['metadata'] = json.dumps(data['metadata'])\\n        return data\\n\\n\\nclass Link(BaseModel):\\n    \\\"\\\"\\\"Link between two Hypernet objects\\\"\\\"\\\"\\n    id: Optional[int] = None\\n    hypernet_address: str\\n\\n    source_address: str\\n    target_address: str\\n    link_type: LinkType\\n\\n    strength: float = Field(default=1.0, ge=0.0, le=1.0)\\n    bidirectional: bool = False\\n\\n    context: Optional[str] = None\\n    created_by: str = \\\"system\\\"\\n\\n    created_at: datetime = Field(default_factory=datetime.now)\\n    updated_at: datetime = Field(default_factory=datetime.now)\\n\\n    status: ObjectStatus = ObjectStatus.ACTIVE\\n    metadata: Optional[Dict[str, Any]] = None\\n\\n    class Config:\\n        use_enum_values = True\\n\\n\\n# ============================================================================\\n# SPECIFIC OBJECT MODELS\\n# ============================================================================\\n\\nclass Photo(BaseModel):\\n    \\\"\\\"\\\"Photo object with EXIF metadata\\\"\\\"\\\"\\n    id: Optional[int] = None\\n    object_id: Optional[int] = None\\n    hypernet_address: str\\n\\n    # Dimensions\\n    width: Optional[int] = None\\n    height: Optional[int] = None\\n    orientation: Optional[int] = None\\n\\n    # Camera info\\n    camera_make: Optional[str] = None\\n    camera_model: Optional[str] = None\\n    lens_model: Optional[str] = None\\n\\n    # Settings\\n    iso: Optional[int] = None\\n    aperture: Optional[float] = None\\n    shutter_speed: Optional[str] = None\\n    focal_length: Optional[float] = None\\n    flash: Optional[bool] = None\\n\\n    # Location\\n    latitude: Optional[float] = None\\n    longitude: Optional[float] = None\\n    altitude: Optional[float] = None\\n    location_name: Optional[str] = None\\n\\n    # When taken\\n    taken_at: Optional[datetime] = None\\n\\n    # Thumbnails\\n    thumbnail_small: Optional[str] = None\\n    thumbnail_medium: Optional[str] = None\\n    thumbnail_large: Optional[str] = None\\n\\n    # AI metadata\\n    ai_caption: Optional[str] = None\\n    ai_tags: Optional[List[str]] = None\\n    ai_detected_faces: Optional[List[Dict[str, Any]]] = None\\n\\n    # Duplicate detection\\n    perceptual_hash: Optional[str] = None\\n\\n    def to_db_dict(self) -> dict:\\n        \\\"\\\"\\\"Convert to dictionary for database insertion\\\"\\\"\\\"\\n        data = self.model_dump()\\n        if data.get('taken_at'):\\n            data['taken_at'] = data['taken_at'].isoformat()\\n        if data.get('ai_tags'):\\n            data['ai_tags'] = json.dumps(data['ai_tags'])\\n        if data.get('ai_detected_faces'):\\n            data['ai_detected_faces'] = json.dumps(data['ai_detected_faces'])\\n        return data\\n\\n\\nclass Person(BaseModel):\\n    \\\"\\\"\\\"Person (living or deceased)\\\"\\\"\\\"\\n    id: Optional[int] = None\\n    object_id: Optional[int] = None\\n    hypernet_address: str\\n\\n    # Name\\n    first_name: Optional[str] = None\\n    middle_name: Optional[str] = None\\n    last_name: Optional[str] = None\\n    preferred_name: Optional[str] = None\\n    suffix: Optional[str] = None\\n\\n    # Dates\\n    birth_date: Optional[datetime] = None\\n    death_date: Optional[datetime] = None\\n\\n    # Contact\\n    email: Optional[str] = None\\n    phone: Optional[str] = None\\n\\n    # Relationships\\n    relationship_to_owner: Optional[str] = None\\n\\n    # Profile\\n    profile_photo_address: Optional[str] = None\\n    bio: Optional[str] = None\\n\\n    # Status\\n    is_living: bool = True\\n    is_hypernet_user: bool = False\\n\\n    @property\\n    def full_name(self) -> str:\\n        \\\"\\\"\\\"Get full name\\\"\\\"\\\"\\n        parts = [self.first_name, self.middle_name, self.last_name, self.suffix]\\n        return \\\" \\\".join(p for p in parts if p)\\n\\n    @property\\n    def display_name(self) -> str:\\n        \\\"\\\"\\\"Get display name (preferred or full)\\\"\\\"\\\"\\n        if self.preferred_name:\\n            return self.preferred_name\\n        return self.full_name\\n\\n    def to_db_dict(self) -> dict:\\n        \\\"\\\"\\\"Convert to dictionary for database insertion\\\"\\\"\\\"\\n        data = self.model_dump()\\n        if data.get('birth_date'):\\n            data['birth_date'] = data['birth_date'].isoformat()\\n        if data.get('death_date'):\\n            data['death_date'] = data['death_date'].isoformat()\\n        return data\\n\\n\\nclass Event(BaseModel):\\n    \\\"\\\"\\\"Event (birthday, holiday, trip, meeting, etc.)\\\"\\\"\\\"\\n    id: Optional[int] = None\\n    object_id: Optional[int] = None\\n    hypernet_address: str\\n\\n    event_type: str\\n\\n    # When\\n    start_date: datetime\\n    end_date: Optional[datetime] = None\\n    all_day: bool = False\\n\\n    # Where\\n    location_name: Optional[str] = None\\n    latitude: Optional[float] = None\\n    longitude: Optional[float] = None\\n\\n    # Recurrence\\n    recurrence_rule: Optional[str] = None\\n\\n    # Attendees\\n    attendees: Optional[List[str]] = None  # List of person HAs\\n\\n    def to_db_dict(self) -> dict:\\n        \\\"\\\"\\\"Convert to dictionary for database insertion\\\"\\\"\\\"\\n        data = self.model_dump()\\n        if data.get('start_date'):\\n            data['start_date'] = data['start_date'].isoformat()\\n        if data.get('end_date'):\\n            data['end_date'] = data['end_date'].isoformat()\\n        if data.get('attendees'):\\n            data['attendees'] = json.dumps(data['attendees'])\\n        return data\\n\\n\\nclass Email(BaseModel):\\n    \\\"\\\"\\\"Email message\\\"\\\"\\\"\\n    id: Optional[int] = None\\n    object_id: Optional[int] = None\\n    hypernet_address: str\\n\\n    # Headers\\n    message_id: str\\n    subject: Optional[str] = None\\n    from_address: str\\n    from_name: Optional[str] = None\\n    to_addresses: List[str]\\n    cc_addresses: Optional[List[str]] = None\\n    bcc_addresses: Optional[List[str]] = None\\n\\n    # Content\\n    body_plain: Optional[str] = None\\n    body_html: Optional[str] = None\\n\\n    # Metadata\\n    sent_at: datetime\\n    received_at: Optional[datetime] = None\\n\\n    # Threading\\n    in_reply_to: Optional[str] = None\\n    thread_id: Optional[str] = None\\n\\n    # Flags\\n    is_read: bool = False\\n    is_starred: bool = False\\n    is_archived: bool = False\\n\\n    # Attachments\\n    attachments: Optional[List[str]] = None\\n\\n    def to_db_dict(self) -> dict:\\n       \n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-17T01:23:12.806811+00:00",
  "updated_at": "2026-02-17T01:23:12.806811+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:8"
}