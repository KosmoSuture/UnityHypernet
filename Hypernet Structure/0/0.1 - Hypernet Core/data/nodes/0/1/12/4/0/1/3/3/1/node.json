{
  "address": "0.1.12.4.0.1.3.3.1",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\3\\3\\node.json",
    "size": 6394,
    "content": "{\n  \"address\": \"0.1.3.3\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"graph.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\hypernet\\\\graph.py\",\n    \"size\": 5874,\n    \"content\": \"\\\"\\\"\\\"\\nHypernet Graph\\n\\nGraph traversal and query engine for the Hypernet. Provides the ability\\nto walk the graph following links, find paths between nodes, and run\\npattern-based queries.\\n\\nThis is where the Hypernet's graph-database nature lives.\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\nfrom collections import deque\\nfrom typing import Optional, Callable\\n\\nfrom .address import HypernetAddress\\nfrom .node import Node\\nfrom .link import Link\\nfrom .store import Store\\n\\n\\nclass Graph:\\n    \\\"\\\"\\\"Graph traversal and query engine over a Hypernet Store.\\\"\\\"\\\"\\n\\n    def __init__(self, store: Store):\\n        self.store = store\\n\\n    def traverse(\\n        self,\\n        start: HypernetAddress,\\n        relationship: Optional[str] = None,\\n        max_depth: int = 3,\\n        filter_fn: Optional[Callable[[Node], bool]] = None,\\n    ) -> list[Node]:\\n        \\\"\\\"\\\"\\n        Breadth-first traversal from a starting node, following links.\\n\\n        Returns all reachable nodes up to max_depth, optionally filtered\\n        by relationship type and a custom filter function.\\n        \\\"\\\"\\\"\\n        visited: set[HypernetAddress] = set()\\n        queue: deque[tuple[HypernetAddress, int]] = deque([(start, 0)])\\n        results: list[Node] = []\\n\\n        while queue:\\n            addr, depth = queue.popleft()\\n\\n            if addr in visited:\\n                continue\\n            visited.add(addr)\\n\\n            if depth > 0:  # Don't include start node in results\\n                node = self.store.get_node(addr)\\n                if node and not node.is_deleted:\\n                    if filter_fn is None or filter_fn(node):\\n                        results.append(node)\\n\\n            if depth < max_depth:\\n                neighbors = self.store.get_neighbors(addr, relationship)\\n                for neighbor in neighbors:\\n                    if neighbor not in visited:\\n                        queue.append((neighbor, depth + 1))\\n\\n        return results\\n\\n    def find_path(\\n        self,\\n        start: HypernetAddress,\\n        end: HypernetAddress,\\n        max_depth: int = 6,\\n    ) -> Optional[list[HypernetAddress]]:\\n        \\\"\\\"\\\"\\n        Find the shortest path between two nodes using BFS.\\n        Returns the path as a list of addresses, or None if no path exists.\\n        \\\"\\\"\\\"\\n        if start == end:\\n            return [start]\\n\\n        visited: set[HypernetAddress] = set()\\n        queue: deque[list[HypernetAddress]] = deque([[start]])\\n\\n        while queue:\\n            path = queue.popleft()\\n            current = path[-1]\\n\\n            if current in visited:\\n                continue\\n            visited.add(current)\\n\\n            if len(path) > max_depth + 1:\\n                continue\\n\\n            neighbors = self.store.get_neighbors(current)\\n            for neighbor in neighbors:\\n                if neighbor == end:\\n                    return path + [neighbor]\\n                if neighbor not in visited:\\n                    queue.append(path + [neighbor])\\n\\n        return None\\n\\n    def linked_to(\\n        self,\\n        address: HypernetAddress,\\n        relationship: str,\\n    ) -> list[Node]:\\n        \\\"\\\"\\\"Get all nodes linked FROM the given address by a specific relationship.\\\"\\\"\\\"\\n        links = self.store.get_links_from(address, relationship)\\n        nodes = []\\n        for link in links:\\n            node = self.store.get_node(link.to_address)\\n            if node and not node.is_deleted:\\n                nodes.append(node)\\n        return nodes\\n\\n    def linked_from(\\n        self,\\n        address: HypernetAddress,\\n        relationship: str,\\n    ) -> list[Node]:\\n        \\\"\\\"\\\"Get all nodes linked TO the given address by a specific relationship.\\\"\\\"\\\"\\n        links = self.store.get_links_to(address, relationship)\\n        nodes = []\\n        for link in links:\\n            node = self.store.get_node(link.from_address)\\n            if node and not node.is_deleted:\\n                nodes.append(node)\\n        return nodes\\n\\n    def subgraph(\\n        self,\\n        root: HypernetAddress,\\n        max_depth: int = 2,\\n    ) -> dict:\\n        \\\"\\\"\\\"\\n        Extract a subgraph centered on a node. Returns nodes and links\\n        within max_depth hops. Useful for visualization and API responses.\\n        \\\"\\\"\\\"\\n        visited_nodes: set[HypernetAddress] = set()\\n        collected_links: list[Link] = []\\n        queue: deque[tuple[HypernetAddress, int]] = deque([(root, 0)])\\n\\n        while queue:\\n            addr, depth = queue.popleft()\\n\\n            if addr in visited_nodes:\\n                continue\\n            visited_nodes.add(addr)\\n\\n            if depth < max_depth:\\n                for link in self.store.get_links_from(addr):\\n                    collected_links.append(link)\\n                    if link.to_address not in visited_nodes:\\n                        queue.append((link.to_address, depth + 1))\\n\\n                for link in self.store.get_links_to(addr):\\n                    if link.bidirectional:\\n                        collected_links.append(link)\\n                        if link.from_address not in visited_nodes:\\n                            queue.append((link.from_address, depth + 1))\\n\\n        nodes = []\\n        for addr in visited_nodes:\\n            node = self.store.get_node(addr)\\n            if node:\\n                nodes.append(node)\\n\\n        return {\\n            \\\"nodes\\\": [n.to_dict() for n in nodes],\\n            \\\"links\\\": [l.to_dict() for l in collected_links],\\n            \\\"center\\\": str(root),\\n            \\\"depth\\\": max_depth,\\n        }\\n\\n    def children(self, address: HypernetAddress) -> list[Node]:\\n        \\\"\\\"\\\"\\n        Get direct children in the address hierarchy (not link-based).\\n        E.g., children of 1.1 returns 1.1.0, 1.1.1, 1.1.2, etc.\\n        \\\"\\\"\\\"\\n        return self.store.list_nodes(prefix=address)\\n\"\n  },\n  \"created_at\": \"2026-02-15T11:54:04.115157+00:00\",\n  \"updated_at\": \"2026-02-15T11:54:04.115157+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"file:graph.py\"\n}"
  },
  "created_at": "2026-02-17T01:23:15.802718+00:00",
  "updated_at": "2026-02-17T01:23:15.802718+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}