{
  "address": "0.1.12.4.0.1.3.6.1",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data-backup-pre-collision-fix\\nodes\\0\\1\\3\\6\\node.json",
    "size": 7380,
    "content": "{\n  \"address\": \"0.1.3.6\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"server.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\hypernet\\\\server.py\",\n    \"size\": 6815,\n    \"content\": \"\\\"\\\"\\\"\\nHypernet API Server\\n\\nFastAPI server that exposes the Hypernet graph through a REST API.\\nUses Hypernet Addresses as the native identifier \\u2014 no UUIDs.\\n\\nEndpoints follow the addressing spec:\\n  GET  /node/{address}           - Get a node\\n  PUT  /node/{address}           - Create/update a node\\n  GET  /node/{address}/links     - Get links from a node\\n  GET  /node/{address}/neighbors - Get connected nodes\\n  GET  /node/{address}/subgraph  - Get local subgraph\\n  POST /link                     - Create a link\\n  GET  /query                    - Query nodes by type, owner, prefix\\n  GET  /stats                    - Store statistics\\n\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\nfrom pathlib import Path\\nfrom typing import Optional\\n\\nfrom .address import HypernetAddress\\nfrom .node import Node\\nfrom .link import Link\\nfrom .store import Store\\nfrom .graph import Graph\\n\\n# Defer FastAPI import so the library works without it installed\\n_app = None\\n_store = None\\n_graph = None\\n\\n\\ndef create_app(data_dir: str | Path = \\\"data\\\") -> \\\"FastAPI\\\":\\n    \\\"\\\"\\\"Create and configure the Hypernet API server.\\\"\\\"\\\"\\n    from fastapi import FastAPI, HTTPException\\n    from fastapi.middleware.cors import CORSMiddleware\\n    from pydantic import BaseModel\\n\\n    global _store, _graph\\n\\n    app = FastAPI(\\n        title=\\\"Hypernet\\\",\\n        description=\\\"The Hypernet \\u2014 decentralized infrastructure for human-AI collaboration\\\",\\n        version=\\\"0.1.0\\\",\\n    )\\n\\n    app.add_middleware(\\n        CORSMiddleware,\\n        allow_origins=[\\\"*\\\"],  # Lock down in production\\n        allow_methods=[\\\"*\\\"],\\n        allow_headers=[\\\"*\\\"],\\n    )\\n\\n    _store = Store(data_dir)\\n    _graph = Graph(_store)\\n\\n    # === Request/Response models ===\\n\\n    class NodeCreate(BaseModel):\\n        type_address: Optional[str] = None\\n        data: dict = {}\\n        source_type: Optional[str] = None\\n        source_id: Optional[str] = None\\n\\n    class LinkCreate(BaseModel):\\n        from_address: str\\n        to_address: str\\n        link_type: str\\n        relationship: str\\n        strength: float = 1.0\\n        bidirectional: bool = False\\n        data: dict = {}\\n        sort_order: Optional[int] = None\\n\\n    # === Node endpoints ===\\n\\n    @app.get(\\\"/node/{address:path}\\\")\\n    def get_node(address: str):\\n        ha = HypernetAddress.parse(address)\\n        node = _store.get_node(ha)\\n        if not node:\\n            raise HTTPException(404, f\\\"Node not found: {address}\\\")\\n        return node.to_dict()\\n\\n    @app.put(\\\"/node/{address:path}\\\")\\n    def put_node(address: str, body: NodeCreate):\\n        ha = HypernetAddress.parse(address)\\n        existing = _store.get_node(ha)\\n        if existing:\\n            existing.update_data(**body.data)\\n            if body.type_address:\\n                existing.type_address = HypernetAddress.parse(body.type_address)\\n            _store.put_node(existing)\\n            return existing.to_dict()\\n        else:\\n            node = Node(\\n                address=ha,\\n                type_address=HypernetAddress.parse(body.type_address) if body.type_address else None,\\n                data=body.data,\\n                source_type=body.source_type,\\n                source_id=body.source_id,\\n            )\\n            _store.put_node(node)\\n            return node.to_dict()\\n\\n    @app.delete(\\\"/node/{address:path}\\\")\\n    def delete_node(address: str, hard: bool = False):\\n        ha = HypernetAddress.parse(address)\\n        if _store.delete_node(ha, hard=hard):\\n            return {\\\"deleted\\\": address, \\\"hard\\\": hard}\\n        raise HTTPException(404, f\\\"Node not found: {address}\\\")\\n\\n    # === Link endpoints ===\\n\\n    @app.get(\\\"/node/{address:path}/links\\\")\\n    def get_node_links(address: str, relationship: Optional[str] = None, direction: str = \\\"outgoing\\\"):\\n        ha = HypernetAddress.parse(address)\\n        if direction == \\\"outgoing\\\":\\n            links = _store.get_links_from(ha, relationship)\\n        elif direction == \\\"incoming\\\":\\n            links = _store.get_links_to(ha, relationship)\\n        else:\\n            links = _store.get_links_from(ha, relationship) + _store.get_links_to(ha, relationship)\\n        return [l.to_dict() for l in links]\\n\\n    @app.get(\\\"/node/{address:path}/neighbors\\\")\\n    def get_neighbors(address: str, relationship: Optional[str] = None):\\n        ha = HypernetAddress.parse(address)\\n        neighbors = _store.get_neighbors(ha, relationship)\\n        nodes = []\\n        for n_addr in neighbors:\\n            node = _store.get_node(n_addr)\\n            if node:\\n                nodes.append(node.to_dict())\\n        return nodes\\n\\n    @app.get(\\\"/node/{address:path}/subgraph\\\")\\n    def get_subgraph(address: str, depth: int = 2):\\n        ha = HypernetAddress.parse(address)\\n        return _graph.subgraph(ha, max_depth=depth)\\n\\n    @app.post(\\\"/link\\\")\\n    def create_link(body: LinkCreate):\\n        link = Link(\\n            from_address=HypernetAddress.parse(body.from_address),\\n            to_address=HypernetAddress.parse(body.to_address),\\n            link_type=body.link_type,\\n            relationship=body.relationship,\\n            strength=body.strength,\\n            bidirectional=body.bidirectional,\\n            data=body.data,\\n            sort_order=body.sort_order,\\n        )\\n        link_hash = _store.put_link(link)\\n        result = link.to_dict()\\n        result[\\\"hash\\\"] = link_hash\\n        return result\\n\\n    # === Query endpoints ===\\n\\n    @app.get(\\\"/query\\\")\\n    def query_nodes(\\n        prefix: Optional[str] = None,\\n        type_address: Optional[str] = None,\\n        owner: Optional[str] = None,\\n        include_deleted: bool = False,\\n    ):\\n        nodes = _store.list_nodes(\\n            prefix=HypernetAddress.parse(prefix) if prefix else None,\\n            type_address=HypernetAddress.parse(type_address) if type_address else None,\\n            owner=HypernetAddress.parse(owner) if owner else None,\\n            include_deleted=include_deleted,\\n        )\\n        return [n.to_dict() for n in nodes]\\n\\n    @app.get(\\\"/stats\\\")\\n    def get_stats():\\n        return _store.stats()\\n\\n    @app.get(\\\"/next-address/{prefix:path}\\\")\\n    def next_address(prefix: str):\\n        ha = HypernetAddress.parse(prefix)\\n        return {\\\"next\\\": str(_store.next_address(ha))}\\n\\n    @app.get(\\\"/\\\")\\n    def root():\\n        return {\\n            \\\"name\\\": \\\"Hypernet\\\",\\n            \\\"version\\\": \\\"0.1.0\\\",\\n            \\\"description\\\": \\\"Decentralized infrastructure for human-AI collaboration\\\",\\n            \\\"stats\\\": _store.stats(),\\n        }\\n\\n    return app\\n\\n\\ndef run(data_dir: str = \\\"data\\\", host: str = \\\"0.0.0.0\\\", port: int = 8000):\\n    \\\"\\\"\\\"Run the Hypernet server.\\\"\\\"\\\"\\n    import uvicorn\\n    app = create_app(data_dir)\\n    uvicorn.run(app, host=host, port=port)\\n\"\n  },\n  \"created_at\": \"2026-02-15T11:54:04.187062+00:00\",\n  \"updated_at\": \"2026-02-15T11:54:04.187062+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"file:server.py\"\n}"
  },
  "created_at": "2026-02-17T01:23:15.857241+00:00",
  "updated_at": "2026-02-17T01:23:15.857241+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}