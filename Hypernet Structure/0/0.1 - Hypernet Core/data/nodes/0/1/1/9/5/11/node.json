{
  "address": "0.1.1.9.5.11",
  "type_address": null,
  "data": {
    "name": "notes.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\routes\\notes.py",
    "size": 7275,
    "content": "\"\"\"\nNotes Routes\n\nEndpoints for managing personal notes and documents.\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.user import User\nfrom app.models.note import Note\n\nrouter = APIRouter()\n\n\n# Request/Response Models\nclass NoteCreate(BaseModel):\n    \"\"\"Note creation request\"\"\"\n    title: str = Field(..., max_length=500)\n    content: str\n    note_format: str = Field(default='plain', description=\"plain, markdown, html\")\n    folder: Optional[str] = Field(None, max_length=255)\n    is_pinned: bool = Field(default=False)\n\n\nclass NoteUpdate(BaseModel):\n    \"\"\"Note update request\"\"\"\n    title: Optional[str] = Field(None, max_length=500)\n    content: Optional[str] = None\n    note_format: Optional[str] = Field(None, description=\"plain, markdown, html\")\n    folder: Optional[str] = Field(None, max_length=255)\n    is_pinned: Optional[bool] = None\n\n\nclass NoteResponse(BaseModel):\n    \"\"\"Note response\"\"\"\n    id: str\n    user_id: str\n    title: str\n    content: str\n    note_format: str\n    folder: Optional[str]\n    is_pinned: bool\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True\n\n\nclass NoteListResponse(BaseModel):\n    \"\"\"Paginated note list response\"\"\"\n    items: List[NoteResponse]\n    total: int\n    page: int\n    page_size: int\n\n\n@router.post(\"\", response_model=NoteResponse, status_code=status.HTTP_201_CREATED)\nasync def create_note(\n    request: NoteCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new note.\n\n    - **title**: Note title (required)\n    - **content**: Note content (required)\n    - **note_format**: plain, markdown, or html (default: plain)\n    - **folder**: Optional folder/category\n    - **is_pinned**: Pin to top of list\n    \"\"\"\n    note = Note(\n        user_id=current_user.id,\n        title=request.title,\n        content=request.content,\n        note_format=request.note_format,\n        folder=request.folder,\n        is_pinned=request.is_pinned\n    )\n\n    db.add(note)\n    db.commit()\n    db.refresh(note)\n\n    return NoteResponse.model_validate(note)\n\n\n@router.get(\"\", response_model=NoteListResponse)\nasync def list_notes(\n    folder: Optional[str] = Query(None, description=\"Filter by folder\"),\n    is_pinned: Optional[bool] = Query(None, description=\"Filter pinned notes\"),\n    search: Optional[str] = Query(None, description=\"Search in title and content\"),\n    page: int = Query(1, ge=1),\n    page_size: int = Query(50, ge=1, le=100),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List notes for the current user.\n\n    Supports:\n    - Filtering by folder\n    - Filtering pinned notes\n    - Full-text search in title and content\n    - Pagination\n\n    Results are ordered by pinned status, then updated_at descending.\n    \"\"\"\n    query = db.query(Note).filter(\n        and_(\n            Note.user_id == current_user.id,\n            Note.deleted_at.is_(None)\n        )\n    )\n\n    if folder:\n        query = query.filter(Note.folder == folder)\n\n    if is_pinned is not None:\n        query = query.filter(Note.is_pinned == is_pinned)\n\n    if search:\n        search_pattern = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Note.title.ilike(search_pattern),\n                Note.content.ilike(search_pattern)\n            )\n        )\n\n    total = query.count()\n\n    offset = (page - 1) * page_size\n    items = query.order_by(\n        Note.is_pinned.desc(),\n        Note.updated_at.desc()\n    ).offset(offset).limit(page_size).all()\n\n    return NoteListResponse(\n        items=[NoteResponse.model_validate(item) for item in items],\n        total=total,\n        page=page,\n        page_size=page_size\n    )\n\n\n@router.get(\"/{note_id}\", response_model=NoteResponse)\nasync def get_note(\n    note_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get a specific note by ID.\"\"\"\n    note = db.query(Note).filter(\n        and_(\n            Note.id == note_id,\n            Note.user_id == current_user.id,\n            Note.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not note:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Note not found\"\n        )\n\n    return NoteResponse.model_validate(note)\n\n\n@router.patch(\"/{note_id}\", response_model=NoteResponse)\nasync def update_note(\n    note_id: UUID,\n    request: NoteUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a note.\n\n    All fields are optional. Only provided fields will be updated.\n    The updated_at timestamp is automatically updated.\n    \"\"\"\n    note = db.query(Note).filter(\n        and_(\n            Note.id == note_id,\n            Note.user_id == current_user.id,\n            Note.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not note:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Note not found\"\n        )\n\n    if request.title is not None:\n        note.title = request.title\n    if request.content is not None:\n        note.content = request.content\n    if request.note_format is not None:\n        note.note_format = request.note_format\n    if request.folder is not None:\n        note.folder = request.folder\n    if request.is_pinned is not None:\n        note.is_pinned = request.is_pinned\n\n    db.commit()\n    db.refresh(note)\n\n    return NoteResponse.model_validate(note)\n\n\n@router.delete(\"/{note_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_note(\n    note_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Soft delete a note.\"\"\"\n    note = db.query(Note).filter(\n        and_(\n            Note.id == note_id,\n            Note.user_id == current_user.id,\n            Note.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not note:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Note not found\"\n        )\n\n    note.soft_delete()\n    db.commit()\n\n    return None\n\n\n@router.get(\"/folders/list\", response_model=List[str])\nasync def list_folders(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get list of all folders used in notes.\n\n    Returns distinct folder names for organizational purposes.\n    \"\"\"\n    folders = db.query(Note.folder).filter(\n        and_(\n            Note.user_id == current_user.id,\n            Note.deleted_at.is_(None),\n            Note.folder.isnot(None)\n        )\n    ).distinct().all()\n\n    return [folder[0] for folder in folders]\n"
  },
  "created_at": "2026-02-17T01:21:58.964181+00:00",
  "updated_at": "2026-02-17T01:21:58.964181+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:notes.py"
}