{
  "address": "0.1.1.1.6",
  "type_address": null,
  "data": {
    "name": "notifications.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\app\\routes\\notifications.py",
    "size": 12064,
    "content": "\"\"\"\nNotifications API Routes\n\nProvides CRUD operations for notification management including\nsystem notifications, alerts, reminders, and message notifications.\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_\nfrom typing import Optional, List\nfrom datetime import datetime\nfrom uuid import UUID\nfrom pydantic import BaseModel, Field\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.user import User\nfrom app.models.notification import Notification\n\n\nrouter = APIRouter()\n\n\n# Pydantic Models for Request/Response\nclass NotificationCreate(BaseModel):\n    notification_type: str = Field(..., description=\"system, alert, reminder, message, update, marketing\")\n    title: str = Field(..., max_length=300)\n    message: str = Field(..., max_length=1000)\n    priority: str = Field(default=\"normal\", description=\"low, normal, high, urgent\")\n    category: Optional[str] = Field(None, max_length=100)\n    action_url: Optional[str] = Field(None, description=\"URL to navigate when notification is clicked\")\n    action_label: Optional[str] = Field(None, max_length=100)\n    related_object_type: Optional[str] = Field(None, max_length=100, description=\"e.g., email, task, document\")\n    related_object_id: Optional[UUID] = Field(None, description=\"ID of related object\")\n    scheduled_for: Optional[datetime] = Field(None, description=\"When to send/display this notification\")\n    expires_at: Optional[datetime] = Field(None, description=\"When notification becomes irrelevant\")\n\n\nclass NotificationUpdate(BaseModel):\n    is_read: Optional[bool] = None\n    is_archived: Optional[bool] = None\n\n\nclass NotificationResponse(BaseModel):\n    id: UUID\n    user_id: UUID\n    notification_type: str\n    title: str\n    message: str\n    priority: str\n    category: Optional[str]\n    action_url: Optional[str]\n    action_label: Optional[str]\n    related_object_type: Optional[str]\n    related_object_id: Optional[UUID]\n    is_read: bool\n    is_archived: bool\n    read_at: Optional[datetime]\n    scheduled_for: Optional[datetime]\n    expires_at: Optional[datetime]\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True\n\n\nclass NotificationListResponse(BaseModel):\n    items: List[NotificationResponse]\n    total: int\n    unread_count: int\n    page: int\n    page_size: int\n    pages: int\n\n\nclass NotificationStats(BaseModel):\n    total: int\n    unread: int\n    by_type: dict\n    by_priority: dict\n\n\n# Endpoints\n@router.post(\"\", response_model=NotificationResponse, status_code=status.HTTP_201_CREATED)\nasync def create_notification(\n    notification_data: NotificationCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Create a new notification.\"\"\"\n    notification = Notification(\n        user_id=current_user.id,\n        **notification_data.dict()\n    )\n    db.add(notification)\n    db.commit()\n    db.refresh(notification)\n    return notification\n\n\n@router.get(\"\", response_model=NotificationListResponse)\nasync def list_notifications(\n    notification_type: Optional[str] = Query(None, description=\"Filter by notification type\"),\n    priority: Optional[str] = Query(None, description=\"Filter by priority\"),\n    category: Optional[str] = Query(None, description=\"Filter by category\"),\n    is_read: Optional[bool] = Query(None, description=\"Filter by read status\"),\n    is_archived: Optional[bool] = Query(None, description=\"Filter by archive status\"),\n    unread_only: bool = Query(False, description=\"Show only unread notifications\"),\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(50, ge=1, le=100, description=\"Items per page\"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"List notifications with optional filtering.\"\"\"\n    query = db.query(Notification).filter(\n        and_(\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None)\n        )\n    )\n\n    # Filter out expired notifications\n    query = query.filter(\n        or_(\n            Notification.expires_at.is_(None),\n            Notification.expires_at > datetime.utcnow()\n        )\n    )\n\n    # Filter out scheduled future notifications\n    query = query.filter(\n        or_(\n            Notification.scheduled_for.is_(None),\n            Notification.scheduled_for <= datetime.utcnow()\n        )\n    )\n\n    if notification_type:\n        query = query.filter(Notification.notification_type == notification_type)\n\n    if priority:\n        query = query.filter(Notification.priority == priority)\n\n    if category:\n        query = query.filter(Notification.category == category)\n\n    if is_read is not None:\n        query = query.filter(Notification.is_read == is_read)\n\n    if is_archived is not None:\n        query = query.filter(Notification.is_archived == is_archived)\n\n    if unread_only:\n        query = query.filter(Notification.is_read == False)\n\n    total = query.count()\n\n    # Count unread\n    unread_count = db.query(Notification).filter(\n        and_(\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None),\n            Notification.is_read == False,\n            or_(\n                Notification.expires_at.is_(None),\n                Notification.expires_at > datetime.utcnow()\n            )\n        )\n    ).count()\n\n    # Order by priority (urgent -> high -> normal -> low), then created_at descending\n    priority_order = {\n        'urgent': 0,\n        'high': 1,\n        'normal': 2,\n        'low': 3\n    }\n\n    from sqlalchemy import case\n    priority_case = case(\n        (Notification.priority == 'urgent', 0),\n        (Notification.priority == 'high', 1),\n        (Notification.priority == 'normal', 2),\n        (Notification.priority == 'low', 3),\n        else_=4\n    )\n\n    query = query.order_by(\n        Notification.is_read.asc(),  # Unread first\n        priority_case,\n        Notification.created_at.desc()\n    )\n\n    offset = (page - 1) * page_size\n    items = query.offset(offset).limit(page_size).all()\n\n    pages = (total + page_size - 1) // page_size\n\n    return NotificationListResponse(\n        items=items,\n        total=total,\n        unread_count=unread_count,\n        page=page,\n        page_size=page_size,\n        pages=pages\n    )\n\n\n@router.get(\"/stats\", response_model=NotificationStats)\nasync def get_notification_stats(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get notification statistics for the user.\"\"\"\n    from sqlalchemy import func\n\n    base_query = db.query(Notification).filter(\n        and_(\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None),\n            or_(\n                Notification.expires_at.is_(None),\n                Notification.expires_at > datetime.utcnow()\n            )\n        )\n    )\n\n    total = base_query.count()\n    unread = base_query.filter(Notification.is_read == False).count()\n\n    # By type\n    by_type_results = db.query(\n        Notification.notification_type,\n        func.count(Notification.id).label('count')\n    ).filter(\n        and_(\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None),\n            or_(\n                Notification.expires_at.is_(None),\n                Notification.expires_at > datetime.utcnow()\n            )\n        )\n    ).group_by(Notification.notification_type).all()\n\n    by_type = {row.notification_type: row.count for row in by_type_results}\n\n    # By priority\n    by_priority_results = db.query(\n        Notification.priority,\n        func.count(Notification.id).label('count')\n    ).filter(\n        and_(\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None),\n            or_(\n                Notification.expires_at.is_(None),\n                Notification.expires_at > datetime.utcnow()\n            )\n        )\n    ).group_by(Notification.priority).all()\n\n    by_priority = {row.priority: row.count for row in by_priority_results}\n\n    return NotificationStats(\n        total=total,\n        unread=unread,\n        by_type=by_type,\n        by_priority=by_priority\n    )\n\n\n@router.post(\"/mark-all-read\", response_model=dict)\nasync def mark_all_read(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Mark all notifications as read.\"\"\"\n    updated_count = db.query(Notification).filter(\n        and_(\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None),\n            Notification.is_read == False\n        )\n    ).update({\n        \"is_read\": True,\n        \"read_at\": datetime.utcnow(),\n        \"updated_at\": datetime.utcnow()\n    })\n\n    db.commit()\n\n    return {\"marked_read\": updated_count}\n\n\n@router.get(\"/{notification_id}\", response_model=NotificationResponse)\nasync def get_notification(\n    notification_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get a specific notification by ID.\"\"\"\n    notification = db.query(Notification).filter(\n        and_(\n            Notification.id == notification_id,\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not notification:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Notification not found\"\n        )\n\n    return notification\n\n\n@router.patch(\"/{notification_id}\", response_model=NotificationResponse)\nasync def update_notification(\n    notification_id: UUID,\n    notification_data: NotificationUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Update a notification (mark as read/unread, archive/unarchive).\"\"\"\n    notification = db.query(Notification).filter(\n        and_(\n            Notification.id == notification_id,\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not notification:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Notification not found\"\n        )\n\n    update_data = notification_data.dict(exclude_unset=True)\n\n    # If marking as read, set read_at timestamp\n    if update_data.get(\"is_read\") == True and not notification.is_read:\n        notification.read_at = datetime.utcnow()\n\n    # If marking as unread, clear read_at\n    if update_data.get(\"is_read\") == False:\n        notification.read_at = None\n\n    for field, value in update_data.items():\n        setattr(notification, field, value)\n\n    notification.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(notification)\n\n    return notification\n\n\n@router.delete(\"/{notification_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_notification(\n    notification_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Soft delete a notification.\"\"\"\n    notification = db.query(Notification).filter(\n        and_(\n            Notification.id == notification_id,\n            Notification.user_id == current_user.id,\n            Notification.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not notification:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Notification not found\"\n        )\n\n    notification.deleted_at = datetime.utcnow()\n    db.commit()\n\n    return None\n"
  },
  "created_at": "2026-02-15T11:53:48.883349+00:00",
  "updated_at": "2026-02-15T11:53:48.883349+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:notifications.py"
}