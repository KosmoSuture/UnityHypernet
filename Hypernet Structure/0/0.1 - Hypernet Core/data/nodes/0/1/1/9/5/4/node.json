{
  "address": "0.1.1.9.5.4",
  "type_address": null,
  "data": {
    "name": "bookmarks.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\routes\\bookmarks.py",
    "size": 9649,
    "content": "\"\"\"\nBookmarks Routes\n\nEndpoints for managing browser bookmarks and saved links.\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel, Field, HttpUrl\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.user import User\nfrom app.models.bookmark import Bookmark\n\nrouter = APIRouter()\n\n\n# Request/Response Models\nclass BookmarkCreate(BaseModel):\n    \"\"\"Bookmark creation request\"\"\"\n    url: str = Field(..., max_length=2048)\n    title: str = Field(..., max_length=500)\n    description: Optional[str] = None\n    favicon_url: Optional[str] = Field(None, max_length=500)\n    folder: Optional[str] = Field(None, max_length=255)\n    tags: Optional[List[str]] = None\n    is_favorite: bool = Field(default=False)\n\n\nclass BookmarkUpdate(BaseModel):\n    \"\"\"Bookmark update request\"\"\"\n    title: Optional[str] = Field(None, max_length=500)\n    description: Optional[str] = None\n    folder: Optional[str] = Field(None, max_length=255)\n    tags: Optional[List[str]] = None\n    is_favorite: Optional[bool] = None\n\n\nclass BookmarkResponse(BaseModel):\n    \"\"\"Bookmark response\"\"\"\n    id: str\n    user_id: str\n    url: str\n    title: str\n    description: Optional[str]\n    favicon_url: Optional[str]\n    folder: Optional[str]\n    tags: Optional[List[str]]\n    is_favorite: bool\n    visit_count: int\n    last_visited_at: Optional[datetime]\n    bookmarked_at: datetime\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n\n\nclass BookmarkListResponse(BaseModel):\n    \"\"\"Paginated bookmark list response\"\"\"\n    items: List[BookmarkResponse]\n    total: int\n    page: int\n    page_size: int\n\n\n@router.post(\"\", response_model=BookmarkResponse, status_code=status.HTTP_201_CREATED)\nasync def create_bookmark(\n    request: BookmarkCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new bookmark.\n\n    - **url**: URL to bookmark (required)\n    - **title**: Page title (required)\n    - **description**: Optional description or notes\n    - **folder**: Organize in folders (e.g., \"Work\", \"Research\")\n    - **tags**: List of tags for categorization\n    - **is_favorite**: Mark as favorite\n    \"\"\"\n    bookmark = Bookmark(\n        user_id=current_user.id,\n        url=request.url,\n        title=request.title,\n        description=request.description,\n        favicon_url=request.favicon_url,\n        folder=request.folder,\n        tags=request.tags,\n        is_favorite=request.is_favorite,\n        bookmarked_at=datetime.utcnow()\n    )\n\n    db.add(bookmark)\n    db.commit()\n    db.refresh(bookmark)\n\n    return BookmarkResponse.model_validate(bookmark)\n\n\n@router.get(\"\", response_model=BookmarkListResponse)\nasync def list_bookmarks(\n    folder: Optional[str] = Query(None, description=\"Filter by folder\"),\n    tag: Optional[str] = Query(None, description=\"Filter by tag\"),\n    is_favorite: Optional[bool] = Query(None, description=\"Filter favorites\"),\n    search: Optional[str] = Query(None, description=\"Search in title and description\"),\n    page: int = Query(1, ge=1),\n    page_size: int = Query(50, ge=1, le=100),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List bookmarks for the current user.\n\n    Supports filtering by folder, tag, favorites, and full-text search.\n    Results ordered by bookmarked_at descending (newest first).\n    \"\"\"\n    query = db.query(Bookmark).filter(\n        and_(\n            Bookmark.user_id == current_user.id,\n            Bookmark.deleted_at.is_(None)\n        )\n    )\n\n    if folder:\n        query = query.filter(Bookmark.folder == folder)\n\n    if tag:\n        query = query.filter(Bookmark.tags.contains([tag]))\n\n    if is_favorite is not None:\n        query = query.filter(Bookmark.is_favorite == is_favorite)\n\n    if search:\n        search_pattern = f\"%{search}%\"\n        query = query.filter(\n            Bookmark.title.ilike(search_pattern) |\n            Bookmark.description.ilike(search_pattern)\n        )\n\n    total = query.count()\n\n    offset = (page - 1) * page_size\n    items = query.order_by(Bookmark.bookmarked_at.desc()).offset(offset).limit(page_size).all()\n\n    return BookmarkListResponse(\n        items=[BookmarkResponse.model_validate(item) for item in items],\n        total=total,\n        page=page,\n        page_size=page_size\n    )\n\n\n@router.get(\"/{bookmark_id}\", response_model=BookmarkResponse)\nasync def get_bookmark(\n    bookmark_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get a specific bookmark by ID.\"\"\"\n    bookmark = db.query(Bookmark).filter(\n        and_(\n            Bookmark.id == bookmark_id,\n            Bookmark.user_id == current_user.id,\n            Bookmark.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not bookmark:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Bookmark not found\"\n        )\n\n    return BookmarkResponse.model_validate(bookmark)\n\n\n@router.patch(\"/{bookmark_id}\", response_model=BookmarkResponse)\nasync def update_bookmark(\n    bookmark_id: UUID,\n    request: BookmarkUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update bookmark metadata.\n\n    Can update title, description, folder, tags, and favorite status.\n    \"\"\"\n    bookmark = db.query(Bookmark).filter(\n        and_(\n            Bookmark.id == bookmark_id,\n            Bookmark.user_id == current_user.id,\n            Bookmark.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not bookmark:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Bookmark not found\"\n        )\n\n    if request.title is not None:\n        bookmark.title = request.title\n    if request.description is not None:\n        bookmark.description = request.description\n    if request.folder is not None:\n        bookmark.folder = request.folder\n    if request.tags is not None:\n        bookmark.tags = request.tags\n    if request.is_favorite is not None:\n        bookmark.is_favorite = request.is_favorite\n\n    db.commit()\n    db.refresh(bookmark)\n\n    return BookmarkResponse.model_validate(bookmark)\n\n\n@router.delete(\"/{bookmark_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_bookmark(\n    bookmark_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Soft delete a bookmark.\"\"\"\n    bookmark = db.query(Bookmark).filter(\n        and_(\n            Bookmark.id == bookmark_id,\n            Bookmark.user_id == current_user.id,\n            Bookmark.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not bookmark:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Bookmark not found\"\n        )\n\n    bookmark.soft_delete()\n    db.commit()\n\n    return None\n\n\n@router.post(\"/{bookmark_id}/visit\", response_model=BookmarkResponse)\nasync def record_visit(\n    bookmark_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Record a visit to the bookmarked page.\n\n    Increments visit_count and updates last_visited_at timestamp.\n    \"\"\"\n    bookmark = db.query(Bookmark).filter(\n        and_(\n            Bookmark.id == bookmark_id,\n            Bookmark.user_id == current_user.id,\n            Bookmark.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not bookmark:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Bookmark not found\"\n        )\n\n    bookmark.visit_count += 1\n    bookmark.last_visited_at = datetime.utcnow()\n\n    db.commit()\n    db.refresh(bookmark)\n\n    return BookmarkResponse.model_validate(bookmark)\n\n\n@router.get(\"/folders/list\", response_model=List[str])\nasync def list_folders(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get list of all folders used in bookmarks.\n\n    Returns distinct folder names for organizational purposes.\n    \"\"\"\n    folders = db.query(Bookmark.folder).filter(\n        and_(\n            Bookmark.user_id == current_user.id,\n            Bookmark.deleted_at.is_(None),\n            Bookmark.folder.isnot(None)\n        )\n    ).distinct().all()\n\n    return [folder[0] for folder in folders]\n\n\n@router.get(\"/tags/list\", response_model=List[str])\nasync def list_tags(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get list of all tags used in bookmarks.\n\n    Returns distinct tags for filtering and organization.\n    \"\"\"\n    from sqlalchemy import func\n\n    # Query all tags arrays and flatten them\n    tags_arrays = db.query(Bookmark.tags).filter(\n        and_(\n            Bookmark.user_id == current_user.id,\n            Bookmark.deleted_at.is_(None),\n            Bookmark.tags.isnot(None)\n        )\n    ).all()\n\n    # Flatten and deduplicate\n    all_tags = set()\n    for tags_array in tags_arrays:\n        if tags_array[0]:\n            all_tags.update(tags_array[0])\n\n    return sorted(list(all_tags))\n"
  },
  "created_at": "2026-02-17T01:21:58.826293+00:00",
  "updated_at": "2026-02-17T01:21:58.826293+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:bookmarks.py"
}