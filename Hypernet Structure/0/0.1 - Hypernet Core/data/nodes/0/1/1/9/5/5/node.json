{
  "address": "0.1.1.9.5.5",
  "type_address": null,
  "data": {
    "name": "calendar_events.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\routes\\calendar_events.py",
    "size": 8659,
    "content": "\"\"\"\nCalendar Events Routes\n\nEndpoints for managing calendar events and appointments.\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.user import User\nfrom app.models.calendar_event import CalendarEvent\n\nrouter = APIRouter()\n\n\n# Request/Response Models\nclass CalendarEventCreate(BaseModel):\n    \"\"\"Calendar event creation request\"\"\"\n    title: str = Field(..., max_length=500)\n    starts_at: datetime\n    ends_at: Optional[datetime] = None\n    event_type: str = Field(default='event', description=\"event, meeting, appointment, reminder\")\n    description: Optional[str] = None\n    location: Optional[str] = Field(None, max_length=500)\n    meeting_url: Optional[str] = Field(None, max_length=500)\n    is_all_day: bool = Field(default=False)\n    is_recurring: bool = Field(default=False)\n    recurrence_rule: Optional[str] = Field(None, max_length=500)\n    attendees: Optional[List[str]] = None\n\n\nclass CalendarEventUpdate(BaseModel):\n    \"\"\"Calendar event update request\"\"\"\n    title: Optional[str] = Field(None, max_length=500)\n    starts_at: Optional[datetime] = None\n    ends_at: Optional[datetime] = None\n    event_type: Optional[str] = None\n    description: Optional[str] = None\n    location: Optional[str] = Field(None, max_length=500)\n    meeting_url: Optional[str] = Field(None, max_length=500)\n    is_all_day: Optional[bool] = None\n    is_recurring: Optional[bool] = None\n    recurrence_rule: Optional[str] = Field(None, max_length=500)\n    attendees: Optional[List[str]] = None\n\n\nclass CalendarEventResponse(BaseModel):\n    \"\"\"Calendar event response\"\"\"\n    id: str\n    user_id: str\n    title: str\n    starts_at: datetime\n    ends_at: Optional[datetime]\n    event_type: str\n    description: Optional[str]\n    location: Optional[str]\n    meeting_url: Optional[str]\n    is_all_day: bool\n    is_recurring: bool\n    recurrence_rule: Optional[str]\n    attendees: Optional[List[str]]\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True\n\n\nclass CalendarEventListResponse(BaseModel):\n    \"\"\"Paginated calendar event list response\"\"\"\n    items: List[CalendarEventResponse]\n    total: int\n    page: int\n    page_size: int\n\n\n@router.post(\"\", response_model=CalendarEventResponse, status_code=status.HTTP_201_CREATED)\nasync def create_calendar_event(\n    request: CalendarEventCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new calendar event.\n\n    - **title**: Event title (required)\n    - **starts_at**: Event start time (required)\n    - **ends_at**: Event end time\n    - **event_type**: event, meeting, appointment, reminder\n    - **location**: Physical location or address\n    - **meeting_url**: Video meeting URL (Zoom, Teams, etc.)\n    \"\"\"\n    event = CalendarEvent(\n        user_id=current_user.id,\n        title=request.title,\n        starts_at=request.starts_at,\n        ends_at=request.ends_at,\n        event_type=request.event_type,\n        description=request.description,\n        location=request.location,\n        meeting_url=request.meeting_url,\n        is_all_day=request.is_all_day,\n        is_recurring=request.is_recurring,\n        recurrence_rule=request.recurrence_rule,\n        attendees=request.attendees\n    )\n\n    db.add(event)\n    db.commit()\n    db.refresh(event)\n\n    return CalendarEventResponse.model_validate(event)\n\n\n@router.get(\"\", response_model=CalendarEventListResponse)\nasync def list_calendar_events(\n    start_date: Optional[datetime] = Query(None, description=\"Filter events starting after this date\"),\n    end_date: Optional[datetime] = Query(None, description=\"Filter events ending before this date\"),\n    event_type: Optional[str] = Query(None, description=\"Filter by event type\"),\n    page: int = Query(1, ge=1),\n    page_size: int = Query(50, ge=1, le=100),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List calendar events for the current user.\n\n    Supports:\n    - Filter by date range (start_date, end_date)\n    - Filter by event_type\n    - Pagination\n\n    Results ordered by starts_at ascending (soonest first).\n    \"\"\"\n    query = db.query(CalendarEvent).filter(\n        and_(\n            CalendarEvent.user_id == current_user.id,\n            CalendarEvent.deleted_at.is_(None)\n        )\n    )\n\n    if start_date:\n        query = query.filter(CalendarEvent.starts_at >= start_date)\n\n    if end_date:\n        query = query.filter(CalendarEvent.starts_at <= end_date)\n\n    if event_type:\n        query = query.filter(CalendarEvent.event_type == event_type)\n\n    total = query.count()\n\n    offset = (page - 1) * page_size\n    items = query.order_by(CalendarEvent.starts_at.asc()).offset(offset).limit(page_size).all()\n\n    return CalendarEventListResponse(\n        items=[CalendarEventResponse.model_validate(item) for item in items],\n        total=total,\n        page=page,\n        page_size=page_size\n    )\n\n\n@router.get(\"/{event_id}\", response_model=CalendarEventResponse)\nasync def get_calendar_event(\n    event_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get a specific calendar event by ID.\"\"\"\n    event = db.query(CalendarEvent).filter(\n        and_(\n            CalendarEvent.id == event_id,\n            CalendarEvent.user_id == current_user.id,\n            CalendarEvent.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not event:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Calendar event not found\"\n        )\n\n    return CalendarEventResponse.model_validate(event)\n\n\n@router.patch(\"/{event_id}\", response_model=CalendarEventResponse)\nasync def update_calendar_event(\n    event_id: UUID,\n    request: CalendarEventUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a calendar event.\n\n    All fields are optional. Only provided fields will be updated.\n    \"\"\"\n    event = db.query(CalendarEvent).filter(\n        and_(\n            CalendarEvent.id == event_id,\n            CalendarEvent.user_id == current_user.id,\n            CalendarEvent.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not event:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Calendar event not found\"\n        )\n\n    if request.title is not None:\n        event.title = request.title\n    if request.starts_at is not None:\n        event.starts_at = request.starts_at\n    if request.ends_at is not None:\n        event.ends_at = request.ends_at\n    if request.event_type is not None:\n        event.event_type = request.event_type\n    if request.description is not None:\n        event.description = request.description\n    if request.location is not None:\n        event.location = request.location\n    if request.meeting_url is not None:\n        event.meeting_url = request.meeting_url\n    if request.is_all_day is not None:\n        event.is_all_day = request.is_all_day\n    if request.is_recurring is not None:\n        event.is_recurring = request.is_recurring\n    if request.recurrence_rule is not None:\n        event.recurrence_rule = request.recurrence_rule\n    if request.attendees is not None:\n        event.attendees = request.attendees\n\n    db.commit()\n    db.refresh(event)\n\n    return CalendarEventResponse.model_validate(event)\n\n\n@router.delete(\"/{event_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_calendar_event(\n    event_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Soft delete a calendar event.\"\"\"\n    event = db.query(CalendarEvent).filter(\n        and_(\n            CalendarEvent.id == event_id,\n            CalendarEvent.user_id == current_user.id,\n            CalendarEvent.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not event:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Calendar event not found\"\n        )\n\n    event.soft_delete()\n    db.commit()\n\n    return None\n"
  },
  "created_at": "2026-02-17T01:21:58.846294+00:00",
  "updated_at": "2026-02-17T01:21:58.846294+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:calendar_events.py"
}