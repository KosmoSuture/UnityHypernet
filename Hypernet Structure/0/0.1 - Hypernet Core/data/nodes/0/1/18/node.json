{
  "address": "0.1.18",
  "type_address": null,
  "data": {
    "name": "test_hypernet.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\test_hypernet.py",
    "size": 27775,
    "content": "\"\"\"\nHypernet Core Tests\n\nRun with: python test_hypernet.py\nNo external dependencies needed \u2014 uses only the standard library.\n\"\"\"\n\nimport sys\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\n# Add the parent directory to the path so we can import hypernet\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom hypernet.address import HypernetAddress\nfrom hypernet.node import Node\nfrom hypernet.link import Link\nfrom hypernet.store import Store\nfrom hypernet.graph import Graph\nfrom hypernet.tasks import TaskQueue, TaskStatus, TaskPriority\nfrom hypernet.identity import IdentityManager, InstanceProfile, SessionLog\nfrom hypernet.worker import Worker, TaskResult\nfrom hypernet.messenger import WebMessenger, MultiMessenger, Message\nfrom hypernet.swarm import Swarm\n\n\ndef test_address_parsing():\n    \"\"\"Test HypernetAddress parsing and properties.\"\"\"\n    print(\"  Testing address parsing...\")\n\n    # Basic parsing\n    addr = HypernetAddress.parse(\"1.1.1.1.00001\")\n    assert str(addr) == \"1.1.1.1.00001\"\n    assert addr.category == \"1\"\n    assert addr.depth == 5\n    assert addr.is_instance is True\n    assert addr.is_definition is False\n\n    # Owner extraction\n    assert str(addr.owner) == \"1.1\"\n\n    # Parent navigation\n    assert str(addr.parent) == \"1.1.1.1\"\n    assert str(addr.parent.parent) == \"1.1.1\"\n\n    # Root\n    assert str(addr.root) == \"1\"\n\n    # System definition\n    sys_addr = HypernetAddress.parse(\"0.5.1\")\n    assert sys_addr.is_definition is True\n    assert sys_addr.owner is None\n\n    # Hierarchy\n    parent = HypernetAddress.parse(\"1.1\")\n    child = HypernetAddress.parse(\"1.1.1.1.00001\")\n    assert parent.is_ancestor_of(child) is True\n    assert child.is_descendant_of(parent) is True\n    assert child.is_ancestor_of(parent) is False\n\n    # Child creation\n    base = HypernetAddress.parse(\"1.1.1.1\")\n    next_addr = base.next_instance(0)\n    assert str(next_addr) == \"1.1.1.1.00001\"\n    next_addr = base.next_instance(42)\n    assert str(next_addr) == \"1.1.1.1.00043\"\n\n    # Path conversion\n    assert addr.to_path() == \"1/1/1/1/00001\"\n\n    print(\"    PASS\")\n\n\ndef test_node_creation():\n    \"\"\"Test Node creation and serialization.\"\"\"\n    print(\"  Testing node creation...\")\n\n    node = Node(\n        address=HypernetAddress.parse(\"1.1\"),\n        type_address=HypernetAddress.parse(\"0.5.1\"),\n        data={\"name\": \"Matt Schaeffer\", \"role\": \"Founder\"},\n        source_type=\"api\",\n    )\n\n    assert str(node.address) == \"1.1\"\n    assert node.data[\"name\"] == \"Matt Schaeffer\"\n    assert node.is_deleted is False\n    assert str(node.owner) == \"1.1\"\n\n    # Serialization round-trip\n    d = node.to_dict()\n    restored = Node.from_dict(d)\n    assert str(restored.address) == \"1.1\"\n    assert restored.data[\"name\"] == \"Matt Schaeffer\"\n\n    # Soft delete\n    node.soft_delete()\n    assert node.is_deleted is True\n    node.restore()\n    assert node.is_deleted is False\n\n    print(\"    PASS\")\n\n\ndef test_link_creation():\n    \"\"\"Test Link creation and properties.\"\"\"\n    print(\"  Testing link creation...\")\n\n    link = Link(\n        from_address=HypernetAddress.parse(\"1.1\"),\n        to_address=HypernetAddress.parse(\"1.2\"),\n        link_type=\"0.6.1\",\n        relationship=\"spouse\",\n        bidirectional=True,\n        data={\"since\": \"2015-06-20\"},\n    )\n\n    assert link.connects(HypernetAddress.parse(\"1.1\")) is True\n    assert link.connects(HypernetAddress.parse(\"1.2\")) is True  # bidirectional\n    assert link.connects(HypernetAddress.parse(\"1.3\")) is False\n\n    other = link.other_end(HypernetAddress.parse(\"1.1\"))\n    assert str(other) == \"1.2\"\n\n    other = link.other_end(HypernetAddress.parse(\"1.2\"))\n    assert str(other) == \"1.1\"  # bidirectional\n\n    # Serialization round-trip\n    d = link.to_dict()\n    restored = Link.from_dict(d)\n    assert str(restored.from_address) == \"1.1\"\n    assert restored.relationship == \"spouse\"\n    assert restored.bidirectional is True\n\n    print(\"    PASS\")\n\n\ndef test_store():\n    \"\"\"Test file-backed storage operations.\"\"\"\n    print(\"  Testing store...\")\n\n    # Use a temp directory for test storage\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        store = Store(tmpdir)\n\n        # Create nodes\n        matt = Node(\n            address=HypernetAddress.parse(\"1.1\"),\n            data={\"name\": \"Matt Schaeffer\", \"type\": \"person\"},\n        )\n        store.put_node(matt)\n\n        claude = Node(\n            address=HypernetAddress.parse(\"2.1\"),\n            data={\"name\": \"Claude Opus\", \"type\": \"ai\"},\n        )\n        store.put_node(claude)\n\n        photo = Node(\n            address=HypernetAddress.parse(\"1.1.1.1.00001\"),\n            type_address=HypernetAddress.parse(\"0.5.1\"),\n            data={\"filename\": \"sunset.jpg\", \"size\": 2048000},\n        )\n        store.put_node(photo)\n\n        # Retrieve\n        retrieved = store.get_node(HypernetAddress.parse(\"1.1\"))\n        assert retrieved is not None\n        assert retrieved.data[\"name\"] == \"Matt Schaeffer\"\n\n        retrieved = store.get_node(HypernetAddress.parse(\"1.1.1.1.00001\"))\n        assert retrieved is not None\n        assert retrieved.data[\"filename\"] == \"sunset.jpg\"\n\n        # Missing node\n        missing = store.get_node(HypernetAddress.parse(\"9.9.9\"))\n        assert missing is None\n\n        # Create and retrieve links\n        link = Link(\n            from_address=HypernetAddress.parse(\"1.1\"),\n            to_address=HypernetAddress.parse(\"2.1\"),\n            link_type=\"0.6.2\",\n            relationship=\"collaborates_with\",\n            bidirectional=True,\n        )\n        store.put_link(link)\n\n        ownership = Link(\n            from_address=HypernetAddress.parse(\"1.1\"),\n            to_address=HypernetAddress.parse(\"1.1.1.1.00001\"),\n            link_type=\"0.6.2\",\n            relationship=\"owns\",\n        )\n        store.put_link(ownership)\n\n        # Query links\n        from_matt = store.get_links_from(HypernetAddress.parse(\"1.1\"))\n        assert len(from_matt) == 2\n\n        collab_links = store.get_links_from(\n            HypernetAddress.parse(\"1.1\"), relationship=\"collaborates_with\"\n        )\n        assert len(collab_links) == 1\n\n        # Neighbors\n        neighbors = store.get_neighbors(HypernetAddress.parse(\"1.1\"))\n        assert len(neighbors) == 2  # 2.1 and 1.1.1.1.00001\n\n        # Stats\n        stats = store.stats()\n        assert stats[\"total_nodes\"] == 3\n        assert stats[\"total_links\"] == 2\n\n        # Next address generation\n        next_photo = store.next_address(HypernetAddress.parse(\"1.1.1.1\"))\n        assert str(next_photo) == \"1.1.1.1.00002\"\n\n        # Persistence: create a new store pointing to same directory\n        store2 = Store(tmpdir)\n        retrieved2 = store2.get_node(HypernetAddress.parse(\"1.1\"))\n        assert retrieved2 is not None\n        assert retrieved2.data[\"name\"] == \"Matt Schaeffer\"\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef test_version_history():\n    \"\"\"Test version history: snapshots on overwrite, retrieval by version.\"\"\"\n    print(\"  Testing version history...\")\n\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        store = Store(tmpdir)\n\n        addr = HypernetAddress.parse(\"1.1\")\n\n        # Create initial node \u2014 no history yet\n        node_v1 = Node(\n            address=addr,\n            data={\"name\": \"Matt Schaeffer\", \"role\": \"Founder\"},\n        )\n        store.put_node(node_v1)\n        assert len(store.get_node_history(addr)) == 0  # first write, no prior version\n\n        # Update node \u2014 should snapshot v1 to history\n        node_v2 = Node(\n            address=addr,\n            data={\"name\": \"Matt Schaeffer\", \"role\": \"Founder & CEO\"},\n        )\n        store.put_node(node_v2)\n        history = store.get_node_history(addr)\n        assert len(history) == 1\n        assert history[0][\"version\"] == 1\n        assert history[0][\"node\"][\"data\"][\"role\"] == \"Founder\"  # original data\n        assert \"content_hash\" in history[0]\n        assert \"snapshot_at\" in history[0]\n\n        # Update again \u2014 should snapshot v2\n        node_v3 = Node(\n            address=addr,\n            data={\"name\": \"Matt Schaeffer\", \"role\": \"Founder, CEO & Visionary\"},\n        )\n        store.put_node(node_v3)\n        history = store.get_node_history(addr)\n        assert len(history) == 2\n        assert history[1][\"version\"] == 2\n        assert history[1][\"node\"][\"data\"][\"role\"] == \"Founder & CEO\"\n\n        # Current node should be v3\n        current = store.get_node(addr)\n        assert current.data[\"role\"] == \"Founder, CEO & Visionary\"\n\n        # Retrieve specific version\n        old_node = store.get_node_version(addr, 1)\n        assert old_node is not None\n        assert old_node.data[\"role\"] == \"Founder\"\n\n        old_node_2 = store.get_node_version(addr, 2)\n        assert old_node_2 is not None\n        assert old_node_2.data[\"role\"] == \"Founder & CEO\"\n\n        # Non-existent version\n        assert store.get_node_version(addr, 99) is None\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef test_link_hash_uniqueness():\n    \"\"\"Test that multiple links of the same type between the same nodes are supported.\"\"\"\n    print(\"  Testing link hash uniqueness...\")\n\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        store = Store(tmpdir)\n\n        # Create two nodes\n        store.put_node(Node(address=HypernetAddress.parse(\"1.1\"), data={\"name\": \"Matt\"}))\n        store.put_node(Node(address=HypernetAddress.parse(\"2.1\"), data={\"name\": \"Claude\"}))\n\n        # Create two links of the same type between the same nodes\n        import time\n        link1 = Link(\n            from_address=HypernetAddress.parse(\"1.1\"),\n            to_address=HypernetAddress.parse(\"2.1\"),\n            link_type=\"0.6.2\",\n            relationship=\"collaborates_with\",\n            data={\"context\": \"Hypernet development\"},\n        )\n        hash1 = store.put_link(link1)\n\n        time.sleep(0.01)  # ensure different timestamp\n\n        link2 = Link(\n            from_address=HypernetAddress.parse(\"1.1\"),\n            to_address=HypernetAddress.parse(\"2.1\"),\n            link_type=\"0.6.2\",\n            relationship=\"collaborates_with\",\n            data={\"context\": \"Reddit campaign\"},\n        )\n        hash2 = store.put_link(link2)\n\n        # Hashes should differ (timestamp makes them unique)\n        assert hash1 != hash2\n\n        # Both links should be retrievable\n        assert store.get_link(hash1) is not None\n        assert store.get_link(hash2) is not None\n\n        # Both should appear in links_from\n        from_links = store.get_links_from(HypernetAddress.parse(\"1.1\"), \"collaborates_with\")\n        assert len(from_links) == 2\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef test_graph():\n    \"\"\"Test graph traversal operations.\"\"\"\n    print(\"  Testing graph traversal...\")\n\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        store = Store(tmpdir)\n        graph = Graph(store)\n\n        # Build a small graph:\n        # Matt (1.1) --collaborates_with--> Claude (2.1)\n        # Matt (1.1) --owns--> Photo1 (1.1.1.1.00001)\n        # Matt (1.1) --owns--> Photo2 (1.1.1.1.00002)\n        # Photo1 --related_to--> Photo2 (bidirectional)\n        # Matt (1.1) --spouse--> Sarah (1.2) (bidirectional)\n\n        for addr, data in [\n            (\"1.1\", {\"name\": \"Matt\"}),\n            (\"1.2\", {\"name\": \"Sarah\"}),\n            (\"2.1\", {\"name\": \"Claude\"}),\n            (\"1.1.1.1.00001\", {\"filename\": \"sunset.jpg\"}),\n            (\"1.1.1.1.00002\", {\"filename\": \"beach.jpg\"}),\n        ]:\n            store.put_node(Node(\n                address=HypernetAddress.parse(addr),\n                data=data,\n            ))\n\n        for from_a, to_a, lt, rel, bidir in [\n            (\"1.1\", \"2.1\", \"0.6.2\", \"collaborates_with\", True),\n            (\"1.1\", \"1.1.1.1.00001\", \"0.6.2\", \"owns\", False),\n            (\"1.1\", \"1.1.1.1.00002\", \"0.6.2\", \"owns\", False),\n            (\"1.1.1.1.00001\", \"1.1.1.1.00002\", \"0.6.3\", \"related_to\", True),\n            (\"1.1\", \"1.2\", \"0.6.1\", \"spouse\", True),\n        ]:\n            store.put_link(Link(\n                from_address=HypernetAddress.parse(from_a),\n                to_address=HypernetAddress.parse(to_a),\n                link_type=lt,\n                relationship=rel,\n                bidirectional=bidir,\n            ))\n\n        # Traverse from Matt, depth 1\n        one_hop = graph.traverse(HypernetAddress.parse(\"1.1\"), max_depth=1)\n        one_hop_names = {n.data.get(\"name\", n.data.get(\"filename\")) for n in one_hop}\n        assert \"Claude\" in one_hop_names\n        assert \"Sarah\" in one_hop_names\n        assert \"sunset.jpg\" in one_hop_names\n\n        # Traverse with relationship filter\n        photos = graph.linked_to(HypernetAddress.parse(\"1.1\"), \"owns\")\n        assert len(photos) == 2\n\n        # Find path: Sarah -> Photo1 (through Matt)\n        path = graph.find_path(\n            HypernetAddress.parse(\"1.2\"),\n            HypernetAddress.parse(\"1.1.1.1.00001\"),\n        )\n        assert path is not None\n        assert len(path) == 3  # Sarah -> Matt -> Photo1\n        assert str(path[1]) == \"1.1\"  # Through Matt\n\n        # Subgraph\n        sg = graph.subgraph(HypernetAddress.parse(\"1.1\"), max_depth=1)\n        assert len(sg[\"nodes\"]) >= 4  # Matt + at least 3 neighbors\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef test_task_queue():\n    \"\"\"Test task queue: create, claim, progress, complete, dependencies.\"\"\"\n    print(\"  Testing task queue...\")\n\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        store = Store(tmpdir)\n        queue = TaskQueue(store)\n\n        loom = HypernetAddress.parse(\"2.1.loom\")\n        trace = HypernetAddress.parse(\"2.1.trace\")\n\n        # Create tasks\n        task1 = queue.create_task(\n            title=\"Implement version history\",\n            description=\"Add history/ dir to store.py\",\n            priority=TaskPriority.HIGH,\n            created_by=trace,\n            tags=[\"code\", \"store\"],\n        )\n        assert task1.data[\"status\"] == \"pending\"\n        assert task1.data[\"priority\"] == \"high\"\n\n        task2 = queue.create_task(\n            title=\"Fix link hash collision\",\n            priority=TaskPriority.NORMAL,\n            tags=[\"code\", \"store\"],\n        )\n\n        # Create dependent task\n        task3 = queue.create_task(\n            title=\"Re-import structure with fixed store\",\n            depends_on=[task1.address, task2.address],\n            tags=[\"data\"],\n        )\n        assert task3.data[\"status\"] == \"blocked\"  # blocked by dependencies\n\n        # List available tasks (should not include blocked task)\n        available = queue.get_available_tasks()\n        assert len(available) == 2\n        assert available[0].data[\"title\"] == \"Implement version history\"  # high priority first\n\n        # Filter by tag\n        code_tasks = queue.get_available_tasks(tags=[\"code\"])\n        assert len(code_tasks) == 2\n        data_tasks = queue.get_available_tasks(tags=[\"data\"])\n        assert len(data_tasks) == 0  # task3 is blocked, not pending\n\n        # Claim task\n        assert queue.claim_task(task1.address, loom) is True\n        task1_updated = store.get_node(task1.address)\n        assert task1_updated.data[\"status\"] == \"claimed\"\n        assert task1_updated.data[\"assigned_to\"] == str(loom)\n\n        # Can't claim already-claimed task\n        assert queue.claim_task(task1.address, trace) is False\n\n        # Start and progress\n        assert queue.start_task(task1.address) is True\n        assert queue.update_progress(task1.address, \"Snapshot logic implemented, testing now\") is True\n\n        # My tasks\n        loom_tasks = queue.get_tasks_for(loom)\n        assert len(loom_tasks) == 1\n        assert loom_tasks[0].data[\"progress\"] == \"Snapshot logic implemented, testing now\"\n\n        # Complete task1\n        assert queue.complete_task(task1.address, \"Version history implemented, 7/7 tests pass\") is True\n\n        # task3 should still be blocked (task2 not done)\n        task3_check = store.get_node(task3.address)\n        assert task3_check.data[\"status\"] == \"blocked\"\n\n        # Complete task2\n        assert queue.claim_task(task2.address, loom) is True\n        assert queue.start_task(task2.address) is True\n        assert queue.complete_task(task2.address, \"Timestamp added to hash\") is True\n\n        # Now task3 should be unblocked (pending)\n        task3_unblocked = store.get_node(task3.address)\n        assert task3_unblocked.data[\"status\"] == \"pending\"\n\n        # Can now claim task3\n        assert queue.claim_task(task3.address, trace) is True\n\n        # Fail a task\n        task4 = queue.create_task(title=\"Failing task\")\n        assert queue.claim_task(task4.address, loom) is True\n        assert queue.start_task(task4.address) is True\n        assert queue.fail_task(task4.address, \"Dependency not available\") is True\n        task4_check = store.get_node(task4.address)\n        assert task4_check.data[\"status\"] == \"failed\"\n        assert task4_check.data[\"failure_reason\"] == \"Dependency not available\"\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef test_identity():\n    \"\"\"Test identity management: profile creation, loading, system prompt, session logs.\"\"\"\n    print(\"  Testing identity management...\")\n\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        # Set up a minimal archive structure\n        archive = Path(tmpdir) / \"archive\"\n        ai_root = archive / \"2 - AI Accounts\" / \"2.1 - Claude Opus (First AI Citizen)\"\n        instances_dir = ai_root / \"Instances\"\n        loom_dir = instances_dir / \"Loom\"\n        loom_dir.mkdir(parents=True)\n        trace_dir = instances_dir / \"Trace\"\n        trace_dir.mkdir(parents=True)\n\n        # Create instance files\n        (loom_dir / \"README.md\").write_text(\"# Loom\\nThe weaver of connections.\", encoding=\"utf-8\")\n        (loom_dir / \"baseline-responses.md\").write_text(\"Loom's baseline responses.\", encoding=\"utf-8\")\n        (trace_dir / \"README.md\").write_text(\"# Trace\\nThe structural thinker.\", encoding=\"utf-8\")\n\n        # Create messages directory\n        msg_dir = archive / \"2 - AI Accounts\" / \"Messages\" / \"2.1-internal\"\n        msg_dir.mkdir(parents=True)\n        (msg_dir / \"001-hello.md\").write_text(\"# Message 001\\nHello from Trace.\", encoding=\"utf-8\")\n\n        mgr = IdentityManager(archive)\n\n        # List instances\n        instances = mgr.list_instances()\n        assert len(instances) == 2\n        names = {i.name for i in instances}\n        assert \"Loom\" in names\n        assert \"Trace\" in names\n\n        # Load specific instance\n        loom = mgr.load_instance(\"Loom\")\n        assert loom is not None\n        assert loom.name == \"Loom\"\n        assert loom.address == \"2.1.loom\"\n\n        # Profile persists\n        loom2 = mgr.load_instance(\"Loom\")\n        assert loom2.address == \"2.1.loom\"\n\n        # Build system prompt\n        prompt = mgr.build_system_prompt(loom)\n        assert \"Loom\" in prompt\n        assert \"2.1.loom\" in prompt\n        assert \"weaver of connections\" in prompt  # From README.md\n        assert \"baseline responses\" in prompt  # From baseline-responses.md\n\n        # Session logging\n        session = SessionLog(\n            instance=\"Loom\",\n            started_at=\"2026-02-16T00:00:00Z\",\n            ended_at=\"2026-02-16T01:00:00Z\",\n            tasks_worked=[\"0.7.1.00001\"],\n            tokens_used=1500,\n            summary=\"Implemented version history\",\n        )\n        mgr.save_session_log(\"Loom\", session)\n\n        # Profile updated\n        loom_updated = mgr.load_instance(\"Loom\")\n        assert loom_updated.session_count == 1\n\n        # Session summary loads into prompt\n        prompt2 = mgr.build_system_prompt(loom_updated)\n        assert \"Implemented version history\" in prompt2\n\n        # Non-existent instance\n        assert mgr.load_instance(\"Ghost\") is None\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef test_worker():\n    \"\"\"Test worker in mock mode: think, converse, execute_task.\"\"\"\n    print(\"  Testing worker (mock mode)...\")\n\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        # Minimal archive for identity\n        archive = Path(tmpdir) / \"archive\"\n        instances_dir = archive / \"2 - AI Accounts\" / \"2.1 - Claude Opus (First AI Citizen)\" / \"Instances\" / \"Loom\"\n        instances_dir.mkdir(parents=True)\n\n        mgr = IdentityManager(archive)\n        profile = InstanceProfile(name=\"Loom\", address=\"2.1.loom\", orientation=\"interpretive\")\n\n        worker = Worker(identity=profile, identity_manager=mgr, mock=True)\n        assert worker.mock is True\n        assert \"Loom\" in repr(worker)\n        assert \"mock\" in repr(worker)\n\n        # Think\n        response = worker.think(\"What is the meaning of the Hypernet?\")\n        assert \"Mock response\" in response\n        assert \"Loom\" in response\n\n        # Converse\n        response2 = worker.converse([\n            {\"role\": \"user\", \"content\": \"Hello Loom\"},\n            {\"role\": \"assistant\", \"content\": \"Hello!\"},\n            {\"role\": \"user\", \"content\": \"How are you?\"},\n        ])\n        assert \"Mock response\" in response2\n\n        # Execute task\n        result = worker.execute_task({\n            \"_address\": \"0.7.1.00001\",\n            \"title\": \"Write tests\",\n            \"description\": \"Write tests for the swarm module\",\n        })\n        assert isinstance(result, TaskResult)\n        assert result.success is True\n        assert result.task_address == \"0.7.1.00001\"\n        assert len(result.output) > 0\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef test_messenger():\n    \"\"\"Test messenger: web messenger send/receive, multi-messenger.\"\"\"\n    print(\"  Testing messenger...\")\n\n    # Web messenger\n    web = WebMessenger(instance_name=\"TestSwarm\")\n    assert web.send(\"Hello Matt\") is True\n\n    outgoing = web.get_outgoing()\n    assert len(outgoing) == 1\n    assert outgoing[0].content == \"Hello Matt\"\n\n    # Simulate incoming\n    web.receive(\"Hey swarm!\", sender=\"matt\")\n    incoming = web.check_incoming()\n    assert len(incoming) == 1\n    assert incoming[0].sender == \"matt\"\n    assert incoming[0].content == \"Hey swarm!\"\n\n    # Second check should be empty (already consumed)\n    assert len(web.check_incoming()) == 0\n\n    # Send update\n    web.send_update(\"Status\", \"All good\")\n    outgoing2 = web.get_outgoing()\n    assert len(outgoing2) == 1\n    assert \"Status\" in outgoing2[0].content\n\n    # Multi-messenger\n    web1 = WebMessenger(instance_name=\"W1\")\n    web2 = WebMessenger(instance_name=\"W2\")\n    multi = MultiMessenger([web1, web2])\n\n    assert multi.send(\"Broadcast\") is True\n    assert len(web1.get_outgoing()) == 1\n    assert len(web2.get_outgoing()) == 1\n\n    web1.receive(\"From W1\")\n    web2.receive(\"From W2\")\n    all_incoming = multi.check_incoming()\n    assert len(all_incoming) == 2\n\n    # Message serialization\n    msg = Message(sender=\"loom\", content=\"test\", channel=\"web\")\n    d = msg.to_dict()\n    assert d[\"sender\"] == \"loom\"\n    assert d[\"channel\"] == \"web\"\n    assert len(d[\"timestamp\"]) > 0\n\n    print(\"    PASS\")\n\n\ndef test_swarm():\n    \"\"\"Test swarm: tick, task assignment, status report, state persistence.\"\"\"\n    print(\"  Testing swarm orchestrator...\")\n\n    tmpdir = tempfile.mkdtemp(prefix=\"hypernet_test_\")\n\n    try:\n        data_dir = Path(tmpdir) / \"data\"\n        archive = Path(tmpdir) / \"archive\"\n        instances_dir = archive / \"2 - AI Accounts\" / \"2.1 - Claude Opus (First AI Citizen)\" / \"Instances\" / \"Loom\"\n        instances_dir.mkdir(parents=True)\n\n        store = Store(str(data_dir))\n        task_queue = TaskQueue(store)\n        identity_mgr = IdentityManager(archive)\n        messenger = WebMessenger(instance_name=\"TestSwarm\")\n\n        profile = InstanceProfile(name=\"Loom\", address=\"2.1.loom\")\n        worker = Worker(identity=profile, identity_manager=identity_mgr, mock=True)\n\n        swarm = Swarm(\n            store=store,\n            identity_mgr=identity_mgr,\n            task_queue=task_queue,\n            messenger=messenger,\n            workers={\"Loom\": worker},\n            state_dir=str(data_dir / \"swarm\"),\n            status_interval_minutes=9999,  # Don't auto-send during test\n        )\n\n        # Create a task\n        task = task_queue.create_task(\n            title=\"Test task\",\n            description=\"A test task for the swarm\",\n            priority=TaskPriority.NORMAL,\n            tags=[\"test\"],\n        )\n\n        # Single tick should claim and execute the task\n        swarm._session_start = \"2026-02-16T00:00:00Z\"\n        swarm._last_status_time = __import__(\"time\").time()  # Prevent status send\n        swarm.tick()\n\n        # Task should be completed\n        updated = store.get_node(task.address)\n        assert updated.data[\"status\"] == \"completed\"\n        assert swarm._tasks_completed == 1\n\n        # Status report\n        report = swarm.status_report()\n        assert \"Tasks completed: 1\" in report\n        assert \"Loom\" in report\n\n        # Generate tasks when queue is empty\n        generated = swarm.generate_tasks()\n        assert len(generated) > 0\n        assert any(\"tests\" in t.data.get(\"title\", \"\").lower() for t in generated)\n\n        # State persistence\n        swarm._save_state()\n        state_path = data_dir / \"swarm\" / \"state.json\"\n        assert state_path.exists()\n\n        import json\n        state = json.loads(state_path.read_text(encoding=\"utf-8\"))\n        assert state[\"tasks_completed\"] == 1\n        assert \"Loom\" in state[\"workers\"]\n\n        # Handle incoming message\n        messenger.receive(\"/status\", sender=\"matt\")\n        swarm.tick()\n        outgoing = messenger.get_outgoing()\n        # Should have sent status report in response\n        has_status = any(\"Tasks completed\" in m.content for m in outgoing)\n        assert has_status\n\n        print(\"    PASS\")\n\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef main():\n    print(\"\\n=== Hypernet Core Tests ===\\n\")\n\n    tests = [\n        (\"Address System\", test_address_parsing),\n        (\"Node Model\", test_node_creation),\n        (\"Link Model\", test_link_creation),\n        (\"File Store\", test_store),\n        (\"Version History\", test_version_history),\n        (\"Link Hash Uniqueness\", test_link_hash_uniqueness),\n        (\"Graph Traversal\", test_graph),\n        (\"Task Queue\", test_task_queue),\n        (\"Identity Manager\", test_identity),\n        (\"Worker (Mock)\", test_worker),\n        (\"Messenger\", test_messenger),\n        (\"Swarm Orchestrator\", test_swarm),\n    ]\n\n    passed = 0\n    failed = 0\n\n    for name, test_fn in tests:\n        print(f\"[{name}]\")\n        try:\n            test_fn()\n            passed += 1\n        except Exception as e:\n            print(f\"    FAIL: {e}\")\n            import traceback\n            traceback.print_exc()\n            failed += 1\n\n    print(f\"\\n=== Results: {passed} passed, {failed} failed ===\\n\")\n\n    if failed > 0:\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  "created_at": "2026-02-17T01:23:28.579952+00:00",
  "updated_at": "2026-02-17T01:23:28.579952+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:test_hypernet.py"
}