{
  "address": "0.1.11.4.0.1.1.9.6.2",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\1\\9\\6\\node.json",
    "size": 13158,
    "content": "{\n  \"address\": \"0.1.1.9.6\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"services\",\n    \"type\": \"folder\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.1 - Core System\\\\app\\\\services\",\n    \"content_preview\": \"# Services - Business Logic Layer\\n\\n**Purpose:** Business logic services for Hypernet Core application\\n\\n**Status:** Active development\\n\\n---\\n\\n## Overview\\n\\nThis directory contains the **service layer** for Hypernet Core - the business logic that sits between the API routes and the database models. Services encapsulate complex operations, enforce business rules, and coordinate between multiple models.\\n\\n---\\n\\n## Architecture Pattern\\n\\nHypernet follows a **layered architecture**:\\n\\n```\\n\\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502  Routes (app/routes/)                       \\u2502\\n\\u2502  - Handle HTTP requests/responses           \\u2502\\n\\u2502  - Validate input (Pydantic)                \\u2502\\n\\u2502  - Authentication/authorization checks      \\u2502\\n\\u2502  - Call service layer                       \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n                 \\u2193\\n\\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502  Services (app/services/) \\u2190 YOU ARE HERE    \\u2502\\n\\u2502  - Business logic                           \\u2502\\n\\u2502  - Transaction management                   \\u2502\\n\\u2502  - Orchestrate multiple models              \\u2502\\n\\u2502  - Enforce business rules                   \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n                 \\u2193\\n\\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502  Models (app/models/)                       \\u2502\\n\\u2502  - SQLAlchemy ORM models                    \\u2502\\n\\u2502  - Database schema definitions              \\u2502\\n\\u2502  - Basic CRUD operations                    \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n                 \\u2193\\n\\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502  Database (PostgreSQL)                      \\u2502\\n\\u2502  - Persistent storage                       \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n```\\n\\n---\\n\\n## Why Services?\\n\\n### Problems Services Solve\\n\\n**1. Fat Routes**\\n```python\\n# \\u274c BAD: Business logic in route handler\\n@router.post(\\\"/albums/{album_id}/media\\\")\\nasync def add_media_to_album(album_id: UUID, media_id: UUID, db: Session):\\n    # Complex logic mixed with HTTP handling\\n    album = db.query(Album).filter(Album.id == album_id).first()\\n    if not album:\\n        raise HTTPException(404)\\n    media = db.query(Media).filter(Media.id == media_id).first()\\n    if not media:\\n        raise HTTPException(404)\\n    link = Link(from_object_id=album_id, to_object_id=media_id, ...)\\n    db.add(link)\\n    album.media_count += 1\\n    db.commit()\\n    return link\\n```\\n\\n**2. Duplicated Code**\\n```python\\n# Same logic repeated in multiple routes\\n@router.post(\\\"/albums/{id}/media\\\")  # Adds to album.media_count\\n@router.delete(\\\"/albums/{id}/media/{media_id}\\\")  # Decrements album.media_count\\n# Both need same logic - better in service!\\n```\\n\\n**3. Hard to Test**\\n```python\\n# Testing routes requires mocking HTTP layer\\n# Testing services only requires database session\\n```\\n\\n**4. Transaction Management**\\n```python\\n# Multiple database operations need to be atomic\\n# Services handle transaction boundaries\\n```\\n\\n### Benefits of Services\\n\\n\\u2705 **Reusability:** Logic can be called from routes, background jobs, CLI tools\\n\\u2705 **Testability:** Easy to unit test without HTTP mocking\\n\\u2705 **Maintainability:** Business logic in one place\\n\\u2705 **Transactions:** Proper transaction boundaries\\n\\u2705 **Separation of Concerns:** Routes handle HTTP, services handle business logic\\n\\n---\\n\\n## Service Structure\\n\\n### Naming Convention\\n\\nFiles named after the primary model they work with:\\n\\n```\\napp/services/\\n\\u251c\\u2500\\u2500 __init__.py\\n\\u251c\\u2500\\u2500 user_service.py         # User account operations\\n\\u251c\\u2500\\u2500 media_service.py        # Media upload, processing, metadata\\n\\u251c\\u2500\\u2500 album_service.py        # Album creation, media organization\\n\\u251c\\u2500\\u2500 integration_service.py  # Integration connection, sync\\n\\u251c\\u2500\\u2500 link_service.py         # Link creation, querying\\n\\u2514\\u2500\\u2500 auth_service.py         # Authentication, token management\\n```\\n\\n### Service Class Structure\\n\\n```python\\n# app/services/media_service.py\\nfrom sqlalchemy.orm import Session\\nfrom app.models.media import Media\\nfrom app.models.link import Link\\nfrom uuid import UUID\\n\\nclass MediaService:\\n    \\\"\\\"\\\"\\n    Business logic for media operations.\\n\\n    Responsibilities:\\n    - Upload and process media files\\n    - Extract metadata (EXIF)\\n    - Generate thumbnails\\n    - Manage media lifecycle\\n    - Link media to albums and integrations\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, db: Session):\\n        \\\"\\\"\\\"\\n        Initialize service with database session.\\n\\n        Args:\\n            db: SQLAlchemy database session\\n        \\\"\\\"\\\"\\n        self.db = db\\n\\n    def upload_media(self, user_id: UUID, file, metadata: dict) -> Media:\\n        \\\"\\\"\\\"\\n        Upload and process a media file.\\n\\n        Args:\\n            user_id: Owner of the media\\n            file: Uploaded file object\\n            metadata: Additional metadata\\n\\n        Returns:\\n            Created Media object\\n\\n        Raises:\\n            ValueError: Invalid file type or size\\n            StorageError: Failed to save file\\n        \\\"\\\"\\\"\\n        # Business logic here\\n        pass\\n\\n    def add_to_album(self, media_id: UUID, album_id: UUID, user_id: UUID) -> Link:\\n        \\\"\\\"\\\"\\n        Add media to an album.\\n\\n        This is a transactional operation:\\n        1. Create link object\\n        2. Increment album.media_count\\n        3. Commit or rollback both\\n\\n        Args:\\n            media_id: Media to add\\n            album_id: Target album\\n            user_id: User performing operation (for authorization)\\n\\n        Returns:\\n            Created Link object\\n\\n        Raises:\\n            NotFoundError: Media or album doesn't exist\\n            PermissionError: User doesn't own media or album\\n            DuplicateError: Media already in album\\n        \\\"\\\"\\\"\\n        # Business logic here\\n        pass\\n```\\n\\n---\\n\\n## Service Patterns\\n\\n### 1. Create Operation\\n\\n```python\\ndef create_album(self, user_id: UUID, name: str, description: str = None) -> Album:\\n    \\\"\\\"\\\"Create a new album.\\\"\\\"\\\"\\n\\n    # Validate business rules\\n    if not name or len(name.strip()) == 0:\\n        raise ValueError(\\\"Album name cannot be empty\\\")\\n\\n    if len(name) > 100:\\n        raise ValueError(\\\"Album name too long (max 100 characters)\\\")\\n\\n    # Create object\\n    album = Album(\\n        user_id=user_id,\\n        name=name.strip(),\\n        description=description.strip() if description else None,\\n        media_count=0\\n    )\\n\\n    # Save to database\\n    self.db.add(album)\\n    self.db.commit()\\n    self.db.refresh(album)\\n\\n    return album\\n```\\n\\n### 2. Read/Query Operation\\n\\n```python\\ndef get_album_media(\\n    self,\\n    album_id: UUID,\\n    user_id: UUID,\\n    limit: int = 50,\\n    offset: int = 0\\n) -> list[Media]:\\n    \\\"\\\"\\\"Get media in an album (paginated).\\\"\\\"\\\"\\n\\n    # Verify ownership\\n    album = self.db.query(Album).filter(Album.id == album_id).first()\\n    if not album:\\n        raise NotFoundError(f\\\"Album {album_id} not found\\\")\\n\\n    if album.user_id != user_id:\\n        raise PermissionError(\\\"You don't own this album\\\")\\n\\n    # Query with joins\\n    media = (\\n        self.db.query(Media)\\n        .join(Link, Link.to_object_id == Media.id)\\n        .filter(\\n            Link.from_object_id == album_id,\\n            Link.link_type == \\\"contains\\\",\\n            Link.deleted_at.is_(None),\\n            Media.deleted_at.is_(None)\\n        )\\n        .order_by(Link.sort_order)\\n        .limit(limit)\\n        .offset(offset)\\n        .all()\\n    )\\n\\n    return media\\n```\\n\\n### 3. Update Operation\\n\\n```python\\ndef update_album(\\n    self,\\n    album_id: UUID,\\n    user_id: UUID,\\n    name: str = None,\\n    description: str = None\\n) -> Album:\\n    \\\"\\\"\\\"Update album details.\\\"\\\"\\\"\\n\\n    # Get and verify ownership\\n    album = self.db.query(Album).filter(Album.id == album_id).first()\\n    if not album:\\n        raise NotFoundError(f\\\"Album {album_id} not found\\\")\\n\\n    if album.user_id != user_id:\\n        raise PermissionError(\\\"You don't own this album\\\")\\n\\n    # Update fields\\n    if name is not None:\\n        if not name.strip():\\n            raise ValueError(\\\"Album name cannot be empty\\\")\\n        album.name = name.strip()\\n\\n    if description is not None:\\n        album.description = description.strip() if description else None\\n\\n    # Save changes\\n    self.db.commit()\\n    self.db.refresh(album)\\n\\n    return album\\n```\\n\\n### 4. Delete Operation (Soft Delete)\\n\\n```python\\ndef delete_album(self, album_id: UUID, user_id: UUID) -> None:\\n    \\\"\\\"\\\"Soft delete an album.\\\"\\\"\\\"\\n\\n    # Get and verify ownership\\n    album = self.db.query(Album).filter(Album.id == album_id).first()\\n    if not album:\\n        raise NotFoundError(f\\\"Album {album_id} not found\\\")\\n\\n    if album.user_id != user_id:\\n        raise PermissionError(\\\"You don't own this album\\\")\\n\\n    # Soft delete (set deleted_at)\\n    from datetime import datetime, timezone\\n    album.deleted_at = datetime.now(timezone.utc)\\n\\n    # Also soft delete all links\\n    self.db.query(Link).filter(\\n        Link.from_object_id == album_id,\\n        Link.deleted_at.is_(None)\\n    ).update({\\\"deleted_at\\\": datetime.now(timezone.utc)})\\n\\n    self.db.commit()\\n```\\n\\n### 5. Complex Transaction\\n\\n```python\\ndef sync_from_integration(\\n    self,\\n    integration_id: UUID,\\n    user_id: UUID,\\n    limit: int = 100\\n) -> dict:\\n    \\\"\\\"\\\"\\n    Sync media from an integration.\\n\\n    This is a complex multi-step transaction:\\n    1. Fetch items from external API\\n    2. Check for duplicates\\n    3. Download new media\\n    4. Create Media objects\\n    5. Create Link objects (media \\u2192 integration)\\n    6. Update integration sync state\\n\\n    Returns:\\n        Sync summary (new_count, skipped_count, error_count)\\n    \\\"\\\"\\\"\\n\\n    try:\\n        # Get integration\\n        integration = self.db.query(Integration).filter(\\n            Integration.id == integration_id,\\n            Integration.user_id == user_id\\n        ).first()\\n\\n        if not integration:\\n            raise NotFoundError(\\\"Integration not found\\\")\\n\\n        # Fetch from external API (using integration-specific client)\\n        client = self._get_integration_client(integration)\\n        items = client.fetch_media(cursor=integration.sync_cursor, limit=limit)\\n\\n        new_count = 0\\n        skipped_count = 0\\n\\n        for item in items:\\n            # Check if already imported\\n            existing = self.db.query(Link\\n... [truncated]\",\n    \"content_file\": \"README.md\"\n  },\n  \"created_at\": \"2026-02-17T01:21:59.085708+00:00\",\n  \"updated_at\": \"2026-02-17T01:21:59.085708+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"folder:services\"\n}"
  },
  "created_at": "2026-02-17T01:22:23.610082+00:00",
  "updated_at": "2026-02-17T01:22:23.610082+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}