{
  "address": "0.1.11.4.0.0.8",
  "type_address": null,
  "data": {
    "name": "8",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\0\\8",
    "content_preview": "{\n  \"address\": \"0.0.8\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"README.md\",\n    \"type\": \"file\",\n    \"extension\": \".md\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.0 Metadata for Hypernet Information\\\\README.md\",\n    \"size\": 14556,\n    \"content\": \"# 0.0 - Metadata for Hypernet Information\\n\\n**Version:** 1.0\\n**Last Updated:** February 9, 2026\\n**Purpose:** Core infrastructure specifications and addressing system\\n**Status:** Active - Foundational\\n\\n---\\n\\n## Overview\\n\\nSection 0.0 contains the **most fundamental metadata** in the entire Hypernet system. This is where we define the universal addressing scheme, version control mechanisms, allocation protocols, and lifecycle policies that enable everything else to function.\\n\\nIf Hypernet were a library, this section would define the Dewey Decimal System itself\\u2014not the books, but the organizing principle that makes finding any book possible. It establishes the rules by which all information in Hypernet receives a permanent, unique, hierarchical address.\\n\\n## Purpose and Importance\\n\\n### Why This Matters\\n\\nThe current internet has a fundamental problem: **information duplication**. The same photo exists on a trillion devices. The same document is copied endlessly. There is no single source of truth, no permanent address, no way to know what's authoritative.\\n\\nSection 0.0 solves this by establishing:\\n\\n1. **Universal Uniqueness**: Every piece of information has exactly ONE permanent address\\n2. **Hierarchical Organization**: Addresses form logical, navigable hierarchies\\n3. **Persistent Addressing**: Once assigned, addresses never change or disappear\\n4. **Version Control**: Changes create new versions, not new addresses\\n5. **Lifecycle Management**: Clear policies for deprecation and archival\\n\\nThis addressing foundation enables The Singularity to organize all human knowledge coherently, creating a truly universal knowledge graph.\\n\\n## What Should Be Stored Here\\n\\n### Core Infrastructure Documents\\n\\nThis section contains specifications that define:\\n\\n**Addressing and Organization:**\\n- How the decimal numbering system works (X.Y.Z.W...)\\n- Rules for address assignment and inheritance\\n- Reserved address spaces and allocation policies\\n- Cross-referencing and link mechanisms\\n\\n**Version Control:**\\n- How versions are numbered (semantic versioning)\\n- What constitutes a new version vs. new object\\n- Version history tracking requirements\\n- Backward compatibility rules\\n\\n**Lifecycle Management:**\\n- When and how objects are deprecated\\n- Archival procedures and policies\\n- Restoration request workflows\\n- Historical access requirements\\n\\n**System Metadata:**\\n- Core system configuration schemas\\n- Global constants and parameters\\n- System-wide validation rules\\n- Metadata format specifications\\n\\n### What Does NOT Belong Here\\n\\n- **Object schemas**: Those go in 0.5 Objects - Master Objects\\n- **Link definitions**: Those go in 0.6 Link Definitions\\n- **Node specifications**: Those go in 0.2 Node lists\\n- **Governance rules**: Those go in 0.3 Control data\\n- **Actual implementation**: That goes in 0.1 - Hypernet Core\\n\\nThis section is specifically about the **addressing infrastructure** that underlies everything else.\\n\\n## Contents\\n\\n### 0.0.0 Library Addressing System\\n**Purpose:** Defines the entire Hypernet addressing scheme\\n**Key concepts:**\\n- Top-level categories (0-9)\\n- Hierarchical decimal notation\\n- Address resolution and inheritance\\n- Cross-referencing rules\\n- Reserved address spaces\\n\\n**Why read it:** This is the foundation. Understanding addressing is essential to understanding Hypernet.\\n\\n**Length:** ~100 lines, 15 minute read\\n\\n### 0.0.1 Version Control Schema\\n**Purpose:** Defines how versioning works across all objects\\n**Key concepts:**\\n- Semantic versioning (MAJOR.MINOR.PATCH)\\n- Version history requirements\\n- Change tracking mechanisms\\n- Backward compatibility rules\\n- Migration procedures\\n\\n**Why read it:** Ensures you understand how objects evolve over time while maintaining stability.\\n\\n**Status:** Defined in principle, needs detailed implementation guide\\n\\n### 0.0.2 Address Allocation Protocol\\n**Purpose:** Rules for assigning new addresses\\n**Key concepts:**\\n- Who can allocate addresses in which ranges\\n- Sequential allocation requirements\\n- Reserved ranges and special addresses\\n- Collision prevention\\n- Authority delegation\\n\\n**Why read it:** If you're creating new categories or object types, you need to follow these rules.\\n\\n**Status:** Defined in principle, needs formalization\\n\\n### 0.0.3 Deprecation and Archival Policy\\n**Purpose:** Managing the lifecycle of objects and addresses\\n**Key concepts:**\\n- When to deprecate vs. archive\\n- Retention requirements\\n- Access to archived content\\n- Restoration procedures\\n- Historical record preservation\\n\\n**Why read it:** Objects don't stay \\\"active\\\" forever. Understanding lifecycle management prevents data loss.\\n\\n**Status:** Defined in principle, needs detailed procedures\\n\\n## Relationship to Other Metadata Sections\\n\\nSection 0.0 is the **meta-metadata**\\u2014it defines the infrastructure that other metadata sections use:\\n\\n```\\n\\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502  0.0 - Metadata for Hypernet Information            \\u2502\\n\\u2502  Defines: Addressing, Versioning, Allocation        \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n             \\u2502\\n             \\u251c\\u2500\\u25ba 0.1 Code (uses addresses)\\n             \\u2502\\n             \\u251c\\u2500\\u25ba 0.2 Node lists (uses addresses)\\n             \\u2502\\n             \\u251c\\u2500\\u25ba 0.3 Control data (uses versioning)\\n             \\u2502\\n             \\u251c\\u2500\\u25ba 0.5 Objects (uses addresses & versions)\\n             \\u2502\\n             \\u251c\\u2500\\u25ba 0.6 Link Definitions (uses addresses)\\n             \\u2502\\n             \\u2514\\u2500\\u25ba 0.7 Processes (uses versioning)\\n```\\n\\n**Example:** When you define a new object type in 0.5, you must:\\n1. Follow the addressing rules from 0.0.0\\n2. Assign it an address using protocols from 0.0.2\\n3. Version it according to schema from 0.0.1\\n4. Plan its lifecycle per policy from 0.0.3\\n\\n## Addressing System Deep Dive\\n\\n### The Decimal Hierarchy\\n\\nAddresses use decimal notation to create natural hierarchies:\\n```\\n3.1.2.1.001\\n\\u2502 \\u2502 \\u2502 \\u2502 \\u2514\\u2500\\u2500 Instance number (5 levels deep)\\n\\u2502 \\u2502 \\u2502 \\u2514\\u2500\\u2500\\u2500\\u2500 Status category (4 levels deep)\\n\\u2502 \\u2502 \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500 Component (3 levels deep)\\n\\u2502 \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500 Subcategory (2 levels deep)\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500 Major category (1 level deep)\\n```\\n\\nEach level can expand infinitely: 0.1.2.3.4.5.6.7.8.9.10.11...\\n\\n### Top-Level Categories\\n\\n| Address | Category | Example |\\n|---------|----------|---------|\\n| 0 | System Metadata | Node specifications, governance |\\n| 1 | People | Individual persons |\\n| 2 | Groups & Organizations | Non-commercial collectives |\\n| 3 | Businesses | Commercial entities |\\n| 4 | Knowledge | Information, research, education |\\n| 5 | Objects | Physical items, devices |\\n| 6 | Media | Audio, video, images |\\n| 7 | Events | Time-bound occurrences |\\n| 8 | Locations | Physical and virtual places |\\n| 9 | Concepts | Abstract ideas, theories |\\n\\n### Address Permanence\\n\\nOnce assigned, addresses are **immutable**. This means:\\n- An object at address 3.1.2.1.001 will ALWAYS be at that address\\n- If the object is moved or deleted, the address is reserved\\n- No address is ever reused for different content\\n- Links never break due to address changes\\n\\nThis permanence is crucial for building a stable knowledge graph.\\n\\n### Version Control Integration\\n\\nVersions are managed AT the address, not through new addresses:\\n```\\n3.1.2.1.001\\n\\u251c\\u2500\\u2500 v1.0.0 (initial creation)\\n\\u251c\\u2500\\u2500 v1.1.0 (feature added)\\n\\u251c\\u2500\\u2500 v1.1.1 (bug fix)\\n\\u2514\\u2500\\u2500 v2.0.0 (breaking change)\\n```\\n\\nThe address remains 3.1.2.1.001 across all versions.\\n\\n## Common Use Cases\\n\\n### For System Architects\\n**Task:** Understanding the complete addressing architecture\\n**Read:**\\n1. 0.0.0 Library Addressing System (foundational)\\n2. 0.0.2 Address Allocation Protocol (practical)\\n3. Related: 0.5.0 Master Object Schema (see how objects use addresses)\\n\\n### For Developers\\n**Task:** Implementing address-aware features\\n**Need to know:**\\n- How addresses are structured and validated\\n- How to generate new addresses in your namespace\\n- How version numbers map to objects\\n- How to handle deprecated content\\n\\n**Read:** 0.0.0 and 0.0.1\\n\\n### For Content Creators\\n**Task:** Creating new information categories\\n**Need to know:**\\n- What address range you're authorized to use\\n- How to request new address allocations\\n- Versioning requirements for your content\\n- Deprecation policies\\n\\n**Read:** 0.0.2 and 0.0.3\\n\\n### For Data Managers\\n**Task:** Managing object lifecycles\\n**Need to know:**\\n- When to mark something deprecated\\n- How to archive old content\\n- Retention requirements\\n- How to restore archived objects\\n\\n**Read:** 0.0.3\\n\\n## Examples in Practice\\n\\n### Example 1: Task Management System\\n\\n**Address:** `3.1.2.1.001`\\n- Category 3 (Businesses)\\n- Subcategory 3.1 (Hypernet company)\\n-\n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-17T01:22:19.598181+00:00",
  "updated_at": "2026-02-17T01:22:19.598181+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:8"
}