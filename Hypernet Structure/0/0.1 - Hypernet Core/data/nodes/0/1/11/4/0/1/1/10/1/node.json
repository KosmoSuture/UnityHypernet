{
  "address": "0.1.11.4.0.1.1.10.1",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\1\\10\\node.json",
    "size": 13800,
    "content": "{\n  \"address\": \"0.1.1.10\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"import_photos.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.1 - Core System\\\\import_photos.py\",\n    \"size\": 13142,\n    \"content\": \"\\\"\\\"\\\"\\nPhoto Import Script for Hypernet MVP\\nImports photos from a directory, extracts EXIF metadata, and populates the database\\n\\\"\\\"\\\"\\n\\nimport sqlite3\\nimport os\\nfrom pathlib import Path\\nfrom datetime import datetime\\nfrom typing import Optional, Tuple\\nimport hashlib\\nimport json\\n\\n# For EXIF extraction\\ntry:\\n    from PIL import Image\\n    from PIL.ExifTags import TAGS, GPSTAGS\\nexcept ImportError:\\n    print(\\\"PIL/Pillow not installed. Run: pip install Pillow\\\")\\n    exit(1)\\n\\nfrom mvp_models import (\\n    HypernetObject, Photo, ObjectType, PrivacyLevel,\\n    HypernetAddress\\n)\\n\\n\\nclass PhotoImporter:\\n    \\\"\\\"\\\"Import photos into Hypernet database\\\"\\\"\\\"\\n\\n    def __init__(self, db_path: str):\\n        self.db_path = db_path\\n        self.conn = sqlite3.connect(db_path)\\n        self.conn.row_factory = sqlite3.Row\\n        self.cursor = self.conn.cursor()\\n\\n    def __enter__(self):\\n        return self\\n\\n    def __exit__(self, exc_type, exc_val, exc_tb):\\n        self.conn.close()\\n\\n    def get_next_photo_instance(self, owner_address: str = \\\"1.1\\\") -> int:\\n        \\\"\\\"\\\"Get next available instance number for photos\\\"\\\"\\\"\\n        self.cursor.execute(\\\"\\\"\\\"\\n            SELECT MAX(instance) as max_instance\\n            FROM ha_registry\\n            WHERE category = 1\\n              AND subcategory = (SELECT subcategory FROM ha_registry WHERE hypernet_address = ?)\\n              AND type = 8\\n              AND subtype = 0\\n        \\\"\\\"\\\", (owner_address,))\\n\\n        result = self.cursor.fetchone()\\n        max_instance = result['max_instance'] if result['max_instance'] else 0\\n        return max_instance + 1\\n\\n    def extract_exif(self, image_path: str) -> dict:\\n        \\\"\\\"\\\"Extract EXIF metadata from image\\\"\\\"\\\"\\n        try:\\n            image = Image.open(image_path)\\n            exif_data = image._getexif()\\n\\n            if not exif_data:\\n                return {}\\n\\n            exif = {}\\n\\n            for tag_id, value in exif_data.items():\\n                tag = TAGS.get(tag_id, tag_id)\\n                exif[tag] = value\\n\\n            # Extract GPS info if available\\n            if 'GPSInfo' in exif:\\n                gps_info = {}\\n                for key in exif['GPSInfo'].keys():\\n                    decode = GPSTAGS.get(key, key)\\n                    gps_info[decode] = exif['GPSInfo'][key]\\n                exif['GPSInfo'] = gps_info\\n\\n            return exif\\n\\n        except Exception as e:\\n            print(f\\\"Error extracting EXIF from {image_path}: {e}\\\")\\n            return {}\\n\\n    def convert_gps_to_degrees(self, gps_coord, gps_ref) -> float:\\n        \\\"\\\"\\\"Convert GPS coordinates to degrees\\\"\\\"\\\"\\n        d, m, s = gps_coord\\n        degrees = float(d) + float(m) / 60.0 + float(s) / 3600.0\\n\\n        if gps_ref in ['S', 'W']:\\n            degrees = -degrees\\n\\n        return degrees\\n\\n    def get_gps_coordinates(self, exif: dict) -> Tuple[Optional[float], Optional[float]]:\\n        \\\"\\\"\\\"Extract GPS latitude and longitude from EXIF\\\"\\\"\\\"\\n        gps_info = exif.get('GPSInfo', {})\\n\\n        if not gps_info:\\n            return None, None\\n\\n        try:\\n            gps_latitude = gps_info.get('GPSLatitude')\\n            gps_latitude_ref = gps_info.get('GPSLatitudeRef')\\n            gps_longitude = gps_info.get('GPSLongitude')\\n            gps_longitude_ref = gps_info.get('GPSLongitudeRef')\\n\\n            if gps_latitude and gps_longitude:\\n                lat = self.convert_gps_to_degrees(gps_latitude, gps_latitude_ref)\\n                lon = self.convert_gps_to_degrees(gps_longitude, gps_longitude_ref)\\n                return lat, lon\\n\\n        except Exception as e:\\n            print(f\\\"Error parsing GPS data: {e}\\\")\\n\\n        return None, None\\n\\n    def get_date_taken(self, exif: dict, file_path: str) -> datetime:\\n        \\\"\\\"\\\"Get the date the photo was taken\\\"\\\"\\\"\\n        # Try EXIF date first\\n        date_str = exif.get('DateTimeOriginal') or exif.get('DateTime')\\n\\n        if date_str:\\n            try:\\n                return datetime.strptime(date_str, '%Y:%m:%d %H:%M:%S')\\n            except:\\n                pass\\n\\n        # Fall back to file modification time\\n        return datetime.fromtimestamp(os.path.getmtime(file_path))\\n\\n    def compute_perceptual_hash(self, image_path: str) -> str:\\n        \\\"\\\"\\\"Compute perceptual hash for duplicate detection\\\"\\\"\\\"\\n        try:\\n            image = Image.open(image_path)\\n            # Resize to 8x8\\n            image = image.resize((8, 8), Image.Resampling.LANCZOS).convert('L')\\n            # Get pixels\\n            pixels = list(image.getdata())\\n            # Compute average\\n            avg = sum(pixels) / len(pixels)\\n            # Generate hash\\n            bits = ''.join('1' if pixel > avg else '0' for pixel in pixels)\\n            # Convert to hex\\n            return hex(int(bits, 2))[2:].zfill(16)\\n        except Exception as e:\\n            print(f\\\"Error computing hash for {image_path}: {e}\\\")\\n            return \\\"\\\"\\n\\n    def import_photo(self, file_path: str, owner_address: str = \\\"1.1\\\",\\n                    privacy_level: PrivacyLevel = PrivacyLevel.PRIVATE) -> Optional[str]:\\n        \\\"\\\"\\\"Import a single photo\\\"\\\"\\\"\\n\\n        # Get file info\\n        file_size = os.path.getsize(file_path)\\n        file_name = os.path.basename(file_path)\\n\\n        # Extract EXIF\\n        print(f\\\"Importing: {file_name}\\\")\\n        exif = self.extract_exif(file_path)\\n\\n        # Get image dimensions\\n        try:\\n            image = Image.open(file_path)\\n            width, height = image.size\\n        except Exception as e:\\n            print(f\\\"Error opening image {file_path}: {e}\\\")\\n            return None\\n\\n        # Extract metadata\\n        camera_make = exif.get('Make', '').strip()\\n        camera_model = exif.get('Model', '').strip()\\n        lens_model = exif.get('LensModel', '').strip()\\n        iso = exif.get('ISOSpeedRatings')\\n        aperture = exif.get('FNumber')\\n        focal_length = exif.get('FocalLength')\\n        flash = 1 if exif.get('Flash', 0) else 0\\n\\n        # Get GPS coordinates\\n        latitude, longitude = self.get_gps_coordinates(exif)\\n\\n        # Get date taken\\n        taken_at = self.get_date_taken(exif, file_path)\\n\\n        # Compute perceptual hash\\n        perceptual_hash = self.compute_perceptual_hash(file_path)\\n\\n        # Check for duplicates\\n        if perceptual_hash:\\n            self.cursor.execute(\\\"\\\"\\\"\\n                SELECT hypernet_address FROM photos WHERE perceptual_hash = ?\\n            \\\"\\\"\\\", (perceptual_hash,))\\n            if self.cursor.fetchone():\\n                print(f\\\"  Duplicate detected, skipping: {file_name}\\\")\\n                return None\\n\\n        # Generate Hypernet Address\\n        instance = self.get_next_photo_instance(owner_address)\\n        hypernet_address = HypernetAddress.generate(1, 1, 8, 0, instance)\\n\\n        # Create object record\\n        self.cursor.execute(\\\"\\\"\\\"\\n            INSERT INTO objects (\\n                hypernet_address, object_type, owner_address, title,\\n                created_at, updated_at, original_date,\\n                file_path, file_size, mime_type,\\n                privacy_level, status, search_text\\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\\n        \\\"\\\"\\\", (\\n            hypernet_address,\\n            ObjectType.PHOTO.value,\\n            owner_address,\\n            file_name,\\n            datetime.now().isoformat(),\\n            datetime.now().isoformat(),\\n            taken_at.isoformat(),\\n            file_path,\\n            file_size,\\n            'image/jpeg',  # Simplified, could detect from extension\\n            privacy_level.value,\\n            'active',\\n            file_name  # For full-text search\\n        ))\\n\\n        object_id = self.cursor.lastrowid\\n\\n        # Create photo record\\n        self.cursor.execute(\\\"\\\"\\\"\\n            INSERT INTO photos (\\n                object_id, hypernet_address,\\n                width, height,\\n                camera_make, camera_model, lens_model,\\n                iso, aperture, focal_length, flash,\\n                latitude, longitude,\\n                taken_at, perceptual_hash\\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\\n        \\\"\\\"\\\", (\\n            object_id,\\n            hypernet_address,\\n            width,\\n            height,\\n            camera_make,\\n            camera_model,\\n            lens_model,\\n            iso,\\n            aperture,\\n            focal_length,\\n            flash,\\n            latitude,\\n            longitude,\\n            taken_at.isoformat(),\\n            perceptual_hash\\n        ))\\n\\n        # Register address\\n        self.cursor.execute(\\\"\\\"\\\"\\n            INSERT INTO ha_registry (\\n                hypernet_address, category, subcategory, type, subtype, instance,\\n                object_type, object_id, status, allocated_at\\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\\n        \\\"\\\"\\\", (\\n            hypernet_address, 1, 1, 8, 0, instance,\\n            ObjectType.PHOTO.value, object_id, 'active',\\n            datetime.now().isoformat()\\n        ))\\n\\n        self.conn.commit()\\n\\n        print(f\\\"  \\u2713 Imported as {hypernet_address}\\\")\\n        return hypernet_address\\n\\n    def import_directory(self, directory: str, owner_address: str = \\\"1.1\\\",\\n                        privacy_level: PrivacyLevel = PrivacyLevel.PRIVATE,\\n                        recursive: bool = False):\\n        \\\"\\\"\\\"Import all photos from a directory\\\"\\\"\\\"\\n\\n        photo_extensions = {'.jpg', '.jpeg', '.png', '.heic', '.heif'}\\n        count = 0\\n\\n        if recursive:\\n            # Walk through all subdirectories\\n            for root, dirs, files in os.walk(directory):\\n                for file in files:\\n                    ext = Path(file).suffix.lower()\\n                    if ext in photo_extensions:\\n                        file_path = os.path.join(root, file)\\n                        if self.import_photo(file_path, owner_address, privacy_level):\\n                            count += 1\\n        else:\\n            # Just process files in the directory\\n            for file in os.listdir(directory):\\n                ext = Path(file).suffix.lower()\\n                if ext in photo_extensions:\\n                    file_path = os.path.join(directory, file)\\n                    if os.path.isfile(file_path):\\n                        if self.import_photo(file_path, owner_address, privacy_level):\\n                            count += 1\\n\\n        print(f\\\"\\\\nImported {count} photos\\\")\\n        return count\\n\\n    def generate_thumbnails(self, max_photos: int = None):\\n        \\\"\\\"\\\"Generate thumbnails for photos that don't have them\\\"\\\"\\\"\\n        # TODO: Implement thumbnail generation\\n        # For MVP, could use PIL to create 256x256, 512x512, 1024x1024 versions\\n        pass\\n\\n\\n# ============================================================================\\n# MAIN EXECUTION\\n# ============================================================================\\n\\ndef main():\\n    \\\"\\\"\\\"Main import script\\\"\\\"\\\"\\n    import argparse\\n\\n    parser = argparse.ArgumentParser(description='Import photos into Hypernet')\\n    parser.add_argument('directory', help='Directory containing photos')\\n    parser.add_argument('--db', default='hypernet.db', help='Database file')\\n    parser.add_argument('--owner', default='1.1', help='Owner Hypernet Address')\\n    parser.add_argument('--privacy', default='private',\\n                       choices=['private', 'family', 'friends', 'professional', 'public'],\\n                       help='Privacy level')\\n    parser.add_argument('--recursive', action='store_true',\\n                       help='Recursively import from subdirectories')\\n\\n    args = parser.parse_args()\\n\\n    # Convert privacy string to enum\\n    privacy_map = {\\n        'private': PrivacyLevel.PRIVATE,\\n        'family': PrivacyLevel.FAMILY,\\n        'friends': PrivacyLevel.FRIENDS,\\n        'professional': PrivacyLevel.PROFESSIONAL,\\n        'public': PrivacyLevel.PUBLIC\\n    }\\n    privacy_level = privacy_map[args.privacy]\\n\\n    print(f\\\"Importing photos from: {args.directory}\\\")\\n    print(f\\\"Owner: {args.owner}\\\")\\n    print(f\\\"Privacy: {args.privacy}\\\")\\n    print(f\\\"Recursive: {args.recursive}\\\")\\n    print()\\n\\n    with PhotoImporter(args.db) as importer:\\n        importer.import_directory(\\n            args.directory,\\n            owner_address=args.owner,\\n            privacy_level=privacy_level,\\n            recursive=args.recursive\\n        )\\n\\n    print(\\\"\\\\nDone!\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\\n\\n# ============================================================================\\n# EXAMPLE USAGE\\n# ============================================================================\\n\\n\\\"\\\"\\\"\\n# Import photos from Google Photos export\\npython import_photos.py \\\"/path/to/Google Photos Takeout/Photos\\\" --recursive --privacy family\\n\\n# Import just your iPhone photos from last month\\npython import_photos.py \\\"/Users/matt/Pictures/2024-02\\\" --privacy private\\n\\n# Import photos for another family member\\npython import_photos.py \\\"/path/to/sarah/photos\\\" --owner 1.2 --privacy private\\n\\\"\\\"\\\"\\n\"\n  },\n  \"created_at\": \"2026-02-17T01:21:59.107706+00:00\",\n  \"updated_at\": \"2026-02-17T01:21:59.107706+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"file:import_photos.py\"\n}"
  },
  "created_at": "2026-02-17T01:22:22.695804+00:00",
  "updated_at": "2026-02-17T01:22:22.695804+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}