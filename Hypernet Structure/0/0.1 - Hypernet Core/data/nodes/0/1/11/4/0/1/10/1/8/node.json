{
  "address": "0.1.11.4.0.1.10.1.8",
  "type_address": null,
  "data": {
    "name": "8",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\10\\1\\8",
    "content_preview": "{\n  \"address\": \"0.1.10.1.8\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"transactions.py\",\n    \"type\": \"file\",\n    \"extension\": \".py\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\app\\\\routes\\\\transactions.py\",\n    \"size\": 11152,\n    \"content\": \"\\\"\\\"\\\"\\nTransactions API Routes\\n\\nProvides CRUD operations for financial transaction management including\\npayments, purchases, transfers, and other financial activities.\\n\\\"\\\"\\\"\\n\\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\\nfrom sqlalchemy.orm import Session\\nfrom sqlalchemy import and_, or_\\nfrom typing import Optional, List\\nfrom datetime import datetime, date\\nfrom uuid import UUID\\nfrom decimal import Decimal\\nfrom pydantic import BaseModel, Field\\n\\nfrom app.core.database import get_db\\nfrom app.core.dependencies import get_current_user\\nfrom app.models.user import User\\nfrom app.models.transaction import Transaction\\n\\n\\nrouter = APIRouter()\\n\\n\\n# Pydantic Models for Request/Response\\nclass TransactionCreate(BaseModel):\\n    transaction_type: str = Field(..., description=\\\"purchase, payment, transfer, refund, subscription, income, other\\\")\\n    amount: Decimal = Field(..., description=\\\"Transaction amount\\\")\\n    currency: str = Field(default=\\\"USD\\\", max_length=3)\\n    merchant: Optional[str] = Field(None, max_length=300)\\n    category: Optional[str] = Field(None, max_length=200)\\n    description: Optional[str] = Field(None, max_length=1000)\\n    transaction_date: datetime\\n    payment_method: Optional[str] = Field(None, max_length=100)\\n    status: str = Field(default=\\\"completed\\\", description=\\\"pending, completed, failed, cancelled, refunded\\\")\\n    account_last_four: Optional[str] = Field(None, max_length=4)\\n    receipt_url: Optional[str] = None\\n    tags: List[str] = Field(default_factory=list)\\n    is_recurring: bool = Field(default=False)\\n    notes: Optional[str] = None\\n\\n\\nclass TransactionUpdate(BaseModel):\\n    category: Optional[str] = Field(None, max_length=200)\\n    description: Optional[str] = Field(None, max_length=1000)\\n    status: Optional[str] = Field(None, description=\\\"pending, completed, failed, cancelled, refunded\\\")\\n    tags: Optional[List[str]] = None\\n    notes: Optional[str] = None\\n\\n\\nclass TransactionResponse(BaseModel):\\n    id: UUID\\n    user_id: UUID\\n    transaction_type: str\\n    amount: Decimal\\n    currency: str\\n    merchant: Optional[str]\\n    category: Optional[str]\\n    description: Optional[str]\\n    transaction_date: datetime\\n    payment_method: Optional[str]\\n    status: str\\n    account_last_four: Optional[str]\\n    receipt_url: Optional[str]\\n    tags: List[str]\\n    is_recurring: bool\\n    notes: Optional[str]\\n    created_at: datetime\\n    updated_at: datetime\\n\\n    class Config:\\n        from_attributes = True\\n\\n\\nclass TransactionListResponse(BaseModel):\\n    items: List[TransactionResponse]\\n    total: int\\n    page: int\\n    page_size: int\\n    pages: int\\n    total_amount: Optional[Decimal] = None\\n\\n\\nclass SpendingSummary(BaseModel):\\n    category: str\\n    total: Decimal\\n    count: int\\n    currency: str\\n\\n\\n# Endpoints\\n@router.post(\\\"\\\", response_model=TransactionResponse, status_code=status.HTTP_201_CREATED)\\nasync def create_transaction(\\n    transaction_data: TransactionCreate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Create a new transaction record.\\\"\\\"\\\"\\n    transaction = Transaction(\\n        user_id=current_user.id,\\n        **transaction_data.dict()\\n    )\\n    db.add(transaction)\\n    db.commit()\\n    db.refresh(transaction)\\n    return transaction\\n\\n\\n@router.get(\\\"\\\", response_model=TransactionListResponse)\\nasync def list_transactions(\\n    transaction_type: Optional[str] = Query(None, description=\\\"Filter by transaction type\\\"),\\n    category: Optional[str] = Query(None, description=\\\"Filter by category\\\"),\\n    merchant: Optional[str] = Query(None, description=\\\"Filter by merchant\\\"),\\n    status: Optional[str] = Query(None, description=\\\"Filter by status\\\"),\\n    is_recurring: Optional[bool] = Query(None, description=\\\"Filter recurring transactions\\\"),\\n    min_amount: Optional[Decimal] = Query(None, description=\\\"Minimum amount\\\"),\\n    max_amount: Optional[Decimal] = Query(None, description=\\\"Maximum amount\\\"),\\n    start_date: Optional[date] = Query(None, description=\\\"Start date (YYYY-MM-DD)\\\"),\\n    end_date: Optional[date] = Query(None, description=\\\"End date (YYYY-MM-DD)\\\"),\\n    search: Optional[str] = Query(None, description=\\\"Search in merchant, description, notes\\\"),\\n    page: int = Query(1, ge=1, description=\\\"Page number\\\"),\\n    page_size: int = Query(50, ge=1, le=100, description=\\\"Items per page\\\"),\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"List transactions with optional filtering and totals.\\\"\\\"\\\"\\n    query = db.query(Transaction).filter(\\n        and_(\\n            Transaction.user_id == current_user.id,\\n            Transaction.deleted_at.is_(None)\\n        )\\n    )\\n\\n    if transaction_type:\\n        query = query.filter(Transaction.transaction_type == transaction_type)\\n\\n    if category:\\n        query = query.filter(Transaction.category == category)\\n\\n    if merchant:\\n        query = query.filter(Transaction.merchant.ilike(f\\\"%{merchant}%\\\"))\\n\\n    if status:\\n        query = query.filter(Transaction.status == status)\\n\\n    if is_recurring is not None:\\n        query = query.filter(Transaction.is_recurring == is_recurring)\\n\\n    if min_amount is not None:\\n        query = query.filter(Transaction.amount >= min_amount)\\n\\n    if max_amount is not None:\\n        query = query.filter(Transaction.amount <= max_amount)\\n\\n    if start_date:\\n        query = query.filter(Transaction.transaction_date >= datetime.combine(start_date, datetime.min.time()))\\n\\n    if end_date:\\n        query = query.filter(Transaction.transaction_date <= datetime.combine(end_date, datetime.max.time()))\\n\\n    if search:\\n        search_pattern = f\\\"%{search}%\\\"\\n        query = query.filter(\\n            or_(\\n                Transaction.merchant.ilike(search_pattern),\\n                Transaction.description.ilike(search_pattern),\\n                Transaction.notes.ilike(search_pattern)\\n            )\\n        )\\n\\n    total = query.count()\\n\\n    # Calculate total amount for filtered transactions\\n    from sqlalchemy import func\\n    total_amount_result = query.with_entities(func.sum(Transaction.amount)).scalar()\\n    total_amount = total_amount_result if total_amount_result else Decimal(0)\\n\\n    # Order by transaction_date descending (most recent first)\\n    query = query.order_by(Transaction.transaction_date.desc())\\n\\n    offset = (page - 1) * page_size\\n    items = query.offset(offset).limit(page_size).all()\\n\\n    pages = (total + page_size - 1) // page_size\\n\\n    return TransactionListResponse(\\n        items=items,\\n        total=total,\\n        page=page,\\n        page_size=page_size,\\n        pages=pages,\\n        total_amount=total_amount\\n    )\\n\\n\\n@router.get(\\\"/summary\\\", response_model=List[SpendingSummary])\\nasync def get_spending_summary(\\n    start_date: Optional[date] = Query(None, description=\\\"Start date (YYYY-MM-DD)\\\"),\\n    end_date: Optional[date] = Query(None, description=\\\"End date (YYYY-MM-DD)\\\"),\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get spending summary grouped by category.\\\"\\\"\\\"\\n    from sqlalchemy import func\\n\\n    query = db.query(\\n        Transaction.category,\\n        func.sum(Transaction.amount).label('total'),\\n        func.count(Transaction.id).label('count'),\\n        Transaction.currency\\n    ).filter(\\n        and_(\\n            Transaction.user_id == current_user.id,\\n            Transaction.deleted_at.is_(None),\\n            Transaction.category.isnot(None)\\n        )\\n    )\\n\\n    if start_date:\\n        query = query.filter(Transaction.transaction_date >= datetime.combine(start_date, datetime.min.time()))\\n\\n    if end_date:\\n        query = query.filter(Transaction.transaction_date <= datetime.combine(end_date, datetime.max.time()))\\n\\n    results = query.group_by(Transaction.category, Transaction.currency).all()\\n\\n    return [\\n        SpendingSummary(\\n            category=row.category,\\n            total=row.total,\\n            count=row.count,\\n            currency=row.currency\\n        )\\n        for row in results\\n    ]\\n\\n\\n@router.get(\\\"/categories\\\", response_model=List[str])\\nasync def list_categories(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get all unique categories for user's transactions.\\\"\\\"\\\"\\n    categories = db.query(Transaction.category).filter(\\n        and_(\\n            Transaction.user_id == current_user.id,\\n            Transaction.deleted_at.is_(None),\\n            Transaction.category.isnot(None)\\n        )\\n    ).distinct().all()\\n\\n    return [cat[0] for cat in categories if cat[0]]\\n\\n\\n@router.get(\\\"/{transaction_id}\\\", response_model=TransactionResponse)\\nasync def get_transaction(\\n    transaction_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get a specific transaction by ID.\\\"\\\"\\\"\\n    transaction = db.query(Transaction).filter(\\n        and_(\\n            Transaction.id == transaction_id,\\n            Transaction.user_id == current_user.id,\\n            Transaction.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not transaction:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Transaction not found\\\"\\n        )\\n\\n    return transaction\\n\\n\\n@router.patch(\\\"/{transaction_id}\\\", response_model=TransactionResponse)\\nasync def update_transaction(\\n    transaction_id: UUID,\\n    transaction_data: TransactionUpdate,\\n    db: Session = Depends(get_db),\\n    cur\n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-17T01:22:24.123276+00:00",
  "updated_at": "2026-02-17T01:22:24.123276+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:8"
}