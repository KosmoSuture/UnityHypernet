{
  "address": "0.1.11.4.0.1.0.5.1",
  "type_address": null,
  "data": {
    "name": "1",
    "type": "folder",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\0\\5\\1",
    "content_preview": "{\n  \"address\": \"0.1.0.5.1\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"01-Object-Model-Specification.md\",\n    \"type\": \"file\",\n    \"extension\": \".md\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.0 - Planning & Documentation\\\\API-Design\\\\01-Object-Model-Specification.md\",\n    \"size\": 29023,\n    \"content\": \"# Hypernet Core - Object Model Specification\\n\\n**Version:** 0.1.0\\n**Last Updated:** 2026-02-03\\n**Status:** Design Phase\\n**Related:** Database-Design/, API endpoint specifications\\n\\n---\\n\\n## Table of Contents\\n\\n1. [Overview](#overview)\\n2. [Design Philosophy](#design-philosophy)\\n3. [Core Object Types](#core-object-types)\\n4. [Object Schema](#object-schema)\\n5. [Field Types and Validation](#field-types-and-validation)\\n6. [Metadata and Extensibility](#metadata-and-extensibility)\\n7. [Object Lifecycle](#object-lifecycle)\\n8. [Object Relationships](#object-relationships)\\n9. [Examples](#examples)\\n\\n---\\n\\n## Overview\\n\\nThe Hypernet object model defines how all data is structured, stored, and accessed through the API. It uses a **hybrid approach** combining:\\n\\n- **Structured core fields** (predictable, queryable, performant)\\n- **Flexible metadata** (integration-specific, extensible)\\n- **First-class links** (relationships as objects, see Link Model spec)\\n\\nThis design balances:\\n- \\u2705 **Performance** - Core fields indexed and optimized\\n- \\u2705 **Flexibility** - New integrations don't require schema changes\\n- \\u2705 **Queryability** - Can filter/search by common attributes\\n- \\u2705 **Type Safety** - Strong typing in API and database\\n\\n---\\n\\n## Design Philosophy\\n\\n### Principles\\n\\n1. **Hybrid Schema**\\n   - Core fields are strongly typed and validated\\n   - Integration-specific data stored in `metadata` JSON field\\n   - Balance structure and flexibility\\n\\n2. **Immutable IDs**\\n   - Every object has a unique, immutable UUID\\n   - UUIDs are globally unique (can merge databases later)\\n   - Never reused, even after deletion\\n\\n3. **Ownership and Isolation**\\n   - Every object (except User) belongs to a single user\\n   - Users can only access their own objects (enforced at API + DB level)\\n   - Multi-tenancy via `user_id` foreign key\\n\\n4. **Audit Trail**\\n   - All objects have `created_at`, `updated_at` timestamps\\n   - Deletions are soft by default (marked `deleted_at`, not removed)\\n   - Can reconstruct history of changes\\n\\n5. **Source Tracking**\\n   - Objects created via integrations track their source\\n   - `source_type` and `source_id` fields link back to original\\n   - Enables sync, deduplication, and provenance\\n\\n6. **Extensibility**\\n   - New object types can be added without breaking existing code\\n   - `metadata` field allows arbitrary additional data\\n   - Plugin architecture for type-specific behavior\\n\\n---\\n\\n## Core Object Types\\n\\n### Phase 1 Object Types\\n\\nThese are the minimum object types for Phase 1 (0.1.0):\\n\\n| Object Type | Purpose | Examples |\\n|-------------|---------|----------|\\n| **User** | Account, authentication, ownership | user@example.com |\\n| **Media** | Photos, videos, files | IMG_1234.jpg, video.mp4 |\\n| **Album** | Collections of media | \\\"Vacation 2025\\\", \\\"Family Photos\\\" |\\n| **Integration** | Connected external services | Instagram account, Google Photos |\\n| **Link** | Relationships between objects | Photo \\u2192 Instagram Post, Photo \\u2192 Album |\\n\\n### Phase 2+ Object Types (Future)\\n\\nNot implemented in Phase 1, but design should accommodate:\\n\\n| Object Type | Purpose | Examples |\\n|-------------|---------|----------|\\n| **Post** | Social media posts | Tweet, Facebook post, Instagram story |\\n| **Message** | Communications | Email, SMS, chat message |\\n| **Contact** | People | Friends, family, colleagues |\\n| **Event** | Calendar events | Birthday, meeting, vacation |\\n| **Location** | Places | GPS coordinates, addresses |\\n| **Tag** | User-defined labels | #vacation, #family, #work |\\n\\n---\\n\\n## Object Schema\\n\\n### Base Object\\n\\nAll objects inherit these common fields:\\n\\n```python\\nclass BaseObject:\\n    \\\"\\\"\\\"Base class for all Hypernet objects\\\"\\\"\\\"\\n\\n    # Identity\\n    id: UUID                    # Unique identifier (UUIDv4)\\n    type: str                   # Object type (\\\"media\\\", \\\"album\\\", etc.)\\n\\n    # Ownership\\n    user_id: UUID               # Owner (foreign key to User)\\n\\n    # Timestamps\\n    created_at: datetime        # When created (UTC, ISO 8601)\\n    updated_at: datetime        # Last modified (UTC, ISO 8601)\\n    deleted_at: datetime | None # Soft delete timestamp (null if not deleted)\\n\\n    # Source Tracking\\n    source_type: str | None     # Where it came from (\\\"integration\\\", \\\"upload\\\", \\\"system\\\")\\n    source_id: str | None       # ID in source system (e.g., Instagram post ID)\\n\\n    # Extensibility\\n    metadata: dict              # JSON object for additional fields\\n```\\n\\n### User Object\\n\\n```python\\nclass User(BaseObject):\\n    \\\"\\\"\\\"User account and authentication\\\"\\\"\\\"\\n\\n    type: str = \\\"user\\\"          # Always \\\"user\\\"\\n\\n    # Authentication\\n    email: str                  # Email address (unique, indexed)\\n    password_hash: str          # bcrypt or argon2 hash\\n    email_verified: bool        # Email verification status\\n\\n    # Profile\\n    display_name: str | None    # Display name (optional)\\n    avatar_url: str | None      # Profile picture URL (optional)\\n\\n    # Account Status\\n    is_active: bool             # Account enabled/disabled\\n    is_admin: bool              # Admin privileges\\n\\n    # Timestamps (inherited from BaseObject)\\n    created_at: datetime        # Account creation\\n    updated_at: datetime        # Last profile update\\n    last_login_at: datetime     # Last successful login\\n\\n    # Quotas and Limits\\n    storage_used: int           # Bytes used (for photos/videos)\\n    storage_quota: int          # Bytes allowed (default: 10 GB)\\n\\n    # Metadata\\n    metadata: dict              # User preferences, settings, etc.\\n```\\n\\n**Validation:**\\n- `email`: Valid email format, unique across all users\\n- `password`: Min 12 chars, complexity requirements (enforced at API level)\\n- `display_name`: Max 100 chars, no special characters\\n- `storage_quota`: Min 1GB, max 1TB (configurable)\\n\\n**Indexes:**\\n- Primary key: `id`\\n- Unique: `email`\\n- Index: `created_at` (for user stats)\\n\\n---\\n\\n### Media Object\\n\\n```python\\nclass Media(BaseObject):\\n    \\\"\\\"\\\"Photos, videos, and other media files\\\"\\\"\\\"\\n\\n    type: str = \\\"media\\\"         # Always \\\"media\\\"\\n\\n    # Basic Info\\n    filename: str               # Original filename\\n    media_type: str             # \\\"photo\\\", \\\"video\\\", \\\"document\\\", \\\"other\\\"\\n    mime_type: str              # MIME type (image/jpeg, video/mp4, etc.)\\n\\n    # File Information\\n    size: int                   # File size in bytes\\n    width: int | None           # Image/video width in pixels\\n    height: int | None          # Image/video height in pixels\\n    duration: float | None      # Video duration in seconds\\n\\n    # Storage\\n    file_path: str              # Path in /media partition (relative)\\n    thumbnail_path: str | None  # Path to thumbnail (if generated)\\n    hash: str                   # SHA-256 hash of file (for deduplication)\\n\\n    # Dates and Location\\n    taken_at: datetime | None   # When photo/video was taken (from EXIF)\\n    latitude: float | None      # GPS latitude (from EXIF)\\n    longitude: float | None     # GPS longitude (from EXIF)\\n\\n    # Source Tracking (inherited, but commonly used)\\n    source_type: str | None     # \\\"upload\\\", \\\"integration\\\", \\\"import\\\"\\n    source_id: str | None       # External ID (e.g., Instagram media ID)\\n\\n    # Processing Status\\n    processing_status: str      # \\\"pending\\\", \\\"processing\\\", \\\"complete\\\", \\\"failed\\\"\\n    thumbnail_generated: bool   # Has thumbnail been created?\\n    metadata_extracted: bool    # Has EXIF/metadata been extracted?\\n\\n    # Metadata (EXIF and more)\\n    metadata: dict              # {\\n                                #   \\\"exif\\\": {...},          # EXIF data\\n                                #   \\\"camera\\\": \\\"iPhone 15\\\",  # Camera model\\n                                #   \\\"tags\\\": [\\\"vacation\\\"],   # User tags\\n                                #   \\\"description\\\": \\\"...\\\",   # User description\\n                                #   \\\"integration_data\\\": {...} # Integration-specific\\n                                # }\\n```\\n\\n**Validation:**\\n- `filename`: Max 255 chars, valid filename chars\\n- `media_type`: One of [\\\"photo\\\", \\\"video\\\", \\\"document\\\", \\\"other\\\"]\\n- `mime_type`: Valid MIME type from allowed list\\n- `size`: Max 100MB for photos, 1GB for videos (configurable)\\n- `hash`: Valid SHA-256 hash (64 hex chars)\\n- `latitude`: -90 to 90\\n- `longitude`: -180 to 180\\n- `processing_status`: One of [\\\"pending\\\", \\\"processing\\\", \\\"complete\\\", \\\"failed\\\"]\\n\\n**Indexes:**\\n- Primary key: `id`\\n- Foreign key: `user_id` (with index)\\n- Index: `hash` (for deduplication)\\n- Index: `taken_at` (for timeline queries)\\n- Index: `media_type` (for filtering)\\n- Composite: `(user_id, source_type, source_id)` (for sync deduplication)\\n\\n**File Path Convention:**\\n```\\n/media/users/{user_id}/media/{year}/{month}/{id}.{ext}\\nExample: /media/users/a1b2c3d4-1234-5678-abcd-123456789abc/media/2026/02/e5f6g7h8-5678-90ab-cdef-567890abcdef.jpg\\n```\\n\\n---\\n\\n### Album Object\\n\\n```python\\nclass Album(BaseObject):\\n    \\\"\\\"\\\"Collection of media objects\\\"\\\"\\\"\\n\\n    type: str = \\\"album\\\"         # Always \\\"album\\\"\\n\\n    # Basic Info\\n    name: str                   # Album name\\n    description: str | None     # Album description (optional)\\n\\n    # Display\\n    cover_media_id: UUID | None # Media object to use as cover (foreign key)\\n    sort_order: str             # \\\"date_asc\\\", \\\"date_desc\\\", \\\"manual\\\"\\n\\n    # Counts (denormalized for performance)\\n    media_count: int            # Number of media in album (cached)\\n\\n    # Privacy (Phase 2)\\n    \n... [truncated]",
    "content_file": "node.json"
  },
  "created_at": "2026-02-17T01:22:21.990697+00:00",
  "updated_at": "2026-02-17T01:22:21.990697+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "folder:1"
}