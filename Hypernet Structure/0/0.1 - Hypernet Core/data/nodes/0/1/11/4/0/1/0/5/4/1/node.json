{
  "address": "0.1.11.4.0.1.0.5.4.1",
  "type_address": null,
  "data": {
    "name": "node.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\0\\5\\4\\node.json",
    "size": 12480,
    "content": "{\n  \"address\": \"0.1.0.5.4\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"README.md\",\n    \"type\": \"file\",\n    \"extension\": \".md\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.0 - Planning & Documentation\\\\API-Design\\\\README.md\",\n    \"size\": 11700,\n    \"content\": \"# API Design Documentation\\n\\n## Overview\\n\\nThis directory contains the complete API design specification for Hypernet Core 0.1, including object models, link semantics, and RESTful endpoint definitions.\\n\\n---\\n\\n## Documents\\n\\n### 1. Object Model Specification (27KB)\\n**File:** `01-Object-Model-Specification.md`\\n\\nDefines all object types, their fields, validation rules, and lifecycle.\\n\\n**Object Types:**\\n- **User** - Account and authentication\\n- **Media** - Photos, videos, files\\n- **Album** - Collections of media\\n- **Integration** - Connected external services\\n- **Link** - Relationships between objects\\n\\n**Key Decisions:**\\n- \\u2705 Hybrid schema (core fields + JSON metadata)\\n- \\u2705 Immutable UUIDs for all objects\\n- \\u2705 Soft deletes by default\\n- \\u2705 Source tracking for all objects\\n- \\u2705 Audit timestamps (created_at, updated_at, deleted_at)\\n\\n### 2. Link Model Specification (22KB)\\n**File:** `02-Link-Model-Specification.md`\\n\\nDefines how relationships work as first-class objects.\\n\\n**Link Types (Phase 1):**\\n- `contains` - Album \\u2192 Media, Album \\u2192 Album\\n- `source` - Media \\u2192 Integration\\n- `duplicate_of` - Media \\u2194 Media\\n- `variant_of` - Media \\u2192 Media (thumbnails, edits)\\n\\n**Key Features:**\\n- \\u2705 First-class link objects (not just foreign keys)\\n- \\u2705 Directional with bidirectional support\\n- \\u2705 Strength/confidence scores (0.0 to 1.0)\\n- \\u2705 Ordered relationships (sort_order)\\n- \\u2705 Rich metadata on relationships\\n\\n### 3. API Endpoints (28KB)\\n**File:** `03-API-Endpoints.md`\\n\\nComplete RESTful API specification with all endpoints.\\n\\n**Endpoint Groups:**\\n- **Auth** - Register, login, refresh, logout\\n- **Users** - Profile management\\n- **Media** - Upload, list, get, download, thumbnail, update, delete\\n- **Albums** - Create, list, get, update, delete, add/remove media\\n- **Integrations** - Connect, sync, disconnect\\n- **Links** - Create, list, update, delete\\n- **System** - Health, version, metrics\\n\\n**Total Endpoints:** ~30 endpoints across 7 resource types\\n\\n---\\n\\n## API Design Principles\\n\\n1. **RESTful** - Resources, HTTP methods, standard status codes\\n2. **Versioned** - `/api/v1/...` allows future evolution\\n3. **JSON** - All request/response bodies (except file uploads)\\n4. **Stateless** - JWT tokens, no server sessions\\n5. **Paginated** - Offset and cursor pagination\\n6. **Filterable & Sortable** - Query parameters for filtering/sorting\\n7. **Secure** - Input validation, authentication, authorization, rate limiting\\n\\n---\\n\\n## Key Architectural Decisions\\n\\n### Hybrid Object Model\\n\\n**Problem:** How to balance structure and flexibility?\\n\\n**Solution:** Core fields + JSON metadata\\n- Common fields (id, user_id, created_at) are strongly typed\\n- Integration-specific data in flexible `metadata` JSONB column\\n- Best of both: performant queries + extensibility\\n\\n### First-Class Links\\n\\n**Problem:** How to represent relationships?\\n\\n**Solution:** Links as objects (not just foreign keys)\\n- Media can be in multiple albums (many-to-many)\\n- Rich metadata on relationships (when added, why, confidence)\\n- Enables graph queries and complex relationships\\n\\n### Source Tracking\\n\\n**Problem:** How to prevent duplicate imports?\\n\\n**Solution:** Every object tracks its source\\n- `source_type` and `source_id` fields\\n- Links connect media to integrations\\n- Deduplication by checking existing source links\\n\\n### Soft Deletes\\n\\n**Problem:** How to handle accidental deletions?\\n\\n**Solution:** Soft delete by default\\n- Set `deleted_at` timestamp instead of removing\\n- Can be restored by admin\\n- Permanently deleted after retention period (30 days)\\n\\n---\\n\\n## Object Relationships\\n\\n```\\nUser\\n \\u251c\\u2500\\u2500 owns \\u2192 Media (1:N)\\n \\u251c\\u2500\\u2500 owns \\u2192 Album (1:N)\\n \\u251c\\u2500\\u2500 owns \\u2192 Integration (1:N)\\n \\u2514\\u2500\\u2500 owns \\u2192 Link (1:N)\\n\\nAlbum\\n \\u251c\\u2500\\u2500 contains \\u2192 Media (via Link, M:N)\\n \\u251c\\u2500\\u2500 contains \\u2192 Album (via Link, nested)\\n \\u2514\\u2500\\u2500 has cover \\u2192 Media (foreign key)\\n\\nMedia\\n \\u251c\\u2500\\u2500 in \\u2192 Album (via Link, M:N)\\n \\u251c\\u2500\\u2500 sourced from \\u2192 Integration (via Link)\\n \\u251c\\u2500\\u2500 duplicate of \\u2192 Media (via Link, bidirectional)\\n \\u2514\\u2500\\u2500 variant of \\u2192 Media (via Link, thumbnails/edits)\\n\\nIntegration\\n \\u2514\\u2500\\u2500 sourced \\u2192 Media (via Link, 1:N)\\n```\\n\\n---\\n\\n## Data Flow Examples\\n\\n### Upload Photo\\n```\\n1. POST /api/v1/media/upload (multipart)\\n2. Validate file, scan malware\\n3. Generate UUID, extract EXIF\\n4. Save to /media/{user_id}/media/{year}/{month}/{id}.jpg\\n5. Generate thumbnails (async)\\n6. Insert Media object to database\\n7. Return Media object JSON\\n```\\n\\n### Add Photo to Album\\n```\\n1. POST /api/v1/albums/{album_id}/media\\n2. Validate album and media exist, user owns both\\n3. Create Link object (album \\u2192 media, type \\\"contains\\\")\\n4. Update album.media_count (denormalized)\\n5. Return Link object\\n```\\n\\n### Sync from Instagram\\n```\\n1. POST /api/v1/integrations/{id}/sync\\n2. Fetch items from Instagram API (paginated)\\n3. For each item:\\n   a. Check if Link exists (media \\u2192 integration, source_id)\\n   b. If exists, skip (already imported)\\n   c. If new, download media, create Media object\\n   d. Create Link (media \\u2192 integration, type \\\"source\\\")\\n4. Update integration sync state (cursor, last_sync_at)\\n5. Return sync status\\n```\\n\\n---\\n\\n## API Authentication Flow\\n\\n### Registration\\n```\\nPOST /api/v1/auth/register\\n  {email, password, display_name}\\n\\u2192 Create User object\\n\\u2192 Return {user, access_token, refresh_token}\\n```\\n\\n### Login\\n```\\nPOST /api/v1/auth/login\\n  {email, password}\\n\\u2192 Verify password\\n\\u2192 Generate access_token (15min) + refresh_token (30days)\\n\\u2192 Return {user, access_token, refresh_token}\\n```\\n\\n### API Request\\n```\\nGET /api/v1/media\\n  Authorization: Bearer {access_token}\\n\\u2192 Verify JWT signature\\n\\u2192 Extract user_id from token\\n\\u2192 Query media WHERE user_id = {user_id} AND deleted_at IS NULL\\n\\u2192 Return {items, total, pagination}\\n```\\n\\n### Token Refresh\\n```\\nPOST /api/v1/auth/refresh\\n  {refresh_token}\\n\\u2192 Verify refresh_token\\n\\u2192 Generate new access_token\\n\\u2192 Return {access_token}\\n```\\n\\n---\\n\\n## Validation & Security\\n\\n### Input Validation\\n\\nAll inputs validated using Pydantic models:\\n\\n```python\\nclass MediaUploadRequest(BaseModel):\\n    file: UploadFile\\n    description: str | None = None\\n    tags: list[str] = []\\n\\n    @validator('tags')\\n    def validate_tags(cls, v):\\n        if len(v) > 50:\\n            raise ValueError('Max 50 tags')\\n        return v\\n```\\n\\n### Authorization\\n\\nEvery endpoint checks:\\n1. **Authentication:** Valid JWT token?\\n2. **Ownership:** Does user own this resource?\\n3. **Permission:** Does user have required permission?\\n\\n```python\\nasync def get_media(media_id: UUID, user: User = Depends(get_current_user)):\\n    media = db.query(Media).filter(Media.id == media_id).first()\\n    if not media:\\n        raise HTTPException(404, \\\"Not found\\\")\\n    if media.user_id != user.id and not user.is_admin:\\n        raise HTTPException(403, \\\"Forbidden\\\")\\n    return media\\n```\\n\\n### Rate Limiting\\n\\nPer-user rate limits enforced via Redis:\\n\\n```python\\nRATE_LIMITS = {\\n    \\\"/api/v1/media/upload\\\": \\\"10/minute\\\",  # Max 10 uploads per minute\\n    \\\"/api/v1/auth/login\\\": \\\"5/minute\\\",     # Max 5 login attempts\\n    \\\"/api/v1/*\\\": \\\"1000/hour\\\",             # Global limit\\n}\\n```\\n\\n---\\n\\n## Database Schema Preview\\n\\n**Users Table:**\\n```sql\\nCREATE TABLE users (\\n    id UUID PRIMARY KEY,\\n    email VARCHAR(255) UNIQUE NOT NULL,\\n    password_hash VARCHAR(255) NOT NULL,\\n    display_name VARCHAR(100),\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    ...\\n);\\n```\\n\\n**Media Table:**\\n```sql\\nCREATE TABLE media (\\n    id UUID PRIMARY KEY,\\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\\n    filename VARCHAR(255) NOT NULL,\\n    media_type VARCHAR(50) NOT NULL,\\n    file_path VARCHAR(1024) NOT NULL,\\n    hash VARCHAR(64) NOT NULL,\\n    metadata JSONB,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    deleted_at TIMESTAMP WITH TIME ZONE,\\n    ...\\n);\\n\\nCREATE INDEX idx_media_user ON media(user_id) WHERE deleted_at IS NULL;\\nCREATE INDEX idx_media_hash ON media(hash);\\n```\\n\\n**Links Table:**\\n```sql\\nCREATE TABLE links (\\n    id UUID PRIMARY KEY,\\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\\n    from_object_id UUID NOT NULL,\\n    from_object_type VARCHAR(50) NOT NULL,\\n    to_object_id UUID NOT NULL,\\n    to_object_type VARCHAR(50) NOT NULL,\\n    link_type VARCHAR(50) NOT NULL,\\n    strength FLOAT DEFAULT 1.0,\\n    sort_order INTEGER,\\n    metadata JSONB,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    deleted_at TIMESTAMP WITH TIME ZONE,\\n    ...\\n);\\n\\nCREATE INDEX idx_links_from ON links(from_object_id, link_type) WHERE deleted_at IS NULL;\\nCREATE INDEX idx_links_to ON links(to_object_id, link_type) WHERE deleted_at IS NULL;\\nCREATE UNIQUE INDEX idx_links_unique ON links(from_object_id, to_object_id, link_type) WHERE deleted_at IS NULL;\\n```\\n\\n**Full schema:** See `Database-Design/` folder\\n\\n---\\n\\n## Implementation Checklist\\n\\n### Phase 1 - Core API (Weeks 3-5)\\n\\n- [ ] Set up FastAPI project structure\\n- [ ] Implement Pydantic models for request/response validation\\n- [ ] Implement SQLAlchemy ORM models\\n- [ ] Create database migrations (Alembic)\\n- [ ] Implement authentication (JWT)\\n- [ ] Implement authorization middleware\\n- [ ] Implement rate limiting\\n- [ ] Add input validation and sanitization\\n- [ ] Set up error handling (RFC 7807 Problem Details)\\n- [ ] Generate OpenAPI/Swagger docs (auto from FastAPI)\\n\\n### Phase 2 - Media Endpoints (Weeks 6-8)\\n\\n- [ ] Implement file upload handling (multipart/form-data)\\n- [ ] Add EXIF extraction (exifread or pillow)\\n- [ ] Implement malware scanning (ClamAV)\\n- [ ] Add thumbnail generation (Pillow or ImageMagick)\\n- [ ] Implement file download/streaming\\n- [ ] Add pagination helpers\\n- [ ] Implement filtering and sorting\\n- [ ] Write tests for all media endpoints\\n\\n### Phase 3 - Integration Endpoints (Weeks 9-11)\\n\\n- [ ] Implement OAuth2 flow (Google Photos or Instagram)\\n- [ ] Create integration plugin architecture\\n- [ ] Implement sync logic (incremental + full)\\n- [ ] Add deduplication (check existing source links)\\n- [ ] Handle rate limiting from external APIs\\n- [ ] Implement background job system (Celery or RQ)\\n- [ ] Write tests for integration sync\\n\\n### Phase 4 - API Documentation (Week 12)\\n\\n- [ ] Review auto-generated OpenAPI spec\\n- [ ] Add examples to all endpoints\\n- [ ] Write API usage guide\\n- [ ] Set up Swagger UI\\n- [ ] Set up ReDoc\\n- [ ] Create Postman collection\\n\\n---\\n\\n## Open Questions\\n\\n1. **GraphQL in Phase 2?**\\n   - REST is sufficient for Phase 1\\n   - GraphQL could simplify complex queries (get album + media + links in one request)\\n   - Defer decision to Phase 2\\n\\n2. **Webhooks for integrations?**\\n   - Some integrations support webhooks (Instagram, Facebook)\\n   - Could enable real-time sync instead of polling\\n   - Defer to Phase 2\\n\\n3. **Batch operations?**\\n   - Bulk upload, bulk delete, bulk tag?\\n   - Could improve efficiency\\n   - Defer to Phase 2 if needed\\n\\n4. **API versioning strategy?**\\n   - Currently `/api/v1/...`\\n   - When to bump to v2? Only for breaking changes\\n   - Maintain v1 for how long? (1 year minimum)\\n\\n---\\n\\n## Next Steps\\n\\n1. \\u2705 Complete API design (this folder)\\n2. \\ud83d\\udd04 Design database schema (see `Database-Design/`)\\n3. \\u23f3 Implement API in FastAPI\\n4. \\u23f3 Write integration tests\\n5. \\u23f3 Deploy and test\\n\\n---\\n\\n**Status:** API design complete, ready for implementation\\n**Completion:** ~75KB of detailed specification across 3 documents\\n**Next Critical Step:** Database schema design\\n\"\n  },\n  \"created_at\": \"2026-02-17T01:21:58.244477+00:00\",\n  \"updated_at\": \"2026-02-17T01:21:58.244477+00:00\",\n  \"deleted_at\": null,\n  \"source_type\": \"import\",\n  \"source_id\": \"file:README.md\"\n}"
  },
  "created_at": "2026-02-17T01:22:22.189327+00:00",
  "updated_at": "2026-02-17T01:22:22.189327+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.json"
}