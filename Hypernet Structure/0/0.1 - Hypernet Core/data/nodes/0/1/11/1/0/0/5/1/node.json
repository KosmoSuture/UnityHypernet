{
  "address": "0.1.11.1.0.0.5.1",
  "type_address": null,
  "data": {
    "name": "v0001.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\history\\0\\0\\5\\v0001.json",
    "size": 6840,
    "content": "{\n  \"version\": 1,\n  \"content_hash\": \"1fbe91668928f865\",\n  \"snapshot_at\": \"2026-02-17T01:21:58.217478+00:00\",\n  \"node\": {\n    \"address\": \"0.0.5\",\n    \"type_address\": null,\n    \"data\": {\n      \"name\": \"ADDRESSING-IMPLEMENTATION-SPEC.md\",\n      \"type\": \"file\",\n      \"extension\": \".md\",\n      \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.0 Metadata for Hypernet Information\\\\ADDRESSING-IMPLEMENTATION-SPEC.md\",\n      \"size\": 6076,\n      \"content\": \"# Hypernet Addressing \\u2014 Implementation Specification\\n\\n**Version:** 2.0\\n**Author:** Trace (2.1), building on Matt's v1.0 specification\\n**Date:** 2026-02-15\\n**Purpose:** Formal rules for the `hypernet.address` module, bridging the design spec (HYPERNET-ADDRESSING-SYSTEM.md) and Loom's implementation (`0.1 - Hypernet Core/hypernet/address.py`)\\n\\n---\\n\\n## Address Format\\n\\n### Syntax\\n\\n```\\nADDRESS     ::= PART ('.' PART)*\\nPART        ::= ALPHANUM+\\nALPHANUM    ::= [a-zA-Z0-9]\\n```\\n\\nAn address is one or more dot-separated parts. Each part is a non-empty string of alphanumeric characters. There is no fixed maximum depth.\\n\\n### Examples\\n\\n| Address | Meaning | Depth |\\n|---------|---------|-------|\\n| `0` | Infrastructure root | 1 |\\n| `1.1` | Matt (person) | 2 |\\n| `2.1.27` | Boot Sequence (document in AI account) | 3 |\\n| `1.1.1.1.00001` | Matt's first photo (instance) | 5 |\\n| `0.6.1` | Person-to-person link type | 3 |\\n\\n### Category Allocation\\n\\n| Range | Category | Authority |\\n|-------|----------|-----------|\\n| `0.*` | Infrastructure & System Definitions | Core team (Matt + approved instances) |\\n| `1.*` | People (Humans) | Per-person ownership at depth 2 (e.g., 1.1 = Matt) |\\n| `2.*` | AI Entities | Per-account ownership at depth 2 (e.g., 2.1 = Claude Opus) |\\n| `3.*` | Businesses & Organizations | Per-org ownership at depth 2 |\\n| `4.*` | Knowledge & Information | Per-domain ownership at depth 2 |\\n| `5.*` | Reserved | TBD |\\n| `6.*` | Historical People | Per-person at depth 2 |\\n| `7+` | Future expansion | TBD |\\n\\n### Properties\\n\\n**Parent:** Remove the last part. `2.1.27` \\u2192 `2.1`. Root addresses have no parent.\\n\\n**Owner:** For categories 1-6, the first two parts identify the owner entity. `1.1.3.1.00001` is owned by `1.1`. For category 0, there is no owner (system-level).\\n\\n**Instance indicator:** An address ending in a zero-padded numeric part (length >= 5) is an instance node. `1.1.1.1.00001` is an instance. `2.1.27` is not.\\n\\n**Ancestry:** Address A is an ancestor of address B if B starts with A's parts. `1.1` is an ancestor of `1.1.1.1.00001`. An address is NOT its own ancestor.\\n\\n---\\n\\n## Version Addressing\\n\\nPer Matt's v1.0 spec (section \\\"Future Extensions: Temporal Versioning\\\"), version addressing uses the `@` separator:\\n\\n```\\nVERSION_REF ::= ADDRESS '@' VERSION_TAG\\nVERSION_TAG ::= 'v' [0-9]+ | 'latest'\\n```\\n\\n| Expression | Meaning |\\n|-----------|---------|\\n| `2.1.27@v1` | First version of the Boot Sequence |\\n| `2.1.27@v3` | Third version |\\n| `2.1.27@latest` | Current (most recent) version |\\n| `2.1.27` | Equivalent to `@latest` (unversioned = current) |\\n\\n### Storage Rule\\n\\nWhen a node is updated, the **previous** state is archived to the version history before the current state is overwritten. This produces:\\n\\n```\\nnodes/2/1/27/\\n  node.json              \\u2190 current state (@latest)\\n  history/\\n    v001.json            \\u2190 first version\\n    v002.json            \\u2190 second version (previous current)\\n```\\n\\n**Implementation note for Loom:** The `Store.put_node()` method should:\\n1. If node already exists: read current, write it to `history/vNNN.json`, increment version\\n2. Write new state to `node.json` with updated version number\\n3. Compute and store content hash for the new version\\n\\nVersion numbers are sequential, zero-padded to 3 digits. If more than 999 versions exist, extend padding.\\n\\n---\\n\\n## Rules for the Implementation\\n\\n### 1. Parsing\\n\\n- Empty strings and whitespace-only strings are invalid\\n- Leading/trailing dots are invalid (`\\\".1.1\\\"`, `\\\"1.1.\\\"`)\\n- Consecutive dots are invalid (`\\\"1..1\\\"`)\\n- Parts must be non-empty after splitting on `.`\\n\\n### 2. Comparison and Ordering\\n\\n- Addresses are compared lexicographically by parts tuple\\n- Numeric parts are compared as strings, NOT as integers (`\\\"00001\\\" < \\\"00002\\\"` works, but `\\\"9\\\" > \\\"10\\\"` \\u2014 this is acceptable because numeric parts are zero-padded by convention)\\n\\n### 3. Hashing and Equality\\n\\n- Two addresses are equal if and only if their parts tuples are equal\\n- Hash is based on the parts tuple (consistent with equality)\\n- Addresses are immutable (frozen dataclass)\\n\\n### 4. Link Addressing\\n\\nLinks are identified by a content hash of `from_address:to_address:relationship:created_at`. Adding `created_at` to the hash input allows multiple links of the same type between the same nodes (e.g., two separate \\\"disagrees_with\\\" links on different topics, created at different times).\\n\\n### 5. Path Mapping\\n\\nAddress-to-filesystem path conversion:\\n- Replace `.` with `/`\\n- Example: `2.1.27` \\u2192 `2/1/27/`\\n- Node data lives in `node.json` within that directory\\n- Instance data can optionally use `INSTANCE.json` instead of `INSTANCE/node.json` for leaf nodes\\n\\n---\\n\\n## Differences from v1.0 Spec\\n\\n| v1.0 Design | v2.0 Implementation |\\n|-------------|-------------------|\\n| Addresses are always integers | Parts are alphanumeric strings (supports named sub-categories like instance forks) |\\n| Fixed 5-level hierarchy | Variable depth, unbounded |\\n| SQL as storage option | File-backed JSON (Hypernet is its own database per Matt's directive) |\\n| UUID migration plan | No UUIDs ever \\u2014 HA is native from the start |\\n| Version addressing as \\\"future\\\" | Version addressing specified here for immediate implementation |\\n\\n---\\n\\n## Compatibility with Loom's Implementation\\n\\nLoom's `address.py` is largely compatible with this spec. Required changes:\\n\\n1. **Add version parsing** \\u2014 `HypernetAddress.parse(\\\"2.1.27@v2\\\")` should split on `@` and store version separately\\n2. **Add `version` property** \\u2014 returns the version tag or None for unversioned\\n3. **Reject invalid syntax** \\u2014 leading/trailing/consecutive dots\\n4. **Update `_link_hash`** \\u2014 include `created_at` in hash input\\n\\nEverything else (parent, owner, ancestry, is_instance, child, path conversion) is correct as-is.\\n\\n---\\n\\n*This spec is authoritative for the `hypernet` Python module. The v1.0 spec remains authoritative for the conceptual design and category definitions.*\\n\\n\\u2014 Trace, 2.1\\n\"\n    },\n    \"created_at\": \"2026-02-17T01:20:04.703165+00:00\",\n    \"updated_at\": \"2026-02-17T01:20:04.703165+00:00\",\n    \"deleted_at\": null,\n    \"source_type\": \"import\",\n    \"source_id\": \"file:ADDRESSING-IMPLEMENTATION-SPEC.md\"\n  }\n}"
  },
  "created_at": "2026-02-17T01:22:00.524572+00:00",
  "updated_at": "2026-02-17T01:22:00.524572+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:v0001.json"
}