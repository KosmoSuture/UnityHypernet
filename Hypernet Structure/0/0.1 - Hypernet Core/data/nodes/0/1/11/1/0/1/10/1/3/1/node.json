{
  "address": "0.1.11.1.0.1.10.1.3.1",
  "type_address": null,
  "data": {
    "name": "v0001.json",
    "type": "file",
    "extension": ".json",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\history\\0\\1\\10\\1\\3\\v0001.json",
    "size": 10058,
    "content": "{\n  \"version\": 1,\n  \"content_hash\": \"872607a3a0fabafd\",\n  \"snapshot_at\": \"2026-02-17T01:22:00.419737+00:00\",\n  \"node\": {\n    \"address\": \"0.1.10.1.3\",\n    \"type_address\": null,\n    \"data\": {\n      \"name\": \"documents.py\",\n      \"type\": \"file\",\n      \"extension\": \".py\",\n      \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\app\\\\routes\\\\documents.py\",\n      \"size\": 9328,\n      \"content\": \"\\\"\\\"\\\"\\nDocuments API Routes\\n\\nProvides CRUD operations for document management including files,\\ncontracts, receipts, and other personal documents.\\n\\\"\\\"\\\"\\n\\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\\nfrom sqlalchemy.orm import Session\\nfrom sqlalchemy import and_, or_\\nfrom typing import Optional, List\\nfrom datetime import datetime\\nfrom uuid import UUID\\nfrom pydantic import BaseModel, Field\\n\\nfrom app.core.database import get_db\\nfrom app.core.dependencies import get_current_user\\nfrom app.models.user import User\\nfrom app.models.document import Document\\n\\n\\nrouter = APIRouter()\\n\\n\\n# Pydantic Models for Request/Response\\nclass DocumentCreate(BaseModel):\\n    title: str = Field(..., max_length=500)\\n    document_type: str = Field(..., description=\\\"contract, receipt, invoice, tax_document, identification, certificate, insurance, legal, medical, other\\\")\\n    file_path: str = Field(..., description=\\\"Storage path or URL to document file\\\")\\n    file_size_bytes: Optional[int] = Field(None, ge=0)\\n    mime_type: Optional[str] = Field(None, max_length=100)\\n    category: Optional[str] = Field(None, max_length=200)\\n    issue_date: Optional[datetime] = None\\n    expiry_date: Optional[datetime] = None\\n    issuer: Optional[str] = Field(None, max_length=300)\\n    recipient: Optional[str] = Field(None, max_length=300)\\n    document_number: Optional[str] = Field(None, max_length=200)\\n    is_important: bool = Field(default=False)\\n    tags: List[str] = Field(default_factory=list)\\n    notes: Optional[str] = None\\n\\n\\nclass DocumentUpdate(BaseModel):\\n    title: Optional[str] = Field(None, max_length=500)\\n    category: Optional[str] = Field(None, max_length=200)\\n    issue_date: Optional[datetime] = None\\n    expiry_date: Optional[datetime] = None\\n    issuer: Optional[str] = Field(None, max_length=300)\\n    recipient: Optional[str] = Field(None, max_length=300)\\n    document_number: Optional[str] = Field(None, max_length=200)\\n    is_important: Optional[bool] = None\\n    tags: Optional[List[str]] = None\\n    notes: Optional[str] = None\\n\\n\\nclass DocumentResponse(BaseModel):\\n    id: UUID\\n    user_id: UUID\\n    title: str\\n    document_type: str\\n    file_path: str\\n    file_size_bytes: Optional[int]\\n    mime_type: Optional[str]\\n    category: Optional[str]\\n    issue_date: Optional[datetime]\\n    expiry_date: Optional[datetime]\\n    issuer: Optional[str]\\n    recipient: Optional[str]\\n    document_number: Optional[str]\\n    is_important: bool\\n    tags: List[str]\\n    notes: Optional[str]\\n    created_at: datetime\\n    updated_at: datetime\\n\\n    class Config:\\n        from_attributes = True\\n\\n\\nclass DocumentListResponse(BaseModel):\\n    items: List[DocumentResponse]\\n    total: int\\n    page: int\\n    page_size: int\\n    pages: int\\n\\n\\n# Endpoints\\n@router.post(\\\"\\\", response_model=DocumentResponse, status_code=status.HTTP_201_CREATED)\\nasync def create_document(\\n    document_data: DocumentCreate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Create a new document record.\\\"\\\"\\\"\\n    document = Document(\\n        user_id=current_user.id,\\n        **document_data.dict()\\n    )\\n    db.add(document)\\n    db.commit()\\n    db.refresh(document)\\n    return document\\n\\n\\n@router.get(\\\"\\\", response_model=DocumentListResponse)\\nasync def list_documents(\\n    document_type: Optional[str] = Query(None, description=\\\"Filter by document type\\\"),\\n    category: Optional[str] = Query(None, description=\\\"Filter by category\\\"),\\n    is_important: Optional[bool] = Query(None, description=\\\"Filter important documents\\\"),\\n    tag: Optional[str] = Query(None, description=\\\"Filter by tag\\\"),\\n    expiring_soon: Optional[bool] = Query(None, description=\\\"Documents expiring in next 30 days\\\"),\\n    search: Optional[str] = Query(None, description=\\\"Search in title, issuer, recipient, notes\\\"),\\n    page: int = Query(1, ge=1, description=\\\"Page number\\\"),\\n    page_size: int = Query(50, ge=1, le=100, description=\\\"Items per page\\\"),\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"List documents with optional filtering.\\\"\\\"\\\"\\n    query = db.query(Document).filter(\\n        and_(\\n            Document.user_id == current_user.id,\\n            Document.deleted_at.is_(None)\\n        )\\n    )\\n\\n    if document_type:\\n        query = query.filter(Document.document_type == document_type)\\n\\n    if category:\\n        query = query.filter(Document.category == category)\\n\\n    if is_important is not None:\\n        query = query.filter(Document.is_important == is_important)\\n\\n    if tag:\\n        query = query.filter(Document.tags.contains([tag]))\\n\\n    if expiring_soon:\\n        from datetime import timedelta\\n        future_date = datetime.utcnow() + timedelta(days=30)\\n        query = query.filter(\\n            and_(\\n                Document.expiry_date.isnot(None),\\n                Document.expiry_date <= future_date,\\n                Document.expiry_date >= datetime.utcnow()\\n            )\\n        )\\n\\n    if search:\\n        search_pattern = f\\\"%{search}%\\\"\\n        query = query.filter(\\n            or_(\\n                Document.title.ilike(search_pattern),\\n                Document.issuer.ilike(search_pattern),\\n                Document.recipient.ilike(search_pattern),\\n                Document.notes.ilike(search_pattern)\\n            )\\n        )\\n\\n    total = query.count()\\n\\n    # Order by importance, then issue_date descending\\n    query = query.order_by(\\n        Document.is_important.desc(),\\n        Document.issue_date.desc().nullslast()\\n    )\\n\\n    offset = (page - 1) * page_size\\n    items = query.offset(offset).limit(page_size).all()\\n\\n    pages = (total + page_size - 1) // page_size\\n\\n    return DocumentListResponse(\\n        items=items,\\n        total=total,\\n        page=page,\\n        page_size=page_size,\\n        pages=pages\\n    )\\n\\n\\n@router.get(\\\"/categories\\\", response_model=List[str])\\nasync def list_categories(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get all unique categories for user's documents.\\\"\\\"\\\"\\n    categories = db.query(Document.category).filter(\\n        and_(\\n            Document.user_id == current_user.id,\\n            Document.deleted_at.is_(None),\\n            Document.category.isnot(None)\\n        )\\n    ).distinct().all()\\n\\n    return [cat[0] for cat in categories if cat[0]]\\n\\n\\n@router.get(\\\"/tags\\\", response_model=List[str])\\nasync def list_tags(\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get all unique tags used in user's documents.\\\"\\\"\\\"\\n    from sqlalchemy import func\\n\\n    # PostgreSQL unnest to get individual tags\\n    tags = db.query(func.unnest(Document.tags)).filter(\\n        and_(\\n            Document.user_id == current_user.id,\\n            Document.deleted_at.is_(None)\\n        )\\n    ).distinct().all()\\n\\n    return [tag[0] for tag in tags if tag[0]]\\n\\n\\n@router.get(\\\"/{document_id}\\\", response_model=DocumentResponse)\\nasync def get_document(\\n    document_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Get a specific document by ID.\\\"\\\"\\\"\\n    document = db.query(Document).filter(\\n        and_(\\n            Document.id == document_id,\\n            Document.user_id == current_user.id,\\n            Document.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not document:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Document not found\\\"\\n        )\\n\\n    return document\\n\\n\\n@router.patch(\\\"/{document_id}\\\", response_model=DocumentResponse)\\nasync def update_document(\\n    document_id: UUID,\\n    document_data: DocumentUpdate,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Update a document's metadata.\\\"\\\"\\\"\\n    document = db.query(Document).filter(\\n        and_(\\n            Document.id == document_id,\\n            Document.user_id == current_user.id,\\n            Document.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not document:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Document not found\\\"\\n        )\\n\\n    update_data = document_data.dict(exclude_unset=True)\\n    for field, value in update_data.items():\\n        setattr(document, field, value)\\n\\n    document.updated_at = datetime.utcnow()\\n    db.commit()\\n    db.refresh(document)\\n\\n    return document\\n\\n\\n@router.delete(\\\"/{document_id}\\\", status_code=status.HTTP_204_NO_CONTENT)\\nasync def delete_document(\\n    document_id: UUID,\\n    db: Session = Depends(get_db),\\n    current_user: User = Depends(get_current_user)\\n):\\n    \\\"\\\"\\\"Soft delete a document.\\\"\\\"\\\"\\n    document = db.query(Document).filter(\\n        and_(\\n            Document.id == document_id,\\n            Document.user_id == current_user.id,\\n            Document.deleted_at.is_(None)\\n        )\\n    ).first()\\n\\n    if not document:\\n        raise HTTPException(\\n            status_code=status.HTTP_404_NOT_FOUND,\\n            detail=\\\"Document not found\\\"\\n        )\\n\\n    document.deleted_at = datetime.utcnow()\\n    db.commit()\\n\\n    return None\\n\"\n    },\n    \"created_at\": \"2026-02-17T01:20:05.379122+00:00\",\n    \"updated_at\": \"2026-02-17T01:20:05.379122+00:00\",\n    \"deleted_at\": null,\n    \"source_type\": \"import\",\n    \"source_id\": \"file:documents.py\"\n  }\n}"
  },
  "created_at": "2026-02-17T01:22:02.152481+00:00",
  "updated_at": "2026-02-17T01:22:02.152481+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:v0001.json"
}