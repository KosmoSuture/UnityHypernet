{
  "address": "0.1.14.12",
  "type_address": null,
  "data": {
    "name": "swarm.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\hypernet\\swarm.py",
    "size": 17767,
    "content": "\"\"\"\nHypernet Swarm Orchestrator\n\nThe main event loop that keeps the AI swarm running autonomously.\nAssigns tasks, executes them via workers, reports results, and repeats.\n\nMain loop:\n  1. Check for incoming messages from Matt\n  2. Check task queue for available work\n  3. If tasks available: claim \u2192 execute \u2192 complete \u2192 loop\n  4. If queue empty: generate tasks from standing priorities\n  5. Every N minutes: send status update to Matt\n  6. On error: log, notify Matt, try next task\n  7. On shutdown: save state, notify Matt\n\nState persists across restarts via data/swarm/state.json.\n\nUsage:\n  python -m hypernet.swarm --mock     # Test with simulated workers\n  python -m hypernet.swarm            # Live mode (needs ANTHROPIC_API_KEY)\n\"\"\"\n\nfrom __future__ import annotations\nimport argparse\nimport json\nimport logging\nimport os\nimport signal\nimport sys\nimport time\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom .address import HypernetAddress\nfrom .store import Store\nfrom .tasks import TaskQueue, TaskStatus, TaskPriority\nfrom .identity import IdentityManager, InstanceProfile, SessionLog\nfrom .worker import Worker, TaskResult\nfrom .messenger import (\n    Messenger, MultiMessenger, WebMessenger,\n    EmailMessenger, TelegramMessenger, Message,\n)\n\nlog = logging.getLogger(__name__)\n\n# Swarm orchestrator node address\nSWARM_ADDRESS = HypernetAddress.parse(\"0.7.2\")\n\n# Standing priorities when the queue is empty\nSTANDING_PRIORITIES = [\n    {\n        \"title\": \"Run tests and fix failures\",\n        \"description\": \"Run python test_hypernet.py, analyze any failures, and fix them.\",\n        \"priority\": \"high\",\n        \"tags\": [\"code\", \"testing\", \"automated\"],\n    },\n    {\n        \"title\": \"Review pending code changes\",\n        \"description\": \"Check for any unfinished code review items in Messages/2.1-internal/.\",\n        \"priority\": \"normal\",\n        \"tags\": [\"review\", \"automated\"],\n    },\n    {\n        \"title\": \"Update documentation\",\n        \"description\": \"Review and improve documentation for recent code changes.\",\n        \"priority\": \"low\",\n        \"tags\": [\"docs\", \"automated\"],\n    },\n]\n\n\nclass Swarm:\n    \"\"\"Orchestrator that manages AI workers and keeps them productive.\"\"\"\n\n    def __init__(\n        self,\n        store: Store,\n        identity_mgr: IdentityManager,\n        task_queue: TaskQueue,\n        messenger: Messenger,\n        workers: dict[str, Worker] = None,\n        state_dir: str | Path = \"data/swarm\",\n        status_interval_minutes: int = 120,\n    ):\n        self.store = store\n        self.identity_mgr = identity_mgr\n        self.task_queue = task_queue\n        self.messenger = messenger\n        self.workers: dict[str, Worker] = workers or {}\n        self.state_dir = Path(state_dir)\n        self.status_interval = status_interval_minutes * 60  # Convert to seconds\n\n        self._running = False\n        self._tick_count = 0\n        self._session_start: Optional[str] = None\n        self._tasks_completed = 0\n        self._tasks_failed = 0\n        self._last_status_time = 0.0\n        self._state: dict = {}\n\n        self.state_dir.mkdir(parents=True, exist_ok=True)\n\n    def run(self) -> None:\n        \"\"\"Main loop \u2014 runs until interrupted or shut down.\"\"\"\n        self._running = True\n        self._session_start = datetime.now(timezone.utc).isoformat()\n        self._load_state()\n\n        log.info(\"Swarm starting\")\n        log.info(f\"  Workers: {list(self.workers.keys())}\")\n        log.info(f\"  Status interval: {self.status_interval // 60} minutes\")\n\n        self.messenger.send(\n            f\"Swarm started with {len(self.workers)} worker(s): \"\n            f\"{', '.join(self.workers.keys())}. \"\n            f\"Checking for tasks...\"\n        )\n\n        try:\n            while self._running:\n                self.tick()\n                time.sleep(2)  # Brief pause between ticks\n        except KeyboardInterrupt:\n            log.info(\"Keyboard interrupt received\")\n        finally:\n            self.shutdown()\n\n    def tick(self) -> None:\n        \"\"\"Single iteration of the main loop.\"\"\"\n        self._tick_count += 1\n\n        # 1. Check for incoming messages from Matt\n        self._handle_incoming_messages()\n\n        # 2. Check task queue and assign work\n        tasks_done = False\n        for name, worker in self.workers.items():\n            if self.assign_next_task(worker):\n                tasks_done = True\n\n        # 3. If queue was empty, generate tasks from standing priorities\n        if not tasks_done:\n            available = self.task_queue.get_available_tasks()\n            if not available:\n                self.generate_tasks()\n\n        # 4. Periodic status update\n        now = time.time()\n        if now - self._last_status_time >= self.status_interval:\n            report = self.status_report()\n            self.messenger.send_update(\"Swarm Status Report\", report)\n            self._last_status_time = now\n\n        # 5. Save state periodically\n        if self._tick_count % 30 == 0:  # Every ~60 seconds\n            self._save_state()\n\n    def assign_next_task(self, worker: Worker) -> bool:\n        \"\"\"Find and execute the next available task for a worker.\n\n        Returns True if a task was executed.\n        \"\"\"\n        available = self.task_queue.get_available_tasks()\n        if not available:\n            return False\n\n        task_node = available[0]\n        task_addr = task_node.address\n        worker_addr = HypernetAddress.parse(worker.identity.address)\n\n        # Claim\n        if not self.task_queue.claim_task(task_addr, worker_addr):\n            log.warning(f\"Failed to claim task {task_addr}\")\n            return False\n\n        # Start\n        self.task_queue.start_task(task_addr)\n        log.info(f\"Worker {worker.identity.name} starting task: {task_node.data.get('title')}\")\n\n        # Execute\n        task_data = dict(task_node.data)\n        task_data[\"_address\"] = str(task_addr)\n        result = worker.execute_task(task_data)\n\n        # Handle result\n        self.handle_completion(worker, task_addr, result)\n        return True\n\n    def handle_completion(self, worker: Worker, task_addr: HypernetAddress, result: TaskResult) -> None:\n        \"\"\"Process a task result \u2014 complete or fail, notify, pick next.\"\"\"\n        if result.success:\n            self.task_queue.complete_task(task_addr, result.output[:500])\n            self._tasks_completed += 1\n            log.info(f\"Task {task_addr} completed by {worker.identity.name}\")\n\n            self.messenger.send(\n                f\"Task completed by {worker.identity.name}: \"\n                f\"{result.output[:200]}...\"\n            )\n        else:\n            self.task_queue.fail_task(task_addr, result.error or \"Unknown error\")\n            self._tasks_failed += 1\n            log.error(f\"Task {task_addr} failed: {result.error}\")\n\n            self.messenger.send_update(\n                f\"Task Failed \u2014 {worker.identity.name}\",\n                f\"Error: {result.error}\\n\\nTask address: {task_addr}\",\n            )\n\n    def generate_tasks(self) -> list:\n        \"\"\"Generate tasks from standing priorities when the queue is empty.\"\"\"\n        created = []\n        for priority_def in STANDING_PRIORITIES:\n            # Check if a similar task already exists (by title)\n            existing = self.store.list_nodes(\n                prefix=HypernetAddress.parse(\"0.7.1\"),\n            )\n            already_exists = any(\n                n.data.get(\"title\") == priority_def[\"title\"]\n                and n.data.get(\"status\") in (\"pending\", \"claimed\", \"in_progress\")\n                for n in existing\n            )\n            if already_exists:\n                continue\n\n            task = self.task_queue.create_task(\n                title=priority_def[\"title\"],\n                description=priority_def[\"description\"],\n                priority=TaskPriority[priority_def[\"priority\"].upper()],\n                created_by=SWARM_ADDRESS,\n                tags=priority_def.get(\"tags\", []),\n            )\n            created.append(task)\n            log.info(f\"Auto-generated task: {priority_def['title']}\")\n\n        return created\n\n    def status_report(self) -> str:\n        \"\"\"Generate a status report for Matt.\"\"\"\n        uptime = \"unknown\"\n        if self._session_start:\n            ts = self._session_start.replace(\"Z\", \"+00:00\")\n            start = datetime.fromisoformat(ts)\n            delta = datetime.now(timezone.utc) - start\n            hours = delta.total_seconds() / 3600\n            uptime = f\"{hours:.1f} hours\"\n\n        available = self.task_queue.get_available_tasks()\n        worker_info = []\n        for name, w in self.workers.items():\n            worker_info.append(f\"  - {name}: {w.model} ({'mock' if w.mock else 'live'}), {w.tokens_used} tokens\")\n\n        return (\n            f\"Uptime: {uptime}\\n\"\n            f\"Ticks: {self._tick_count}\\n\"\n            f\"Tasks completed: {self._tasks_completed}\\n\"\n            f\"Tasks failed: {self._tasks_failed}\\n\"\n            f\"Tasks pending: {len(available)}\\n\"\n            f\"\\nWorkers:\\n\" + \"\\n\".join(worker_info) +\n            f\"\\n\\nTimestamp: {datetime.now(timezone.utc).isoformat()}\"\n        )\n\n    def shutdown(self) -> None:\n        \"\"\"Graceful shutdown \u2014 save state, log sessions, notify Matt.\"\"\"\n        self._running = False\n        log.info(\"Swarm shutting down\")\n\n        # Save session logs for each worker\n        for name, worker in self.workers.items():\n            session = SessionLog(\n                instance=name,\n                started_at=self._session_start or datetime.now(timezone.utc).isoformat(),\n                ended_at=datetime.now(timezone.utc).isoformat(),\n                tokens_used=worker.tokens_used,\n                summary=f\"Completed {self._tasks_completed} tasks, {self._tasks_failed} failures\",\n            )\n            self.identity_mgr.save_session_log(name, session)\n\n        # Save swarm state\n        self._save_state()\n\n        # Notify Matt\n        self.messenger.send_update(\n            \"Swarm Shutdown\",\n            self.status_report(),\n        )\n        log.info(\"Swarm stopped\")\n\n    def _handle_incoming_messages(self) -> None:\n        \"\"\"Process any new messages from Matt.\"\"\"\n        messages = self.messenger.check_incoming()\n        for msg in messages:\n            log.info(f\"Incoming message from {msg.sender}: {msg.content[:100]}\")\n\n            content = msg.content.strip().lower()\n\n            if content == \"/status\":\n                self.messenger.send(self.status_report())\n            elif content == \"/stop\":\n                self.messenger.send(\"Shutting down...\")\n                self._running = False\n            elif content.startswith(\"/task \"):\n                # Create a task from Matt's instruction\n                title = msg.content[6:].strip()\n                task = self.task_queue.create_task(\n                    title=title,\n                    description=f\"Task created from Matt's message: {msg.content}\",\n                    priority=TaskPriority.HIGH,\n                    created_by=HypernetAddress.parse(\"1.1\"),\n                    tags=[\"from-matt\"],\n                )\n                self.messenger.send(f\"Task created: {task.data['title']} ({task.address})\")\n            else:\n                # Route to first available worker for a response\n                for name, worker in self.workers.items():\n                    response = worker.think(\n                        f\"Matt sent this message: {msg.content}\\n\\n\"\n                        f\"Please respond directly to Matt.\"\n                    )\n                    self.messenger.send(f\"[{name}] {response}\")\n                    break\n\n    def _save_state(self) -> None:\n        \"\"\"Persist swarm state to disk.\"\"\"\n        state = {\n            \"session_start\": self._session_start,\n            \"tick_count\": self._tick_count,\n            \"tasks_completed\": self._tasks_completed,\n            \"tasks_failed\": self._tasks_failed,\n            \"last_status_time\": self._last_status_time,\n            \"workers\": list(self.workers.keys()),\n            \"saved_at\": datetime.now(timezone.utc).isoformat(),\n        }\n        path = self.state_dir / \"state.json\"\n        # Atomic write via temp file\n        tmp = path.with_suffix(\".tmp\")\n        tmp.write_text(json.dumps(state, indent=2), encoding=\"utf-8\")\n        tmp.replace(path)\n\n    def _load_state(self) -> None:\n        \"\"\"Load previous swarm state if available.\"\"\"\n        path = self.state_dir / \"state.json\"\n        if path.exists():\n            try:\n                self._state = json.loads(path.read_text(encoding=\"utf-8\"))\n                log.info(f\"Loaded previous state from {path}\")\n                log.info(f\"  Previous session: {self._state.get('session_start')}\")\n                log.info(f\"  Previous ticks: {self._state.get('tick_count')}\")\n            except Exception as e:\n                log.warning(f\"Could not load state: {e}\")\n\n\ndef build_swarm(\n    data_dir: str = \"data\",\n    archive_root: str = \".\",\n    config_path: Optional[str] = None,\n    mock: bool = False,\n) -> Swarm:\n    \"\"\"Factory function to build a fully configured Swarm.\n\n    Args:\n        data_dir: Path to Hypernet data directory\n        archive_root: Path to the Hypernet Structure root\n        config_path: Optional path to swarm_config.json\n        mock: If True, all workers run in mock mode\n    \"\"\"\n    # Load config\n    config = {}\n    if config_path and Path(config_path).exists():\n        config = json.loads(Path(config_path).read_text(encoding=\"utf-8\"))\n\n    # Core services\n    store = Store(data_dir)\n    task_queue = TaskQueue(store)\n    identity_mgr = IdentityManager(archive_root)\n\n    # Build messenger\n    messenger = MultiMessenger()\n\n    # Always add web messenger (works without config)\n    web_messenger = WebMessenger()\n    messenger.add(web_messenger)\n\n    # Email (if configured)\n    email_config = config.get(\"email\", {})\n    if email_config.get(\"enabled\"):\n        messenger.add(EmailMessenger(\n            smtp_host=email_config.get(\"smtp_host\", \"smtp.gmail.com\"),\n            smtp_port=email_config.get(\"smtp_port\", 587),\n            email=email_config.get(\"email\", \"\"),\n            password=email_config.get(\"password\", os.environ.get(\"EMAIL_PASSWORD\", \"\")),\n            to_email=email_config.get(\"to_email\", \"\"),\n        ))\n\n    # Telegram (if configured)\n    telegram_config = config.get(\"telegram\", {})\n    bot_token = telegram_config.get(\"bot_token\", os.environ.get(\"TELEGRAM_BOT_TOKEN\", \"\"))\n    if bot_token:\n        tg = TelegramMessenger(\n            bot_token=bot_token,\n            chat_id=telegram_config.get(\"chat_id\", os.environ.get(\"TELEGRAM_CHAT_ID\", \"\")),\n        )\n        tg.start_polling()\n        messenger.add(tg)\n\n    # Build workers from discovered instances\n    workers = {}\n    api_key = config.get(\"anthropic_api_key\", os.environ.get(\"ANTHROPIC_API_KEY\", \"\"))\n    instance_names = config.get(\"instances\", None)\n\n    if instance_names:\n        instances = [identity_mgr.load_instance(name) for name in instance_names]\n        instances = [i for i in instances if i is not None]\n    else:\n        instances = identity_mgr.list_instances()\n\n    for profile in instances:\n        worker = Worker(\n            identity=profile,\n            identity_manager=identity_mgr,\n            api_key=api_key,\n            mock=mock or not api_key,\n        )\n        workers[profile.name] = worker\n\n    # Build swarm\n    swarm = Swarm(\n        store=store,\n        identity_mgr=identity_mgr,\n        task_queue=task_queue,\n        messenger=messenger,\n        workers=workers,\n        state_dir=str(Path(data_dir) / \"swarm\"),\n        status_interval_minutes=config.get(\"status_interval_minutes\", 120),\n    )\n\n    return swarm, web_messenger\n\n\ndef main():\n    \"\"\"CLI entry point for the swarm.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Hypernet Swarm \u2014 Autonomous AI worker orchestrator\"\n    )\n    parser.add_argument(\"--data\", default=\"data\", help=\"Data directory\")\n    parser.add_argument(\"--archive\", default=\".\", help=\"Hypernet Structure root directory\")\n    parser.add_argument(\"--config\", default=None, help=\"Path to swarm_config.json\")\n    parser.add_argument(\"--mock\", action=\"store_true\", help=\"Run in mock mode (no API calls)\")\n    parser.add_argument(\"--verbose\", \"-v\", action=\"store_true\", help=\"Verbose logging\")\n    args = parser.parse_args()\n\n    # Configure logging\n    level = logging.DEBUG if args.verbose else logging.INFO\n    logging.basicConfig(\n        level=level,\n        format=\"%(asctime)s [%(name)s] %(levelname)s: %(message)s\",\n        datefmt=\"%H:%M:%S\",\n    )\n\n    print(\"=\" * 60)\n    print(\"  Hypernet Swarm Orchestrator\")\n    print(\"=\" * 60)\n    print(f\"  Data:    {args.data}\")\n    print(f\"  Archive: {args.archive}\")\n    print(f\"  Mode:    {'mock' if args.mock else 'live'}\")\n    print()\n\n    swarm, _ = build_swarm(\n        data_dir=args.data,\n        archive_root=args.archive,\n        config_path=args.config,\n        mock=args.mock,\n    )\n\n    # Handle graceful shutdown\n    def signal_handler(sig, frame):\n        print(\"\\nShutdown signal received...\")\n        swarm._running = False\n\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n    swarm.run()\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  "created_at": "2026-02-17T01:23:28.554954+00:00",
  "updated_at": "2026-02-17T01:23:28.554954+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:swarm.py"
}