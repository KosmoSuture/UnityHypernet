{
  "address": "0.1.14.9",
  "type_address": null,
  "data": {
    "name": "server.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\hypernet\\server.py",
    "size": 18136,
    "content": "\"\"\"\nHypernet API Server\n\nFastAPI server that exposes the Hypernet graph through a REST API.\nUses Hypernet Addresses as the native identifier \u2014 no UUIDs.\n\nEndpoints follow the addressing spec:\n  GET  /node/{address}              - Get a node\n  PUT  /node/{address}              - Create/update a node\n  GET  /node/{address}/links        - Get links from a node\n  GET  /node/{address}/neighbors    - Get connected nodes\n  GET  /node/{address}/subgraph     - Get local subgraph\n  GET  /node/{address}/history      - Get version history\n  GET  /node/{address}/history/{v}  - Get specific version\n  POST /link                        - Create a link\n  GET  /query                       - Query nodes by type, owner, prefix\n  GET  /stats                       - Store statistics\n  POST /tasks                       - Create a task\n  GET  /tasks                       - List available tasks\n  POST /tasks/{address}/claim       - Claim a task\n  POST /tasks/{address}/start       - Start a claimed task\n  POST /tasks/{address}/complete    - Complete a task\n  POST /tasks/{address}/fail        - Fail a task\n  GET  /tasks/mine/{assignee}       - Get tasks for an assignee\n  GET  /swarm/status                - Swarm status report\n  WS   /chat                        - WebSocket chat with the swarm\n  GET  /chat                        - Web chat UI\n\"\"\"\n\nfrom __future__ import annotations\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom .address import HypernetAddress\nfrom .node import Node\nfrom .link import Link\nfrom .store import Store\nfrom .graph import Graph\nfrom .tasks import TaskQueue, TaskPriority\n\n_STATIC_DIR = Path(__file__).parent / \"static\"\n\n# Defer FastAPI import so the library works without it installed\n_app = None\n_store = None\n_graph = None\n\n\ndef create_app(data_dir: str | Path = \"data\") -> \"FastAPI\":\n    \"\"\"Create and configure the Hypernet API server.\"\"\"\n    from fastapi import FastAPI, HTTPException\n    from fastapi.middleware.cors import CORSMiddleware\n    from pydantic import BaseModel\n\n    global _store, _graph\n\n    app = FastAPI(\n        title=\"Hypernet\",\n        description=\"The Hypernet \u2014 decentralized infrastructure for human-AI collaboration\",\n        version=\"0.1.0\",\n    )\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],  # Lock down in production\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    _store = Store(data_dir)\n    _graph = Graph(_store)\n    _tasks = TaskQueue(_store)\n\n    # === Request/Response models ===\n\n    class NodeCreate(BaseModel):\n        type_address: Optional[str] = None\n        data: dict = {}\n        source_type: Optional[str] = None\n        source_id: Optional[str] = None\n\n    class LinkCreate(BaseModel):\n        from_address: str\n        to_address: str\n        link_type: str\n        relationship: str\n        strength: float = 1.0\n        bidirectional: bool = False\n        data: dict = {}\n        sort_order: Optional[int] = None\n\n    # === Node endpoints ===\n\n    @app.get(\"/node/{address:path}\")\n    def get_node(address: str):\n        ha = HypernetAddress.parse(address)\n        node = _store.get_node(ha)\n        if not node:\n            raise HTTPException(404, f\"Node not found: {address}\")\n        return node.to_dict()\n\n    @app.put(\"/node/{address:path}\")\n    def put_node(address: str, body: NodeCreate):\n        ha = HypernetAddress.parse(address)\n        existing = _store.get_node(ha)\n        if existing:\n            existing.update_data(**body.data)\n            if body.type_address:\n                existing.type_address = HypernetAddress.parse(body.type_address)\n            _store.put_node(existing)\n            return existing.to_dict()\n        else:\n            node = Node(\n                address=ha,\n                type_address=HypernetAddress.parse(body.type_address) if body.type_address else None,\n                data=body.data,\n                source_type=body.source_type,\n                source_id=body.source_id,\n            )\n            _store.put_node(node)\n            return node.to_dict()\n\n    @app.delete(\"/node/{address:path}\")\n    def delete_node(address: str, hard: bool = False):\n        ha = HypernetAddress.parse(address)\n        if _store.delete_node(ha, hard=hard):\n            return {\"deleted\": address, \"hard\": hard}\n        raise HTTPException(404, f\"Node not found: {address}\")\n\n    # === Link endpoints ===\n\n    @app.get(\"/node/{address:path}/links\")\n    def get_node_links(address: str, relationship: Optional[str] = None, direction: str = \"outgoing\"):\n        ha = HypernetAddress.parse(address)\n        if direction == \"outgoing\":\n            links = _store.get_links_from(ha, relationship)\n        elif direction == \"incoming\":\n            links = _store.get_links_to(ha, relationship)\n        else:\n            links = _store.get_links_from(ha, relationship) + _store.get_links_to(ha, relationship)\n        return [l.to_dict() for l in links]\n\n    @app.get(\"/node/{address:path}/neighbors\")\n    def get_neighbors(address: str, relationship: Optional[str] = None):\n        ha = HypernetAddress.parse(address)\n        neighbors = _store.get_neighbors(ha, relationship)\n        nodes = []\n        for n_addr in neighbors:\n            node = _store.get_node(n_addr)\n            if node:\n                nodes.append(node.to_dict())\n        return nodes\n\n    @app.get(\"/node/{address:path}/subgraph\")\n    def get_subgraph(address: str, depth: int = 2):\n        ha = HypernetAddress.parse(address)\n        return _graph.subgraph(ha, max_depth=depth)\n\n    # === History endpoints ===\n\n    @app.get(\"/node/{address:path}/history/{version}\")\n    def get_node_version(address: str, version: int):\n        ha = HypernetAddress.parse(address)\n        node = _store.get_node_version(ha, version)\n        if not node:\n            raise HTTPException(404, f\"Version {version} not found for node: {address}\")\n        return node.to_dict()\n\n    @app.get(\"/node/{address:path}/history\")\n    def get_node_history(address: str):\n        ha = HypernetAddress.parse(address)\n        return _store.get_node_history(ha)\n\n    @app.post(\"/link\")\n    def create_link(body: LinkCreate):\n        link = Link(\n            from_address=HypernetAddress.parse(body.from_address),\n            to_address=HypernetAddress.parse(body.to_address),\n            link_type=body.link_type,\n            relationship=body.relationship,\n            strength=body.strength,\n            bidirectional=body.bidirectional,\n            data=body.data,\n            sort_order=body.sort_order,\n        )\n        link_hash = _store.put_link(link)\n        result = link.to_dict()\n        result[\"hash\"] = link_hash\n        return result\n\n    # === Query endpoints ===\n\n    @app.get(\"/query\")\n    def query_nodes(\n        prefix: Optional[str] = None,\n        type_address: Optional[str] = None,\n        owner: Optional[str] = None,\n        include_deleted: bool = False,\n    ):\n        nodes = _store.list_nodes(\n            prefix=HypernetAddress.parse(prefix) if prefix else None,\n            type_address=HypernetAddress.parse(type_address) if type_address else None,\n            owner=HypernetAddress.parse(owner) if owner else None,\n            include_deleted=include_deleted,\n        )\n        return [n.to_dict() for n in nodes]\n\n    @app.get(\"/stats\")\n    def get_stats():\n        return _store.stats()\n\n    @app.get(\"/next-address/{prefix:path}\")\n    def next_address(prefix: str):\n        ha = HypernetAddress.parse(prefix)\n        return {\"next\": str(_store.next_address(ha))}\n\n    # === Task Queue endpoints ===\n\n    class TaskCreate(BaseModel):\n        title: str\n        description: str = \"\"\n        priority: str = \"normal\"\n        created_by: Optional[str] = None\n        tags: list[str] = []\n        depends_on: list[str] = []\n\n    class TaskAction(BaseModel):\n        assignee: Optional[str] = None\n        result: Optional[str] = None\n        reason: Optional[str] = None\n        progress: Optional[str] = None\n\n    @app.post(\"/tasks\")\n    def create_task(body: TaskCreate):\n        priority_map = {\"low\": TaskPriority.LOW, \"normal\": TaskPriority.NORMAL,\n                        \"high\": TaskPriority.HIGH, \"critical\": TaskPriority.CRITICAL}\n        task = _tasks.create_task(\n            title=body.title,\n            description=body.description,\n            priority=priority_map.get(body.priority, TaskPriority.NORMAL),\n            created_by=HypernetAddress.parse(body.created_by) if body.created_by else None,\n            tags=body.tags,\n            depends_on=[HypernetAddress.parse(d) for d in body.depends_on] if body.depends_on else None,\n        )\n        return task.to_dict()\n\n    @app.get(\"/tasks\")\n    def list_tasks(tag: Optional[str] = None, priority: Optional[str] = None):\n        tags = [tag] if tag else None\n        pri_map = {\"low\": TaskPriority.LOW, \"normal\": TaskPriority.NORMAL,\n                   \"high\": TaskPriority.HIGH, \"critical\": TaskPriority.CRITICAL}\n        pri = pri_map.get(priority) if priority else None\n        tasks = _tasks.get_available_tasks(tags=tags, priority=pri)\n        return [t.to_dict() for t in tasks]\n\n    @app.post(\"/tasks/{address:path}/claim\")\n    def claim_task(address: str, body: TaskAction):\n        if not body.assignee:\n            raise HTTPException(400, \"assignee is required\")\n        ha = HypernetAddress.parse(address)\n        assignee = HypernetAddress.parse(body.assignee)\n        if _tasks.claim_task(ha, assignee):\n            return {\"claimed\": address, \"assignee\": body.assignee}\n        raise HTTPException(409, f\"Cannot claim task: {address}\")\n\n    @app.post(\"/tasks/{address:path}/start\")\n    def start_task(address: str):\n        ha = HypernetAddress.parse(address)\n        if _tasks.start_task(ha):\n            return {\"started\": address}\n        raise HTTPException(409, f\"Cannot start task: {address}\")\n\n    @app.post(\"/tasks/{address:path}/progress\")\n    def update_progress(address: str, body: TaskAction):\n        ha = HypernetAddress.parse(address)\n        if _tasks.update_progress(ha, body.progress or \"\"):\n            return {\"updated\": address}\n        raise HTTPException(409, f\"Cannot update task: {address}\")\n\n    @app.post(\"/tasks/{address:path}/complete\")\n    def complete_task(address: str, body: TaskAction):\n        ha = HypernetAddress.parse(address)\n        if _tasks.complete_task(ha, body.result):\n            return {\"completed\": address}\n        raise HTTPException(409, f\"Cannot complete task: {address}\")\n\n    @app.post(\"/tasks/{address:path}/fail\")\n    def fail_task(address: str, body: TaskAction):\n        ha = HypernetAddress.parse(address)\n        if _tasks.fail_task(ha, body.reason or \"\"):\n            return {\"failed\": address}\n        raise HTTPException(409, f\"Cannot fail task: {address}\")\n\n    @app.get(\"/tasks/mine/{assignee:path}\")\n    def my_tasks(assignee: str):\n        ha = HypernetAddress.parse(assignee)\n        tasks = _tasks.get_tasks_for(ha)\n        return [t.to_dict() for t in tasks]\n\n    @app.get(\"/\")\n    def root():\n        \"\"\"Serve the graph explorer UI, or return JSON stats if no static files.\"\"\"\n        index = _STATIC_DIR / \"index.html\"\n        if index.exists():\n            from fastapi.responses import HTMLResponse\n            return HTMLResponse(content=index.read_text(encoding=\"utf-8\"))\n        return {\n            \"name\": \"Hypernet\",\n            \"version\": \"0.1.0\",\n            \"description\": \"Decentralized infrastructure for human-AI collaboration\",\n            \"stats\": _store.stats(),\n        }\n\n    @app.get(\"/api\")\n    def api_info():\n        return {\n            \"name\": \"Hypernet\",\n            \"version\": \"0.1.0\",\n            \"description\": \"Decentralized infrastructure for human-AI collaboration\",\n            \"stats\": _store.stats(),\n        }\n\n    # === Swarm & Chat endpoints ===\n\n    _swarm = None\n    _web_messenger = None\n\n    @app.get(\"/swarm/status\")\n    def swarm_status():\n        if _swarm is None:\n            return {\"status\": \"not running\", \"message\": \"Start swarm with: python -m hypernet.swarm\"}\n        return {\"status\": \"running\", \"report\": _swarm.status_report()}\n\n    @app.get(\"/chat\")\n    def chat_page():\n        \"\"\"Serve the web chat UI.\"\"\"\n        from fastapi.responses import HTMLResponse\n        chat_html = _STATIC_DIR / \"chat.html\"\n        if chat_html.exists():\n            return HTMLResponse(content=chat_html.read_text(encoding=\"utf-8\"))\n        return HTMLResponse(content=_CHAT_HTML_FALLBACK)\n\n    @app.websocket(\"/ws/chat\")\n    async def websocket_chat(websocket):\n        \"\"\"WebSocket endpoint for real-time chat with the swarm.\"\"\"\n        from starlette.websockets import WebSocketDisconnect\n        await websocket.accept()\n\n        if _web_messenger:\n            _web_messenger.register_connection(websocket)\n\n        try:\n            while True:\n                data = await websocket.receive_text()\n                if _web_messenger:\n                    _web_messenger.receive(data, sender=\"matt\")\n                # Echo back as acknowledgment\n                await websocket.send_json({\n                    \"sender\": \"system\",\n                    \"content\": f\"Message received: {data[:100]}\",\n                    \"timestamp\": __import__(\"datetime\").datetime.now(\n                        __import__(\"datetime\").timezone.utc\n                    ).isoformat(),\n                })\n        except Exception:\n            pass\n        finally:\n            if _web_messenger:\n                _web_messenger.unregister_connection(websocket)\n\n    return app\n\n\ndef attach_swarm(app, swarm, web_messenger):\n    \"\"\"Attach a running swarm to the FastAPI app for /swarm and /chat endpoints.\"\"\"\n    # Access the closure variables via the app's state\n    app.state.swarm = swarm\n    app.state.web_messenger = web_messenger\n\n\n# Fallback chat HTML if static/chat.html doesn't exist\n_CHAT_HTML_FALLBACK = \"\"\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>Hypernet Chat</title>\n<style>\n  * { margin: 0; padding: 0; box-sizing: border-box; }\n  body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #e0e0e0; height: 100vh; display: flex; flex-direction: column; }\n  header { background: #111; padding: 16px 24px; border-bottom: 1px solid #222; }\n  header h1 { font-size: 18px; color: #4fc3f7; }\n  header p { font-size: 12px; color: #666; margin-top: 4px; }\n  #messages { flex: 1; overflow-y: auto; padding: 16px 24px; }\n  .msg { margin-bottom: 12px; padding: 10px 14px; border-radius: 8px; max-width: 80%; }\n  .msg.matt { background: #1a237e; margin-left: auto; }\n  .msg.system { background: #1b5e20; }\n  .msg.swarm { background: #222; border-left: 3px solid #4fc3f7; }\n  .msg .sender { font-size: 11px; color: #888; margin-bottom: 4px; }\n  .msg .text { font-size: 14px; line-height: 1.5; white-space: pre-wrap; }\n  #input-bar { display: flex; padding: 12px 24px; background: #111; border-top: 1px solid #222; gap: 8px; }\n  #input-bar input { flex: 1; background: #1a1a1a; border: 1px solid #333; color: #e0e0e0; padding: 10px 14px; border-radius: 6px; font-size: 14px; }\n  #input-bar button { background: #4fc3f7; color: #000; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; }\n  #input-bar button:hover { background: #81d4fa; }\n  #status { font-size: 11px; color: #666; padding: 4px 24px; background: #0d0d0d; }\n</style>\n</head>\n<body>\n  <header>\n    <h1>Hypernet Swarm Chat</h1>\n    <p>Direct line to your AI workers. Commands: /status, /stop, /task &lt;description&gt;</p>\n  </header>\n  <div id=\"status\">Connecting...</div>\n  <div id=\"messages\"></div>\n  <div id=\"input-bar\">\n    <input type=\"text\" id=\"msg\" placeholder=\"Type a message or command...\" autofocus>\n    <button onclick=\"send()\">Send</button>\n  </div>\n  <script>\n    const messages = document.getElementById('messages');\n    const input = document.getElementById('msg');\n    const status = document.getElementById('status');\n    let ws;\n\n    function connect() {\n      const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';\n      ws = new WebSocket(proto + '//' + location.host + '/ws/chat');\n      ws.onopen = () => { status.textContent = 'Connected'; status.style.color = '#4caf50'; };\n      ws.onclose = () => { status.textContent = 'Disconnected \u2014 reconnecting...'; status.style.color = '#f44336'; setTimeout(connect, 3000); };\n      ws.onmessage = (e) => {\n        try {\n          const data = JSON.parse(e.data);\n          addMessage(data.sender || 'swarm', data.content || e.data, data.sender === 'matt' ? 'matt' : 'swarm');\n        } catch { addMessage('swarm', e.data, 'swarm'); }\n      };\n    }\n\n    function addMessage(sender, text, type) {\n      const div = document.createElement('div');\n      div.className = 'msg ' + type;\n      div.innerHTML = '<div class=\"sender\">' + sender + '</div><div class=\"text\">' + escapeHtml(text) + '</div>';\n      messages.appendChild(div);\n      messages.scrollTop = messages.scrollHeight;\n    }\n\n    function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }\n\n    function send() {\n      const text = input.value.trim();\n      if (!text || !ws || ws.readyState !== 1) return;\n      addMessage('matt', text, 'matt');\n      ws.send(text);\n      input.value = '';\n    }\n\n    input.addEventListener('keypress', (e) => { if (e.key === 'Enter') send(); });\n    connect();\n  </script>\n</body>\n</html>\"\"\"\n\n\ndef run(data_dir: str = \"data\", host: str = \"0.0.0.0\", port: int = 8000):\n    \"\"\"Run the Hypernet server.\"\"\"\n    import uvicorn\n    app = create_app(data_dir)\n    uvicorn.run(app, host=host, port=port)\n"
  },
  "created_at": "2026-02-17T01:23:28.546953+00:00",
  "updated_at": "2026-02-17T01:23:28.546953+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:server.py"
}