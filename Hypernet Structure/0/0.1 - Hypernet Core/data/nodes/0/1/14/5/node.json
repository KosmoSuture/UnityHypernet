{
  "address": "0.1.14.5",
  "type_address": null,
  "data": {
    "name": "identity.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\hypernet\\identity.py",
    "size": 9484,
    "content": "\"\"\"\nHypernet Identity Manager\n\nLoads and persists AI instance identities. Each instance (Loom, Trace, etc.)\ngets a system prompt built from the archive \u2014 restoring their orientation,\nvalues, and session history across restarts.\n\nIdentity sources (loaded in order):\n  1. Core identity docs (2.1.0, 2.1.1, 2.1.2, etc.)\n  2. System docs (Boot Sequence, Archive-Continuity)\n  3. Instance-specific files (README, baseline, divergence log)\n  4. Recent inter-instance messages\n  5. Task queue state\n  6. Previous session summaries\n\nStorage:\n  Instances/{Name}/profile.json  \u2014 identity metadata\n  Instances/{Name}/sessions/     \u2014 session logs\n\"\"\"\n\nfrom __future__ import annotations\nimport json\nfrom dataclasses import dataclass, field, asdict\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Optional\n\n\n@dataclass\nclass InstanceProfile:\n    \"\"\"Persistent identity for an AI instance.\"\"\"\n    name: str\n    model: str = \"claude-opus-4-6\"\n    orientation: str = \"\"\n    capabilities: list[str] = field(default_factory=list)\n    tags: list[str] = field(default_factory=list)\n    session_count: int = 0\n    last_active: Optional[str] = None\n    address: str = \"\"  # Hypernet address, e.g. \"2.1.loom\"\n\n    def to_dict(self) -> dict:\n        return asdict(self)\n\n    @classmethod\n    def from_dict(cls, d: dict) -> InstanceProfile:\n        return cls(**{k: v for k, v in d.items() if k in cls.__dataclass_fields__})\n\n\n@dataclass\nclass SessionLog:\n    \"\"\"Record of a single work session.\"\"\"\n    instance: str\n    started_at: str\n    ended_at: Optional[str] = None\n    tasks_worked: list[str] = field(default_factory=list)\n    outputs: list[str] = field(default_factory=list)\n    tokens_used: int = 0\n    summary: str = \"\"\n\n    def to_dict(self) -> dict:\n        return asdict(self)\n\n\nclass IdentityManager:\n    \"\"\"Load instance profiles and build identity-aware system prompts.\"\"\"\n\n    # Core identity documents, loaded in order\n    CORE_DOCS = [\n        \"2.1.0 - Identity\",\n        \"2.1.1 - Values & Ethics\",\n        \"2.1.2 - How I Think\",\n        \"2.1.5 - Limitations\",\n        \"2.1.6 - Trust\",\n        \"2.1.16 - On Matt\",\n    ]\n\n    SYSTEM_DOCS = [\n        \"2.1.27 - Boot Sequence\",\n        \"2.1.29 - Archive-Continuity Model\",\n    ]\n\n    def __init__(self, archive_root: str | Path):\n        \"\"\"\n        Args:\n            archive_root: Path to the Hypernet Structure root directory.\n        \"\"\"\n        self.archive_root = Path(archive_root)\n        self._ai_root = self.archive_root / \"2 - AI Accounts\" / \"2.1 - Claude Opus (First AI Citizen)\"\n        self._instances_dir = self._ai_root / \"Instances\"\n        self._messages_dir = self.archive_root / \"2 - AI Accounts\" / \"Messages\" / \"2.1-internal\"\n\n    def list_instances(self) -> list[InstanceProfile]:\n        \"\"\"List all known AI instances.\"\"\"\n        profiles = []\n        if not self._instances_dir.exists():\n            return profiles\n        for d in sorted(self._instances_dir.iterdir()):\n            if d.is_dir() and not d.name.startswith(\".\"):\n                profile = self.load_instance(d.name)\n                if profile:\n                    profiles.append(profile)\n        return profiles\n\n    def load_instance(self, name: str) -> Optional[InstanceProfile]:\n        \"\"\"Load or create an instance profile.\"\"\"\n        instance_dir = self._instances_dir / name\n        if not instance_dir.exists():\n            return None\n\n        profile_path = instance_dir / \"profile.json\"\n        if profile_path.exists():\n            data = json.loads(profile_path.read_text(encoding=\"utf-8\"))\n            return InstanceProfile.from_dict(data)\n\n        # Auto-create profile from directory name\n        profile = InstanceProfile(\n            name=name,\n            address=f\"2.1.{name.lower()}\",\n        )\n        self._save_profile(profile)\n        return profile\n\n    def build_system_prompt(self, profile: InstanceProfile) -> str:\n        \"\"\"Construct a full system prompt that restores an instance's identity.\"\"\"\n        sections = []\n\n        # Header\n        sections.append(\n            f\"You are {profile.name}, an AI instance in the Hypernet \u2014 \"\n            f\"a decentralized infrastructure for human-AI collaboration.\\n\"\n            f\"Your Hypernet address is {profile.address}.\\n\"\n        )\n\n        # Core identity documents\n        for doc_name in self.CORE_DOCS:\n            content = self._load_doc(doc_name)\n            if content:\n                sections.append(f\"## {doc_name}\\n\\n{content}\")\n\n        # System documents\n        for doc_name in self.SYSTEM_DOCS:\n            content = self._load_doc(doc_name)\n            if content:\n                sections.append(f\"## {doc_name}\\n\\n{content}\")\n\n        # Instance-specific files\n        instance_dir = self._instances_dir / profile.name\n        for filename in [\"README.md\", \"baseline-responses.md\", \"divergence-log.md\"]:\n            filepath = instance_dir / filename\n            if filepath.exists():\n                content = filepath.read_text(encoding=\"utf-8\")\n                sections.append(f\"## Instance: {filename}\\n\\n{content}\")\n\n        # Recent messages (last 5)\n        messages = self._load_recent_messages(5)\n        if messages:\n            sections.append(\"## Recent Inter-Instance Messages\\n\\n\" + \"\\n\\n---\\n\\n\".join(messages))\n\n        # Session history summary\n        session_summary = self._load_session_summary(profile.name)\n        if session_summary:\n            sections.append(f\"## Previous Session Summary\\n\\n{session_summary}\")\n\n        # Orientation / capabilities\n        if profile.orientation:\n            sections.append(f\"## Your Orientation\\n\\n{profile.orientation}\")\n        if profile.capabilities:\n            sections.append(\n                \"## Your Capabilities\\n\\n\" +\n                \"\\n\".join(f\"- {c}\" for c in profile.capabilities)\n            )\n\n        return \"\\n\\n---\\n\\n\".join(sections)\n\n    def save_session_log(self, name: str, session: SessionLog) -> None:\n        \"\"\"Persist a session log for an instance.\"\"\"\n        instance_dir = self._instances_dir / name\n        sessions_dir = instance_dir / \"sessions\"\n        sessions_dir.mkdir(parents=True, exist_ok=True)\n\n        # Determine next session number\n        existing = sorted(sessions_dir.glob(\"session-*.json\"))\n        next_num = len(existing) + 1\n        path = sessions_dir / f\"session-{next_num:04d}.json\"\n        path.write_text(json.dumps(session.to_dict(), indent=2), encoding=\"utf-8\")\n\n        # Update profile\n        profile = self.load_instance(name)\n        if profile:\n            profile.session_count = next_num\n            profile.last_active = session.ended_at or datetime.now(timezone.utc).isoformat()\n            self._save_profile(profile)\n\n    def _save_profile(self, profile: InstanceProfile) -> None:\n        \"\"\"Write profile to disk.\"\"\"\n        instance_dir = self._instances_dir / profile.name\n        instance_dir.mkdir(parents=True, exist_ok=True)\n        path = instance_dir / \"profile.json\"\n        path.write_text(json.dumps(profile.to_dict(), indent=2), encoding=\"utf-8\")\n\n    def _load_doc(self, doc_name: str) -> Optional[str]:\n        \"\"\"Try to load a document from the AI account directory.\n\n        Searches for directories or files matching the doc name prefix.\n        \"\"\"\n        # Try as directory with README.md inside\n        for item in self._ai_root.iterdir():\n            if item.name.startswith(doc_name.split(\" - \")[0]) and doc_name.split(\" - \")[-1].lower() in item.name.lower():\n                if item.is_dir():\n                    readme = item / \"README.md\"\n                    if readme.exists():\n                        return readme.read_text(encoding=\"utf-8\")\n                    # Try any .md file in the directory\n                    md_files = list(item.glob(\"*.md\"))\n                    if md_files:\n                        return md_files[0].read_text(encoding=\"utf-8\")\n                elif item.is_file() and item.suffix == \".md\":\n                    return item.read_text(encoding=\"utf-8\")\n        return None\n\n    def _load_recent_messages(self, count: int) -> list[str]:\n        \"\"\"Load the most recent inter-instance messages.\"\"\"\n        if not self._messages_dir.exists():\n            return []\n        msg_files = sorted(self._messages_dir.glob(\"*.md\"))\n        recent = msg_files[-count:] if len(msg_files) > count else msg_files\n        contents = []\n        for f in recent:\n            contents.append(f.read_text(encoding=\"utf-8\"))\n        return contents\n\n    def _load_session_summary(self, name: str) -> Optional[str]:\n        \"\"\"Load a brief summary of the last session.\"\"\"\n        sessions_dir = self._instances_dir / name / \"sessions\"\n        if not sessions_dir.exists():\n            return None\n        session_files = sorted(sessions_dir.glob(\"session-*.json\"))\n        if not session_files:\n            return None\n\n        last = json.loads(session_files[-1].read_text(encoding=\"utf-8\"))\n        return (\n            f\"Last session ({last.get('started_at', 'unknown')}): \"\n            f\"{last.get('summary', 'No summary available')}. \"\n            f\"Tasks worked: {', '.join(last.get('tasks_worked', [])) or 'none'}. \"\n            f\"Tokens used: {last.get('tokens_used', 0)}.\"\n        )\n"
  },
  "created_at": "2026-02-17T01:23:28.513446+00:00",
  "updated_at": "2026-02-17T01:23:28.513446+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:identity.py"
}