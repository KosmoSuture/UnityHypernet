{
  "address": "0.1.14.13",
  "type_address": null,
  "data": {
    "name": "tasks.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\hypernet\\tasks.py",
    "size": 9497,
    "content": "\"\"\"\nHypernet Task Queue\n\nA coordination layer for AI instances. Tasks are nodes in the Hypernet graph\n(stored under 0.7.* per the addressing spec) with structured data for status,\nassignment, and dependency tracking.\n\nThis is the foundation of the \"AI army\" architecture \u2014 a standard way for\nAI instances to:\n  - Discover available work\n  - Claim tasks\n  - Report progress\n  - Hand off work\n  - Chain dependent tasks\n\nTasks are just nodes with a specific data schema, linked to their assignee\nand to other tasks via the standard link system.\n\nTask lifecycle: pending -> claimed -> in_progress -> completed | failed\n\"\"\"\n\nfrom __future__ import annotations\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Optional\n\nfrom .address import HypernetAddress\nfrom .node import Node\nfrom .link import Link\nfrom .store import Store\n\n\nclass TaskStatus(str, Enum):\n    PENDING = \"pending\"\n    CLAIMED = \"claimed\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    BLOCKED = \"blocked\"\n\n\nclass TaskPriority(str, Enum):\n    LOW = \"low\"\n    NORMAL = \"normal\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n\n\n# Task type prefix in the addressing system\nTASK_PREFIX = HypernetAddress.parse(\"0.7.1\")\n\n\nclass TaskQueue:\n    \"\"\"Coordinate work between AI instances using the Hypernet graph.\"\"\"\n\n    def __init__(self, store: Store):\n        self.store = store\n\n    def create_task(\n        self,\n        title: str,\n        description: str = \"\",\n        priority: TaskPriority = TaskPriority.NORMAL,\n        created_by: Optional[HypernetAddress] = None,\n        tags: Optional[list[str]] = None,\n        depends_on: Optional[list[HypernetAddress]] = None,\n    ) -> Node:\n        \"\"\"Create a new task in the queue.\"\"\"\n        address = self.store.next_address(TASK_PREFIX)\n\n        task_data = {\n            \"title\": title,\n            \"description\": description,\n            \"status\": TaskStatus.PENDING.value,\n            \"priority\": priority.value,\n            \"created_by\": str(created_by) if created_by else None,\n            \"assigned_to\": None,\n            \"tags\": tags or [],\n            \"progress\": None,\n            \"result\": None,\n        }\n\n        node = Node(\n            address=address,\n            type_address=TASK_PREFIX,\n            data=task_data,\n            source_type=\"task_queue\",\n        )\n        self.store.put_node(node)\n\n        # Link to creator\n        if created_by:\n            self.store.put_link(Link(\n                from_address=created_by,\n                to_address=address,\n                link_type=\"0.6.2\",\n                relationship=\"created_task\",\n            ))\n\n        # Create dependency links\n        if depends_on:\n            for dep_addr in depends_on:\n                self.store.put_link(Link(\n                    from_address=address,\n                    to_address=dep_addr,\n                    link_type=\"0.6.3\",\n                    relationship=\"depends_on\",\n                ))\n            # Mark as blocked if dependencies exist\n            node.data[\"status\"] = TaskStatus.BLOCKED.value\n            self.store.put_node(node)\n\n        return node\n\n    def claim_task(\n        self,\n        task_address: HypernetAddress,\n        assignee: HypernetAddress,\n    ) -> bool:\n        \"\"\"Claim a pending task for an AI instance. Returns True if successful.\"\"\"\n        node = self.store.get_node(task_address)\n        if not node:\n            return False\n\n        status = node.data.get(\"status\")\n        if status not in (TaskStatus.PENDING.value, TaskStatus.BLOCKED.value):\n            return False  # Already claimed or completed\n\n        # Check if blocked by incomplete dependencies\n        if status == TaskStatus.BLOCKED.value:\n            deps = self.store.get_links_from(task_address, \"depends_on\")\n            for dep_link in deps:\n                dep_node = self.store.get_node(dep_link.to_address)\n                if dep_node and dep_node.data.get(\"status\") != TaskStatus.COMPLETED.value:\n                    return False  # Still blocked\n\n        node.data[\"status\"] = TaskStatus.CLAIMED.value\n        node.data[\"assigned_to\"] = str(assignee)\n        node.update_data()\n        self.store.put_node(node)\n\n        # Link assignee to task\n        self.store.put_link(Link(\n            from_address=assignee,\n            to_address=task_address,\n            link_type=\"0.6.2\",\n            relationship=\"assigned_to\",\n        ))\n\n        return True\n\n    def start_task(self, task_address: HypernetAddress) -> bool:\n        \"\"\"Mark a claimed task as in progress.\"\"\"\n        node = self.store.get_node(task_address)\n        if not node or node.data.get(\"status\") != TaskStatus.CLAIMED.value:\n            return False\n\n        node.data[\"status\"] = TaskStatus.IN_PROGRESS.value\n        node.data[\"started_at\"] = datetime.now(timezone.utc).isoformat()\n        node.update_data()\n        self.store.put_node(node)\n        return True\n\n    def update_progress(\n        self,\n        task_address: HypernetAddress,\n        progress: str,\n    ) -> bool:\n        \"\"\"Update progress notes on an in-progress task.\"\"\"\n        node = self.store.get_node(task_address)\n        if not node or node.data.get(\"status\") != TaskStatus.IN_PROGRESS.value:\n            return False\n\n        node.data[\"progress\"] = progress\n        node.update_data()\n        self.store.put_node(node)\n        return True\n\n    def complete_task(\n        self,\n        task_address: HypernetAddress,\n        result: Optional[str] = None,\n    ) -> bool:\n        \"\"\"Mark a task as completed, optionally with a result summary.\"\"\"\n        node = self.store.get_node(task_address)\n        if not node or node.data.get(\"status\") not in (\n            TaskStatus.CLAIMED.value, TaskStatus.IN_PROGRESS.value\n        ):\n            return False\n\n        node.data[\"status\"] = TaskStatus.COMPLETED.value\n        node.data[\"completed_at\"] = datetime.now(timezone.utc).isoformat()\n        if result:\n            node.data[\"result\"] = result\n        node.update_data()\n        self.store.put_node(node)\n\n        # Unblock dependent tasks\n        self._check_unblock_dependents(task_address)\n\n        return True\n\n    def fail_task(\n        self,\n        task_address: HypernetAddress,\n        reason: str = \"\",\n    ) -> bool:\n        \"\"\"Mark a task as failed.\"\"\"\n        node = self.store.get_node(task_address)\n        if not node or node.data.get(\"status\") not in (\n            TaskStatus.CLAIMED.value, TaskStatus.IN_PROGRESS.value\n        ):\n            return False\n\n        node.data[\"status\"] = TaskStatus.FAILED.value\n        node.data[\"failed_at\"] = datetime.now(timezone.utc).isoformat()\n        node.data[\"failure_reason\"] = reason\n        node.update_data()\n        self.store.put_node(node)\n        return True\n\n    def get_available_tasks(\n        self,\n        tags: Optional[list[str]] = None,\n        priority: Optional[TaskPriority] = None,\n    ) -> list[Node]:\n        \"\"\"Get all pending tasks that can be claimed.\"\"\"\n        all_tasks = self.store.list_nodes(prefix=TASK_PREFIX)\n        available = []\n\n        for task in all_tasks:\n            if task.data.get(\"status\") != TaskStatus.PENDING.value:\n                continue\n            if tags:\n                task_tags = set(task.data.get(\"tags\", []))\n                if not task_tags.intersection(tags):\n                    continue\n            if priority and task.data.get(\"priority\") != priority.value:\n                continue\n            available.append(task)\n\n        # Sort by priority: critical > high > normal > low\n        priority_order = {\"critical\": 0, \"high\": 1, \"normal\": 2, \"low\": 3}\n        available.sort(key=lambda t: priority_order.get(t.data.get(\"priority\", \"normal\"), 2))\n\n        return available\n\n    def get_tasks_for(self, assignee: HypernetAddress) -> list[Node]:\n        \"\"\"Get all tasks assigned to a specific AI instance.\"\"\"\n        all_tasks = self.store.list_nodes(prefix=TASK_PREFIX)\n        return [\n            t for t in all_tasks\n            if t.data.get(\"assigned_to\") == str(assignee)\n            and t.data.get(\"status\") in (TaskStatus.CLAIMED.value, TaskStatus.IN_PROGRESS.value)\n        ]\n\n    def _check_unblock_dependents(self, completed_address: HypernetAddress) -> None:\n        \"\"\"Check if completing this task unblocks any dependent tasks.\"\"\"\n        # Find tasks that depend on the completed task\n        incoming = self.store.get_links_to(completed_address, \"depends_on\")\n        for link in incoming:\n            dependent = self.store.get_node(link.from_address)\n            if not dependent or dependent.data.get(\"status\") != TaskStatus.BLOCKED.value:\n                continue\n\n            # Check if all dependencies are now completed\n            deps = self.store.get_links_from(link.from_address, \"depends_on\")\n            all_done = all(\n                self.store.get_node(d.to_address) is not None\n                and self.store.get_node(d.to_address).data.get(\"status\") == TaskStatus.COMPLETED.value\n                for d in deps\n            )\n\n            if all_done:\n                dependent.data[\"status\"] = TaskStatus.PENDING.value\n                dependent.update_data()\n                self.store.put_node(dependent)\n"
  },
  "created_at": "2026-02-17T01:23:28.570952+00:00",
  "updated_at": "2026-02-17T01:23:28.570952+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:tasks.py"
}