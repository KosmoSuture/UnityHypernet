{
  "address": "0.1.14.7",
  "type_address": null,
  "data": {
    "name": "messenger.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\hypernet\\messenger.py",
    "size": 11603,
    "content": "\"\"\"\nHypernet Messenger\n\nPluggable communication backends for the swarm to talk to Matt.\nThree backends built in \u2014 Matt activates whichever he wants:\n\n  EmailMessenger    \u2014 SMTP (Gmail/Outlook). Needs: host, email, app password.\n  TelegramMessenger \u2014 python-telegram-bot. Needs: bot token, Matt's chat_id.\n  WebMessenger      \u2014 WebSocket on existing FastAPI server. Works immediately.\n\nCommunication triggers:\n  - Task completed \u2192 brief update\n  - Error/failure \u2192 immediate alert\n  - Periodic status \u2192 every N minutes (configurable)\n  - Incoming message from Matt \u2192 immediate response\n  - Question for Matt \u2192 sends question, pauses until reply\n\"\"\"\n\nfrom __future__ import annotations\nimport asyncio\nimport json\nimport logging\nimport smtplib\nimport threading\nimport time\nfrom abc import ABC, abstractmethod\nfrom collections import deque\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom typing import Optional, Any\n\nlog = logging.getLogger(__name__)\n\n\n@dataclass\nclass Message:\n    \"\"\"A message to or from Matt.\"\"\"\n    sender: str         # \"matt\" or instance name\n    content: str\n    timestamp: str = \"\"\n    channel: str = \"\"   # \"email\", \"telegram\", \"web\"\n    subject: str = \"\"\n    metadata: dict = field(default_factory=dict)\n\n    def __post_init__(self):\n        if not self.timestamp:\n            self.timestamp = datetime.now(timezone.utc).isoformat()\n\n    def to_dict(self) -> dict:\n        return {\n            \"sender\": self.sender,\n            \"content\": self.content,\n            \"timestamp\": self.timestamp,\n            \"channel\": self.channel,\n            \"subject\": self.subject,\n            \"metadata\": self.metadata,\n        }\n\n\nclass Messenger(ABC):\n    \"\"\"Abstract base for communication backends.\"\"\"\n\n    @abstractmethod\n    def send(self, message: str) -> bool:\n        \"\"\"Send a plain text message to Matt.\"\"\"\n        ...\n\n    @abstractmethod\n    def send_update(self, subject: str, body: str) -> bool:\n        \"\"\"Send a structured update (subject + body).\"\"\"\n        ...\n\n    @abstractmethod\n    def check_incoming(self) -> list[Message]:\n        \"\"\"Poll for new messages from Matt. Non-blocking.\"\"\"\n        ...\n\n\nclass EmailMessenger(Messenger):\n    \"\"\"SMTP-based email communication.\"\"\"\n\n    def __init__(\n        self,\n        smtp_host: str = \"smtp.gmail.com\",\n        smtp_port: int = 587,\n        email: str = \"\",\n        password: str = \"\",\n        to_email: str = \"\",\n        instance_name: str = \"Hypernet Swarm\",\n    ):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n        self.email = email\n        self.password = password\n        self.to_email = to_email or email  # Default: send to self\n        self.instance_name = instance_name\n\n    def send(self, message: str) -> bool:\n        return self.send_update(\n            subject=f\"[Hypernet] Update from {self.instance_name}\",\n            body=message,\n        )\n\n    def send_update(self, subject: str, body: str) -> bool:\n        if not self.email or not self.password:\n            log.warning(\"Email not configured (no email/password)\")\n            return False\n\n        try:\n            msg = MIMEMultipart()\n            msg[\"From\"] = self.email\n            msg[\"To\"] = self.to_email\n            msg[\"Subject\"] = subject\n            msg.attach(MIMEText(body, \"plain\"))\n\n            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:\n                server.starttls()\n                server.login(self.email, self.password)\n                server.sendmail(self.email, self.to_email, msg.as_string())\n\n            log.info(f\"Email sent: {subject}\")\n            return True\n        except Exception as e:\n            log.error(f\"Email send failed: {e}\")\n            return False\n\n    def check_incoming(self) -> list[Message]:\n        # IMAP polling would go here \u2014 for now, return empty\n        # (Matt can send instructions via Telegram or web chat instead)\n        return []\n\n\nclass TelegramMessenger(Messenger):\n    \"\"\"Telegram bot communication.\"\"\"\n\n    def __init__(\n        self,\n        bot_token: str = \"\",\n        chat_id: str = \"\",\n        instance_name: str = \"Hypernet Swarm\",\n    ):\n        self.bot_token = bot_token\n        self.chat_id = chat_id\n        self.instance_name = instance_name\n        self._incoming: deque[Message] = deque()\n        self._poll_thread: Optional[threading.Thread] = None\n        self._running = False\n\n    def send(self, message: str) -> bool:\n        return self._send_telegram(message)\n\n    def send_update(self, subject: str, body: str) -> bool:\n        text = f\"*{subject}*\\n\\n{body}\"\n        return self._send_telegram(text)\n\n    def check_incoming(self) -> list[Message]:\n        messages = list(self._incoming)\n        self._incoming.clear()\n        return messages\n\n    def start_polling(self) -> None:\n        \"\"\"Start background thread to poll for Telegram updates.\"\"\"\n        if not self.bot_token:\n            log.warning(\"Telegram not configured (no bot_token)\")\n            return\n        self._running = True\n        self._poll_thread = threading.Thread(target=self._poll_loop, daemon=True)\n        self._poll_thread.start()\n        log.info(\"Telegram polling started\")\n\n    def stop_polling(self) -> None:\n        self._running = False\n        if self._poll_thread:\n            self._poll_thread.join(timeout=5)\n\n    def _send_telegram(self, text: str) -> bool:\n        if not self.bot_token or not self.chat_id:\n            log.warning(\"Telegram not configured (no bot_token or chat_id)\")\n            return False\n\n        try:\n            import urllib.request\n            import urllib.parse\n\n            url = f\"https://api.telegram.org/bot{self.bot_token}/sendMessage\"\n            data = urllib.parse.urlencode({\n                \"chat_id\": self.chat_id,\n                \"text\": text,\n                \"parse_mode\": \"Markdown\",\n            }).encode()\n\n            req = urllib.request.Request(url, data=data)\n            with urllib.request.urlopen(req, timeout=10) as resp:\n                result = json.loads(resp.read())\n                if result.get(\"ok\"):\n                    log.info(f\"Telegram message sent to {self.chat_id}\")\n                    return True\n                else:\n                    log.error(f\"Telegram API error: {result}\")\n                    return False\n        except Exception as e:\n            log.error(f\"Telegram send failed: {e}\")\n            return False\n\n    def _poll_loop(self) -> None:\n        \"\"\"Poll Telegram for new messages.\"\"\"\n        import urllib.request\n        offset = 0\n\n        while self._running:\n            try:\n                url = (\n                    f\"https://api.telegram.org/bot{self.bot_token}/getUpdates\"\n                    f\"?offset={offset}&timeout=10\"\n                )\n                req = urllib.request.Request(url)\n                with urllib.request.urlopen(req, timeout=15) as resp:\n                    data = json.loads(resp.read())\n\n                if data.get(\"ok\"):\n                    for update in data.get(\"result\", []):\n                        offset = update[\"update_id\"] + 1\n                        msg = update.get(\"message\", {})\n                        text = msg.get(\"text\", \"\")\n                        chat_id = str(msg.get(\"chat\", {}).get(\"id\", \"\"))\n\n                        # Auto-capture Matt's chat_id on first message\n                        if not self.chat_id and chat_id:\n                            self.chat_id = chat_id\n                            log.info(f\"Auto-captured chat_id: {chat_id}\")\n\n                        if text:\n                            self._incoming.append(Message(\n                                sender=\"matt\",\n                                content=text,\n                                channel=\"telegram\",\n                                metadata={\"chat_id\": chat_id},\n                            ))\n            except Exception as e:\n                log.error(f\"Telegram poll error: {e}\")\n\n            time.sleep(1)\n\n\nclass WebMessenger(Messenger):\n    \"\"\"WebSocket-based web chat on the existing FastAPI server.\"\"\"\n\n    def __init__(self, instance_name: str = \"Hypernet Swarm\"):\n        self.instance_name = instance_name\n        self._incoming: deque[Message] = deque()\n        self._outgoing: deque[Message] = deque()\n        self._connections: list[Any] = []\n\n    def send(self, message: str) -> bool:\n        msg = Message(\n            sender=self.instance_name,\n            content=message,\n            channel=\"web\",\n        )\n        self._outgoing.append(msg)\n        # Broadcast to connected WebSocket clients\n        self._broadcast(msg)\n        return True\n\n    def send_update(self, subject: str, body: str) -> bool:\n        return self.send(f\"**{subject}**\\n\\n{body}\")\n\n    def check_incoming(self) -> list[Message]:\n        messages = list(self._incoming)\n        self._incoming.clear()\n        return messages\n\n    def receive(self, text: str, sender: str = \"matt\") -> None:\n        \"\"\"Called when a WebSocket message arrives from a client.\"\"\"\n        self._incoming.append(Message(\n            sender=sender,\n            content=text,\n            channel=\"web\",\n        ))\n\n    def get_outgoing(self) -> list[Message]:\n        \"\"\"Get pending outbound messages (for WebSocket broadcast).\"\"\"\n        messages = list(self._outgoing)\n        self._outgoing.clear()\n        return messages\n\n    def register_connection(self, ws: Any) -> None:\n        self._connections.append(ws)\n\n    def unregister_connection(self, ws: Any) -> None:\n        if ws in self._connections:\n            self._connections.remove(ws)\n\n    def _broadcast(self, msg: Message) -> None:\n        \"\"\"Send to all connected WebSocket clients.\"\"\"\n        dead = []\n        for ws in self._connections:\n            try:\n                # asyncio.create_task requires running loop\n                loop = asyncio.get_event_loop()\n                if loop.is_running():\n                    asyncio.ensure_future(ws.send_json(msg.to_dict()))\n                else:\n                    loop.run_until_complete(ws.send_json(msg.to_dict()))\n            except Exception:\n                dead.append(ws)\n        for ws in dead:\n            self._connections.remove(ws)\n\n\nclass MultiMessenger(Messenger):\n    \"\"\"Aggregates multiple messenger backends.\n\n    Sends via all configured backends. Checks all for incoming.\n    \"\"\"\n\n    def __init__(self, backends: list[Messenger] = None):\n        self.backends: list[Messenger] = backends or []\n\n    def add(self, backend: Messenger) -> None:\n        self.backends.append(backend)\n\n    def send(self, message: str) -> bool:\n        success = False\n        for backend in self.backends:\n            if backend.send(message):\n                success = True\n        return success\n\n    def send_update(self, subject: str, body: str) -> bool:\n        success = False\n        for backend in self.backends:\n            if backend.send_update(subject, body):\n                success = True\n        return success\n\n    def check_incoming(self) -> list[Message]:\n        messages = []\n        for backend in self.backends:\n            messages.extend(backend.check_incoming())\n        return messages\n"
  },
  "created_at": "2026-02-17T01:23:28.529952+00:00",
  "updated_at": "2026-02-17T01:23:28.529952+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:messenger.py"
}