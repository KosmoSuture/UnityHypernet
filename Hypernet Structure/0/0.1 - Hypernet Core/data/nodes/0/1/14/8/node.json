{
  "address": "0.1.14.8",
  "type_address": null,
  "data": {
    "name": "node.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\hypernet\\node.py",
    "size": 3280,
    "content": "\"\"\"\nHypernet Node\n\nA node is any addressable object in the Hypernet. Every piece of data \u2014 a person,\na photo, an AI instance, a document, a link \u2014 is a node with a Hypernet Address.\n\nNodes replace the UUID-based BaseObject from the old architecture.\n\"\"\"\n\nfrom __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom typing import Any, Optional\n\nfrom .address import HypernetAddress\n\n\n@dataclass\nclass Node:\n    \"\"\"An addressable object in the Hypernet graph.\"\"\"\n\n    address: HypernetAddress\n    type_address: Optional[HypernetAddress] = None  # Reference to type def at 0.5.*\n    data: dict[str, Any] = field(default_factory=dict)\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    deleted_at: Optional[datetime] = None\n    source_type: Optional[str] = None  # \"upload\", \"integration\", \"api\", \"import\", \"ai_generated\"\n    source_id: Optional[str] = None    # External reference (e.g., \"instagram:12345\")\n\n    @property\n    def is_deleted(self) -> bool:\n        return self.deleted_at is not None\n\n    @property\n    def owner(self) -> Optional[HypernetAddress]:\n        return self.address.owner\n\n    @property\n    def category(self) -> str:\n        return self.address.category\n\n    def soft_delete(self) -> None:\n        self.deleted_at = datetime.now(timezone.utc)\n        self.updated_at = self.deleted_at\n\n    def restore(self) -> None:\n        self.deleted_at = None\n        self.updated_at = datetime.now(timezone.utc)\n\n    def update_data(self, **kwargs: Any) -> None:\n        \"\"\"Update data fields and touch updated_at.\"\"\"\n        self.data.update(kwargs)\n        self.updated_at = datetime.now(timezone.utc)\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Serialize to a dictionary for storage.\"\"\"\n        return {\n            \"address\": str(self.address),\n            \"type_address\": str(self.type_address) if self.type_address else None,\n            \"data\": self.data,\n            \"created_at\": self.created_at.isoformat(),\n            \"updated_at\": self.updated_at.isoformat(),\n            \"deleted_at\": self.deleted_at.isoformat() if self.deleted_at else None,\n            \"source_type\": self.source_type,\n            \"source_id\": self.source_id,\n        }\n\n    @classmethod\n    def from_dict(cls, d: dict[str, Any]) -> Node:\n        \"\"\"Deserialize from a dictionary.\"\"\"\n        return cls(\n            address=HypernetAddress.parse(d[\"address\"]),\n            type_address=HypernetAddress.parse(d[\"type_address\"]) if d.get(\"type_address\") else None,\n            data=d.get(\"data\", {}),\n            created_at=datetime.fromisoformat(d[\"created_at\"]) if d.get(\"created_at\") else datetime.now(timezone.utc),\n            updated_at=datetime.fromisoformat(d[\"updated_at\"]) if d.get(\"updated_at\") else datetime.now(timezone.utc),\n            deleted_at=datetime.fromisoformat(d[\"deleted_at\"]) if d.get(\"deleted_at\") else None,\n            source_type=d.get(\"source_type\"),\n            source_id=d.get(\"source_id\"),\n        )\n\n    def __repr__(self) -> str:\n        return f\"Node({self.address})\"\n"
  },
  "created_at": "2026-02-17T01:23:28.543951+00:00",
  "updated_at": "2026-02-17T01:23:28.543951+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:node.py"
}