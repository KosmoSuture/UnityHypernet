{
  "address": "0.1.3.4",
  "type_address": null,
  "data": {
    "name": "link.py",
    "type": "file",
    "extension": ".py",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\hypernet\\link.py",
    "size": 4256,
    "content": "\"\"\"\nHypernet Link\n\nLinks are first-class objects that represent relationships between nodes.\nThey have their own addresses in the 0.6.* space and can carry metadata.\n\nA link is a directed edge in the Hypernet graph. Bidirectional links\nare represented by a flag, not by duplicate edges.\n\"\"\"\n\nfrom __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom typing import Any, Optional\n\nfrom .address import HypernetAddress\n\n\n# Standard link types from the addressing spec (0.6.*)\nPERSON_TO_PERSON = \"0.6.1\"    # friendship, family, colleague\nPERSON_TO_OBJECT = \"0.6.2\"    # ownership, creation, usage\nOBJECT_TO_OBJECT = \"0.6.3\"    # references, derives_from, part_of\nTEMPORAL = \"0.6.4\"             # before, after, during\nSPATIAL = \"0.6.5\"              # located_at, near, inside\n\n# Relationship subtypes\nCONTAINS = \"contains\"\nSOURCE = \"source\"\nDUPLICATE_OF = \"duplicate_of\"\nVARIANT_OF = \"variant_of\"\nRELATED_TO = \"related_to\"\nATTENDED_BY = \"attended_by\"\nDOCUMENTED_IN = \"documented_in\"\nLOCATED_AT = \"located_at\"\nDURING = \"during\"\n\n\n@dataclass\nclass Link:\n    \"\"\"A directed relationship between two nodes in the Hypernet graph.\"\"\"\n\n    from_address: HypernetAddress\n    to_address: HypernetAddress\n    link_type: str                        # Category from 0.6.* (e.g., \"0.6.1\")\n    relationship: str                     # Specific relationship (e.g., \"contains\", \"related_to\")\n    address: Optional[HypernetAddress] = None  # Link's own address (optional)\n    strength: float = 1.0                 # 0.0 to 1.0 confidence/weight\n    bidirectional: bool = False\n    data: dict[str, Any] = field(default_factory=dict)\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    sort_order: Optional[int] = None      # For ordered relationships\n\n    def __post_init__(self):\n        if not 0.0 <= self.strength <= 1.0:\n            raise ValueError(f\"Link strength must be 0.0-1.0, got {self.strength}\")\n        if self.from_address == self.to_address:\n            raise ValueError(\"Self-links are not allowed\")\n\n    def connects(self, address: HypernetAddress) -> bool:\n        \"\"\"True if this link connects to/from the given address.\"\"\"\n        if self.from_address == address:\n            return True\n        if self.bidirectional and self.to_address == address:\n            return True\n        return False\n\n    def other_end(self, address: HypernetAddress) -> Optional[HypernetAddress]:\n        \"\"\"Given one end of the link, return the other end.\"\"\"\n        if self.from_address == address:\n            return self.to_address\n        if self.to_address == address and self.bidirectional:\n            return self.from_address\n        return None\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"from_address\": str(self.from_address),\n            \"to_address\": str(self.to_address),\n            \"link_type\": self.link_type,\n            \"relationship\": self.relationship,\n            \"address\": str(self.address) if self.address else None,\n            \"strength\": self.strength,\n            \"bidirectional\": self.bidirectional,\n            \"data\": self.data,\n            \"created_at\": self.created_at.isoformat(),\n            \"sort_order\": self.sort_order,\n        }\n\n    @classmethod\n    def from_dict(cls, d: dict[str, Any]) -> Link:\n        return cls(\n            from_address=HypernetAddress.parse(d[\"from_address\"]),\n            to_address=HypernetAddress.parse(d[\"to_address\"]),\n            link_type=d[\"link_type\"],\n            relationship=d[\"relationship\"],\n            address=HypernetAddress.parse(d[\"address\"]) if d.get(\"address\") else None,\n            strength=d.get(\"strength\", 1.0),\n            bidirectional=d.get(\"bidirectional\", False),\n            data=d.get(\"data\", {}),\n            created_at=datetime.fromisoformat(d[\"created_at\"]) if d.get(\"created_at\") else datetime.now(timezone.utc),\n            sort_order=d.get(\"sort_order\"),\n        )\n\n    def __repr__(self) -> str:\n        arrow = \"<->\" if self.bidirectional else \"->\"\n        return f\"Link({self.from_address} {arrow} {self.to_address} [{self.relationship}])\"\n"
  },
  "created_at": "2026-02-15T11:54:04.132163+00:00",
  "updated_at": "2026-02-15T11:54:04.132163+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:link.py"
}