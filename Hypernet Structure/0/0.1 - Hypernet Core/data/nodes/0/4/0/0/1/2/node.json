{
  "address": "0.4.0.0.1.2",
  "type_address": null,
  "data": {
    "name": "0.0.1.2-INTEGRATION.md",
    "type": "file",
    "extension": ".md",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.4 - Object Type Registry\\0.0.1 - Core Types\\0.0.1.2-INTEGRATION.md",
    "size": 35223,
    "content": "# INTEGRATION - External Service Connection Object Type\n\n**Type ID:** `hypernet.core.integration`\n**Version:** 1.0\n**Category:** 0.0.1 - Core Types\n**Parent:** BaseObject\n**Status:** Active - Phase 1 Priority\n**Created:** 2026-02-09\n**Last Updated:** 2026-02-09\n\n---\n\n## Object Type Metadata\n\n```yaml\ntype_name: \"Integration\"\ntype_id: \"hypernet.core.integration\"\nversion: \"1.0\"\nparent_type: \"BaseObject\"\ncategory: \"0.0.1 - Core Types\"\nabstract: false\ninstantiable: true\n```\n\n---\n\n## Purpose and Description\n\n### What is an Integration?\n\nAn Integration represents a connection between a Hypernet user and an external service (Instagram, Google Photos, Gmail, Dropbox, etc.). It manages OAuth2 authentication, token lifecycle, sync state, and serves as the source attribution for all data imported from external platforms.\n\n### Core Functions\n\n1. **Authentication Management** - Store and refresh OAuth2 tokens for external services\n2. **Sync State Tracking** - Monitor sync progress, cursors, and status\n3. **Source Attribution** - Link imported objects back to their origin\n4. **Configuration Storage** - User preferences for sync behavior\n5. **Error Handling** - Track and report integration failures\n\n### Why This Matters\n\nIntegrations are central to Hypernet's data unification vision. They enable:\n- Automatic import of photos from Instagram, Google Photos, iCloud\n- Email sync from Gmail, Outlook\n- Document sync from Dropbox, Google Drive\n- Social media post archival from Facebook, Twitter\n- Calendar sync from Google Calendar, Outlook\n\nWithout Integrations, Hypernet would be limited to manually uploaded data. With Integrations, Hypernet becomes the universal personal data hub that automatically stays synchronized with your digital life.\n\n### When to Use\n\n- User connects their Instagram account to import photos\n- Syncing Google Photos library to Hypernet\n- Importing email archives from Gmail\n- Backing up Dropbox files\n- Any scenario requiring external data source connection\n\n---\n\n## Inherited Fields from BaseObject\n\n```yaml\nid: UUID\n  - Unique integration identifier\n\nuser_id: UUID\n  - Owner of this integration\n  - User who authorized the connection\n\ncreated_at: DateTime\n  - When integration was first connected\n\nupdated_at: DateTime\n  - Last modification timestamp\n  - Updated on token refresh, sync, or settings change\n\ndeleted_at: DateTime (nullable)\n  - Soft delete timestamp for disconnected integrations\n  - Preserves historical sync data\n\nsource_type: String\n  - Always \"integration\"\n\nsource_id: String\n  - External service identifier (optional)\n\nmetadata: JSONB\n  - Service-specific configuration and statistics\n```\n\n---\n\n## Required Fields\n\n### Integration Identity\n\n```yaml\nintegration_type: String(50)\n  type: String\n  max_length: 50\n  nullable: false\n  indexed: true\n  description: \"Type of external service\"\n  allowed_values:\n    # Social Media\n    - \"instagram\"\n    - \"facebook\"\n    - \"twitter\"\n    - \"linkedin\"\n    - \"tiktok\"\n    # Photo Services\n    - \"google_photos\"\n    - \"icloud_photos\"\n    - \"flickr\"\n    - \"smugmug\"\n    # Cloud Storage\n    - \"dropbox\"\n    - \"google_drive\"\n    - \"onedrive\"\n    - \"box\"\n    # Email\n    - \"gmail\"\n    - \"outlook\"\n    - \"imap\"\n    # Productivity\n    - \"google_calendar\"\n    - \"outlook_calendar\"\n    - \"notion\"\n    - \"evernote\"\n    # Other\n    - \"spotify\"\n    - \"fitbit\"\n    - \"apple_health\"\n  validation:\n    - Must be lowercase\n    - Must match supported integration types\n  usage:\n    - Determines OAuth2 provider configuration\n    - Routes sync tasks to correct handler\n\nintegration_name: String(200)\n  type: String\n  max_length: 200\n  nullable: false\n  description: \"User-friendly name for this integration\"\n  examples:\n    - \"My Instagram\"\n    - \"Work Gmail\"\n    - \"Personal Google Photos\"\n    - \"Family Dropbox\"\n  default: \"{integration_type} Account\"\n  purpose: \"Allow users to distinguish between multiple accounts of same type\"\n  validation:\n    - Minimum 1 character\n    - Maximum 200 characters\n```\n\n### Integration Status\n\n```yaml\nstatus: Enum\n  type: String\n  max_length: 20\n  nullable: false\n  indexed: true\n  default: \"pending\"\n  description: \"Current state of integration\"\n  allowed_values:\n    - \"pending\": OAuth flow initiated but not completed\n    - \"connected\": Active and authenticated\n    - \"disconnected\": User manually disconnected\n    - \"error\": Authentication or sync error\n    - \"expired\": OAuth token expired and refresh failed\n  transitions:\n    pending -> connected: OAuth flow completed\n    connected -> disconnected: User disconnects\n    connected -> error: Sync or auth failure\n    connected -> expired: Token refresh failed\n    error -> connected: Manual reconnection\n    expired -> connected: Token refreshed\n  constraints:\n    - Default on creation is \"pending\"\n    - \"connected\" required for syncing\n```\n\n---\n\n## Optional Fields\n\n### OAuth2 Token Management\n\n```yaml\ntoken_expires_at: DateTime\n  type: DateTime\n  nullable: true\n  timezone: true (UTC)\n  description: \"When the current access token expires\"\n  purpose: \"Trigger automatic token refresh before expiration\"\n  notes:\n    - Null if token doesn't expire (rare)\n    - Used by background job to refresh tokens proactively\n    - Typically 1-2 hours from token issuance\n  examples:\n    - \"2026-02-09T13:00:00Z\"\n\nlast_token_refresh_at: DateTime\n  type: DateTime\n  nullable: true\n  timezone: true (UTC)\n  description: \"When token was last successfully refreshed\"\n  purpose: \"Audit trail and refresh frequency monitoring\"\n```\n\n### Sync State Tracking\n\n```yaml\nlast_sync_at: DateTime\n  type: DateTime\n  nullable: true\n  timezone: true (UTC)\n  description: \"Timestamp of most recent sync attempt\"\n  updated: \"On every sync start\"\n  usage:\n    - Display last sync time to user\n    - Calculate time since last sync\n    - Trigger overdue sync alerts\n\nlast_sync_status: Enum\n  type: String\n  max_length: 20\n  nullable: true\n  description: \"Result of most recent sync\"\n  allowed_values:\n    - \"success\": Sync completed without errors\n    - \"partial\": Some items synced, some failed\n    - \"failed\": Sync completely failed\n  examples:\n    - \"success\": 150 new photos imported\n    - \"partial\": 145 photos imported, 5 failed (quota exceeded)\n    - \"failed\": Authentication error\n\nlast_sync_error: Text\n  type: Text\n  nullable: true\n  description: \"Error message from most recent failed sync\"\n  examples:\n    - \"Rate limit exceeded (429)\"\n    - \"Token expired\"\n    - \"Insufficient permissions\"\n  purpose: \"Debugging and user error reporting\"\n\nsync_cursor: Text\n  type: Text\n  nullable: true\n  description: \"Pagination cursor for incremental sync\"\n  format: \"Platform-specific string\"\n  examples:\n    - Instagram: \"AQHWyNw...\"\n    - Dropbox: \"AAF1xDnKw...\"\n    - Gmail: \"page_token_xyz\"\n  purpose: \"Resume sync from where we left off\"\n  notes:\n    - Null for initial sync\n    - Updated after each successful page\n    - Platform-specific format\n\nitems_synced: Integer\n  type: Integer\n  nullable: false\n  default: 0\n  description: \"Total number of items successfully imported\"\n  constraints:\n    - Must be >= 0\n  updated: \"Incremented after each successful item import\"\n  purpose: \"Show user sync progress and statistics\"\n\nitems_failed: Integer\n  type: Integer\n  nullable: false\n  default: 0\n  description: \"Total number of items that failed to import\"\n  constraints:\n    - Must be >= 0\n  purpose: \"Track sync quality and errors\"\n```\n\n### Configuration\n\n```yaml\nis_enabled: Boolean\n  type: Boolean\n  nullable: false\n  default: true\n  indexed: true\n  description: \"Whether automatic syncing is enabled\"\n  usage:\n    - User can pause sync without disconnecting\n    - Useful for temporary bandwidth limitations\n    - Background jobs skip disabled integrations\n  transitions:\n    - User toggles in settings\n    - Admin can disable for all users (maintenance)\n\nauto_sync: Boolean\n  type: Boolean\n  nullable: false\n  default: true\n  description: \"Whether to automatically trigger periodic syncs\"\n  usage:\n    - true: Background job syncs on schedule\n    - false: Sync only on manual trigger\n\nsync_frequency: Enum\n  type: String\n  max_length: 20\n  nullable: false\n  default: \"hourly\"\n  description: \"How often to automatically sync\"\n  allowed_values:\n    - \"realtime\": Webhook-based (if supported)\n    - \"every_15min\": Every 15 minutes\n    - \"hourly\": Once per hour\n    - \"daily\": Once per day at midnight\n    - \"weekly\": Once per week\n    - \"manual\": Only on user request\n  notes:\n    - Actual frequency may be rate-limited by provider\n    - \"realtime\" requires webhook support from provider\n```\n\n---\n\n## Metadata Schema\n\nThe `metadata` JSONB field stores service-specific data and statistics:\n\n```json\n{\n  \"oauth\": {\n    \"access_token_hash\": \"sha256-hash\",\n    \"refresh_token_hash\": \"sha256-hash\",\n    \"scope\": [\"read_photos\", \"read_user\"],\n    \"token_type\": \"Bearer\"\n  },\n  \"service\": {\n    \"instagram\": {\n      \"user_id\": \"17841405793187218\",\n      \"username\": \"user123\",\n      \"profile_picture_url\": \"https://...\",\n      \"account_type\": \"personal|business\",\n      \"followers_count\": 1543,\n      \"media_count\": 892\n    },\n    \"google\": {\n      \"email\": \"user@gmail.com\",\n      \"name\": \"John Doe\",\n      \"picture\": \"https://...\",\n      \"locale\": \"en\"\n    },\n    \"dropbox\": {\n      \"account_id\": \"dbid:AAH4f99...\",\n      \"email\": \"user@example.com\",\n      \"display_name\": \"John Doe\",\n      \"quota\": {\n        \"used\": 5368709120,\n        \"allocated\": 107374182400\n      }\n    }\n  },\n  \"sync_config\": {\n    \"import_likes\": true,\n    \"import_comments\": true,\n    \"import_stories\": false,\n    \"download_originals\": true,\n    \"create_albums\": true,\n    \"ignore_before\": \"2020-01-01T00:00:00Z\"\n  },\n  \"statistics\": {\n    \"total_items\": 1543,\n    \"photos_synced\": 1456,\n    \"videos_synced\": 87,\n    \"documents_synced\": 0,\n    \"total_bytes\": 8589934592,\n    \"sync_duration_seconds\": 320,\n    \"items_per_second\": 4.8,\n    \"first_sync_at\": \"2024-01-15T10:00:00Z\",\n    \"last_successful_sync_at\": \"2026-02-09T10:00:00Z\"\n  },\n  \"error_history\": [\n    {\n      \"timestamp\": \"2026-02-08T15:30:00Z\",\n      \"error\": \"Rate limit exceeded\",\n      \"code\": \"429\",\n      \"resolved\": true\n    }\n  ],\n  \"webhooks\": {\n    \"enabled\": true,\n    \"subscription_id\": \"sub_abc123\",\n    \"verified_at\": \"2024-01-15T10:05:00Z\"\n  }\n}\n```\n\n---\n\n## Relationships to Other Object Types\n\n### Ownership (Incoming)\n\n```yaml\nowned_by: User\n  description: \"User who authorized this integration\"\n  cardinality: \"N:1 (many integrations, one user)\"\n  implementation: \"user_id foreign key\"\n  constraints:\n    - User must exist\n    - User must be verified (is_verified=true)\n    - Multiple integrations of same type allowed per user\n  examples:\n    - User has \"Personal Instagram\" and \"Business Instagram\"\n    - User has \"Work Gmail\" and \"Personal Gmail\"\n```\n\n### Source Attribution (Outgoing)\n\n```yaml\nsources: Media Objects\n  description: \"All media imported from this integration\"\n  cardinality: \"1:N (one integration, many media)\"\n  link_type: \"source\"\n  implementation: \"Link object with link_type='source'\"\n  query_pattern:\n    from_object_id: media.id\n    to_object_id: integration.id\n    link_type: \"source\"\n  examples:\n    - Photo sourced from Instagram integration\n    - Video sourced from Google Photos integration\n    - Document sourced from Dropbox integration\n  purpose:\n    - Track where data came from\n    - Handle duplicate detection\n    - Resync specific integration's data\n```\n\n---\n\n## API Endpoints\n\n### OAuth2 Flow\n\n```http\nGET /api/v1/integrations/oauth/start\n  Description: Initiate OAuth2 flow for external service\n  Query Parameters:\n    type: string (required) - integration_type\n    name: string (optional) - custom integration_name\n    redirect_uri: string (optional) - custom callback URL\n  Process:\n    1. Create Integration record (status=\"pending\")\n    2. Generate OAuth2 state token (CSRF protection)\n    3. Build authorization URL with required scopes\n    4. Redirect user to external service\n  Response: 302 Redirect\n    Location: https://instagram.com/oauth/authorize?client_id=...&state=...\n  Security:\n    - State token stored in session\n    - PKCE challenge generated for supported providers\n    - Rate limited: 10 requests per hour per user\n\nGET /api/v1/integrations/oauth/callback\n  Description: Complete OAuth2 flow after user authorization\n  Query Parameters:\n    code: string (required) - OAuth2 authorization code\n    state: string (required) - CSRF protection token\n    error: string (optional) - OAuth2 error if user denied\n  Process:\n    1. Verify state token matches session\n    2. Exchange code for access_token and refresh_token\n    3. Fetch user profile from external service\n    4. Update Integration record (status=\"connected\")\n    5. Store tokens securely (hashed)\n    6. Trigger initial sync job\n  Response: 302 Redirect\n    Location: /integrations/{id}?success=true\n  Error Handling:\n    - Invalid state: 400 Bad Request\n    - Token exchange failure: 502 Bad Gateway\n    - User denied: Redirect with error message\n```\n\n### Management\n\n```http\nGET /api/v1/integrations\n  Description: List all integrations for authenticated user\n  Query Parameters:\n    status: string (optional) - filter by status\n    integration_type: string (optional) - filter by type\n    is_enabled: boolean (optional) - filter by enabled state\n    include_deleted: boolean (optional) - include soft-deleted\n  Response: 200 OK\n    {\n      \"items\": [\n        {integration object},\n        {integration object}\n      ],\n      \"total\": 5\n    }\n  Security:\n    - Only returns integrations owned by authenticated user\n    - Token hashes never included in response\n\nGET /api/v1/integrations/{id}\n  Description: Get single integration details\n  Path Parameters:\n    id: UUID (required) - integration ID\n  Response: 200 OK\n    {integration object with full details}\n  Security:\n    - User must own integration\n    - Tokens never returned\n\nPATCH /api/v1/integrations/{id}\n  Description: Update integration settings\n  Path Parameters:\n    id: UUID (required) - integration ID\n  Request Body:\n    {\n      \"integration_name\": \"New Name\",\n      \"is_enabled\": false,\n      \"auto_sync\": true,\n      \"sync_frequency\": \"daily\",\n      \"metadata\": {\n        \"sync_config\": {...}\n      }\n    }\n  Response: 200 OK\n    {updated integration object}\n  Validation:\n    - Cannot change: id, user_id, integration_type, created_at\n    - Can change: name, enabled state, sync settings\n  Security:\n    - User must own integration\n\nDELETE /api/v1/integrations/{id}\n  Description: Disconnect integration (soft delete)\n  Path Parameters:\n    id: UUID (required) - integration ID\n  Query Parameters:\n    delete_data: boolean (optional) - also delete imported data\n  Process:\n    1. Set deleted_at timestamp\n    2. Set status=\"disconnected\"\n    3. Revoke OAuth tokens at provider (if supported)\n    4. Optionally delete all imported media\n  Response: 204 No Content\n  Security:\n    - User must own integration\n    - Confirmation required if delete_data=true\n```\n\n### Sync Operations\n\n```http\nPOST /api/v1/integrations/{id}/sync\n  Description: Trigger manual sync\n  Path Parameters:\n    id: UUID (required) - integration ID\n  Request Body (optional):\n    {\n      \"full_sync\": false,\n      \"reset_cursor\": false\n    }\n  Process:\n    1. Verify integration is connected and enabled\n    2. Check rate limits\n    3. Queue sync job\n    4. Return job ID for status tracking\n  Response: 202 Accepted\n    {\n      \"job_id\": \"job-uuid\",\n      \"status\": \"queued\",\n      \"estimated_duration\": 300\n    }\n  Errors:\n    - Integration not connected: 400 Bad Request\n    - Rate limited: 429 Too Many Requests\n    - Sync already in progress: 409 Conflict\n  Security:\n    - User must own integration\n    - Rate limited: 1 manual sync per 5 minutes per integration\n\nGET /api/v1/integrations/{id}/sync-status\n  Description: Get current sync status\n  Path Parameters:\n    id: UUID (required) - integration ID\n  Response: 200 OK\n    {\n      \"is_syncing\": true,\n      \"current_job_id\": \"job-uuid\",\n      \"progress\": {\n        \"items_processed\": 150,\n        \"total_items\": 1000,\n        \"percent_complete\": 15\n      },\n      \"last_sync_at\": \"2026-02-09T10:00:00Z\",\n      \"last_sync_status\": \"success\",\n      \"items_synced\": 10543,\n      \"items_failed\": 12\n    }\n\nGET /api/v1/integrations/{id}/history\n  Description: Get sync history\n  Path Parameters:\n    id: UUID (required) - integration ID\n  Query Parameters:\n    limit: integer (default 50, max 100)\n    offset: integer (default 0)\n  Response: 200 OK\n    {\n      \"items\": [\n        {\n          \"timestamp\": \"2026-02-09T10:00:00Z\",\n          \"status\": \"success\",\n          \"items_synced\": 25,\n          \"duration_seconds\": 45\n        }\n      ],\n      \"total\": 150\n    }\n```\n\n### Token Management (Admin Only)\n\n```http\nPOST /api/v1/integrations/{id}/refresh-token\n  Description: Manually refresh OAuth token\n  Headers:\n    Authorization: Bearer {admin_token}\n  Response: 200 OK\n    {\n      \"token_refreshed\": true,\n      \"expires_at\": \"2026-02-09T13:00:00Z\"\n    }\n\nPOST /api/v1/integrations/{id}/reconnect\n  Description: Re-initiate OAuth flow for existing integration\n  Process:\n    1. Preserve integration_name and metadata\n    2. Start OAuth flow\n    3. Update existing integration on callback\n  Response: 302 Redirect\n    Location: https://service.com/oauth/authorize...\n```\n\n---\n\n## Database Schema (SQLAlchemy Model Reference)\n\n```python\nfrom sqlalchemy import (\n    Column, String, Boolean, Integer, Text,\n    DateTime, Enum as SQLEnum, ForeignKey, Index, CheckConstraint\n)\nfrom sqlalchemy.dialects.postgresql import UUID, JSONB\nfrom sqlalchemy.orm import relationship\nfrom app.models.base import BaseObject\nfrom datetime import datetime\n\nclass Integration(BaseObject):\n    \"\"\"\n    External service connection with OAuth2 and sync management\n\n    Inherits from BaseObject: id, user_id, created_at, updated_at,\n    deleted_at, source_type, source_id, metadata\n    \"\"\"\n\n    __tablename__ = \"integrations\"\n\n    # Integration Identity\n    integration_type = Column(\n        String(50),\n        nullable=False,\n        index=True,\n        doc=\"Type of external service (instagram, gmail, etc.)\"\n    )\n    integration_name = Column(\n        String(200),\n        nullable=False,\n        doc=\"User-friendly name for this integration\"\n    )\n\n    # Status\n    status = Column(\n        SQLEnum(\n            'pending', 'connected', 'disconnected', 'error', 'expired',\n            name='integration_status_enum'\n        ),\n        nullable=False,\n        default='pending',\n        index=True,\n        doc=\"Current state of integration\"\n    )\n\n    # OAuth2 Token Management\n    token_expires_at = Column(\n        DateTime(timezone=True),\n        nullable=True,\n        doc=\"When access token expires\"\n    )\n    last_token_refresh_at = Column(\n        DateTime(timezone=True),\n        nullable=True,\n        doc=\"When token was last refreshed\"\n    )\n\n    # Sync State Tracking\n    last_sync_at = Column(\n        DateTime(timezone=True),\n        nullable=True,\n        doc=\"Most recent sync timestamp\"\n    )\n    last_sync_status = Column(\n        SQLEnum('success', 'partial', 'failed', name='sync_status_enum'),\n        nullable=True,\n        doc=\"Result of most recent sync\"\n    )\n    last_sync_error = Column(\n        Text,\n        nullable=True,\n        doc=\"Error message from last failed sync\"\n    )\n    sync_cursor = Column(\n        Text,\n        nullable=True,\n        doc=\"Pagination cursor for incremental sync\"\n    )\n    items_synced = Column(\n        Integer,\n        nullable=False,\n        default=0,\n        doc=\"Total items successfully imported\"\n    )\n    items_failed = Column(\n        Integer,\n        nullable=False,\n        default=0,\n        doc=\"Total items that failed to import\"\n    )\n\n    # Configuration\n    is_enabled = Column(\n        Boolean,\n        nullable=False,\n        default=True,\n        index=True,\n        doc=\"Whether automatic syncing is enabled\"\n    )\n    auto_sync = Column(\n        Boolean,\n        nullable=False,\n        default=True,\n        doc=\"Whether to automatically trigger periodic syncs\"\n    )\n    sync_frequency = Column(\n        SQLEnum(\n            'realtime', 'every_15min', 'hourly', 'daily', 'weekly', 'manual',\n            name='sync_frequency_enum'\n        ),\n        nullable=False,\n        default='hourly',\n        doc=\"How often to automatically sync\"\n    )\n\n    # Relationships\n    owner = relationship(\n        \"User\",\n        foreign_keys=[BaseObject.user_id],\n        back_populates=\"integrations\",\n        doc=\"User who owns this integration\"\n    )\n    sourced_media = relationship(\n        \"Link\",\n        foreign_keys=\"Link.to_object_id\",\n        primaryjoin=\"and_(Link.to_object_id==Integration.id, \"\n                    \"Link.link_type=='source')\",\n        doc=\"Media objects sourced from this integration\"\n    )\n\n    # Table Constraints\n    __table_args__ = (\n        CheckConstraint(\n            \"items_synced >= 0\",\n            name=\"check_items_synced_positive\"\n        ),\n        CheckConstraint(\n            \"items_failed >= 0\",\n            name=\"check_items_failed_positive\"\n        ),\n        # Composite indexes\n        Index('idx_integration_user_type', 'user_id', 'integration_type'),\n        Index('idx_integration_status_enabled', 'status', 'is_enabled'),\n        Index('idx_integration_next_sync',\n              'is_enabled', 'auto_sync', 'last_sync_at',\n              postgresql_where=\"status='connected' AND is_enabled=true\"),\n    )\n\n    def __repr__(self):\n        return f\"<Integration(id={self.id}, type={self.integration_type}, \" \\\n               f\"user={self.user_id}, status={self.status})>\"\n\n    @property\n    def is_connected(self):\n        \"\"\"Check if integration is currently connected\"\"\"\n        return self.status == 'connected'\n\n    @property\n    def needs_token_refresh(self):\n        \"\"\"Check if token needs refreshing\"\"\"\n        if not self.token_expires_at:\n            return False\n        # Refresh 5 minutes before expiry\n        from datetime import timedelta\n        threshold = datetime.utcnow() + timedelta(minutes=5)\n        return self.token_expires_at <= threshold\n\n    @property\n    def sync_success_rate(self):\n        \"\"\"Calculate sync success rate\"\"\"\n        total = self.items_synced + self.items_failed\n        if total == 0:\n            return 0.0\n        return (self.items_synced / total) * 100\n\n    def mark_sync_started(self):\n        \"\"\"Mark sync as started\"\"\"\n        self.last_sync_at = datetime.utcnow()\n        self.updated_at = datetime.utcnow()\n\n    def mark_sync_complete(self, status, items_synced=0, items_failed=0, error=None):\n        \"\"\"Mark sync as complete with results\"\"\"\n        self.last_sync_status = status\n        self.items_synced += items_synced\n        self.items_failed += items_failed\n        if error:\n            self.last_sync_error = str(error)\n        self.updated_at = datetime.utcnow()\n\n    def update_sync_cursor(self, cursor):\n        \"\"\"Update pagination cursor for incremental sync\"\"\"\n        self.sync_cursor = cursor\n        self.updated_at = datetime.utcnow()\n```\n\n---\n\n## Privacy and Security Considerations\n\n### Token Storage\n\n1. **Never Store Plaintext Tokens**\n   - Access tokens and refresh tokens stored as SHA-256 hashes\n   - Actual tokens encrypted at rest using AES-256\n   - Tokens never returned in API responses\n   - Tokens never logged\n\n2. **Token Encryption**\n   ```python\n   from cryptography.fernet import Fernet\n\n   def encrypt_token(token: str, key: bytes) -> str:\n       f = Fernet(key)\n       return f.encrypt(token.encode()).decode()\n\n   def decrypt_token(encrypted: str, key: bytes) -> str:\n       f = Fernet(key)\n       return f.decrypt(encrypted.encode()).decode()\n   ```\n\n3. **Token Rotation**\n   - Refresh tokens automatically before expiry\n   - Revoke old tokens after successful refresh\n   - Manual token rotation available via admin API\n\n### OAuth2 Security\n\n1. **CSRF Protection**\n   - State parameter generated per OAuth flow\n   - State stored in secure session\n   - State verified on callback\n\n2. **PKCE (Proof Key for Code Exchange)**\n   - Used for all OAuth2 flows when supported\n   - Code verifier generated client-side\n   - Code challenge sent to authorization server\n\n3. **Scope Minimization**\n   - Request only necessary permissions\n   - User shown exact permissions requested\n   - Scopes stored in metadata for audit\n\n### Data Protection\n\n1. **Imported Data Ownership**\n   - All imported data owned by user\n   - Integration deletion can optionally delete imported data\n   - Data not shared with other users without explicit permission\n\n2. **Rate Limiting**\n   - Protect external services from abuse\n   - Per-integration rate limits\n   - Per-user aggregate rate limits\n   - Backoff on rate limit errors\n\n3. **Audit Trail**\n   - All sync operations logged\n   - OAuth events logged\n   - Token refresh logged\n   - Integration disconnection logged\n\n---\n\n## Validation Rules\n\n### On Creation\n\n```yaml\nintegration_type:\n  - Must be in allowed list\n  - Must be lowercase\n  - Maximum 50 characters\n\nintegration_name:\n  - Minimum 1 character\n  - Maximum 200 characters\n  - Defaults to \"{integration_type} Account\"\n\nstatus:\n  - Must be \"pending\" on creation\n  - Changed to \"connected\" after OAuth completion\n\nuser_id:\n  - Must reference existing User\n  - User must be verified (is_verified=true)\n```\n\n### On Update\n\n```yaml\nimmutable_fields:\n  - id\n  - user_id\n  - integration_type\n  - created_at\n\nmutable_fields:\n  - integration_name\n  - is_enabled\n  - auto_sync\n  - sync_frequency\n  - metadata\n\nsystem_managed:\n  - status (via OAuth flow or sync errors)\n  - token_expires_at (via token refresh)\n  - last_sync_at (via sync operations)\n  - items_synced (via sync operations)\n```\n\n### Database Constraints\n\n```sql\n-- Check constraints\nCHECK (status IN ('pending', 'connected', 'disconnected', 'error', 'expired'))\nCHECK (last_sync_status IS NULL OR last_sync_status IN ('success', 'partial', 'failed'))\nCHECK (items_synced >= 0)\nCHECK (items_failed >= 0)\n\n-- Indexes\nCREATE INDEX idx_integration_user_type ON integrations(user_id, integration_type);\nCREATE INDEX idx_integration_status ON integrations(status, is_enabled);\nCREATE INDEX idx_integration_next_sync ON integrations(is_enabled, auto_sync, last_sync_at)\n  WHERE status = 'connected' AND is_enabled = true;\nCREATE INDEX idx_integration_deleted ON integrations(deleted_at)\n  WHERE deleted_at IS NOT NULL;\n```\n\n---\n\n## Use Cases and Examples\n\n### Example 1: Instagram Integration\n\n```json\n{\n  \"id\": \"int-550e8400-e29b-41d4-a716-446655440000\",\n  \"user_id\": \"user-123-uuid\",\n  \"integration_type\": \"instagram\",\n  \"integration_name\": \"My Personal Instagram\",\n  \"status\": \"connected\",\n  \"token_expires_at\": \"2026-02-09T13:00:00Z\",\n  \"last_token_refresh_at\": \"2026-02-09T11:00:00Z\",\n  \"last_sync_at\": \"2026-02-09T11:30:00Z\",\n  \"last_sync_status\": \"success\",\n  \"last_sync_error\": null,\n  \"sync_cursor\": \"AQHWyNwCwT7NHJmUzFsU...\",\n  \"items_synced\": 1543,\n  \"items_failed\": 2,\n  \"is_enabled\": true,\n  \"auto_sync\": true,\n  \"sync_frequency\": \"hourly\",\n  \"metadata\": {\n    \"service\": {\n      \"instagram\": {\n        \"user_id\": \"17841405793187218\",\n        \"username\": \"user123\",\n        \"account_type\": \"personal\",\n        \"media_count\": 892\n      }\n    },\n    \"sync_config\": {\n      \"import_likes\": true,\n      \"import_comments\": true,\n      \"create_albums\": true\n    },\n    \"statistics\": {\n      \"photos_synced\": 1456,\n      \"videos_synced\": 87,\n      \"total_bytes\": 8589934592\n    }\n  },\n  \"created_at\": \"2024-06-15T10:00:00Z\",\n  \"updated_at\": \"2026-02-09T11:30:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 2: Google Photos Integration\n\n```json\n{\n  \"id\": \"int-550e8400-e29b-41d4-a716-446655440001\",\n  \"user_id\": \"user-123-uuid\",\n  \"integration_type\": \"google_photos\",\n  \"integration_name\": \"Google Photos\",\n  \"status\": \"connected\",\n  \"token_expires_at\": \"2026-02-09T12:00:00Z\",\n  \"last_sync_at\": \"2026-02-09T06:00:00Z\",\n  \"last_sync_status\": \"success\",\n  \"sync_cursor\": \"page_token_xyz\",\n  \"items_synced\": 8943,\n  \"items_failed\": 15,\n  \"is_enabled\": true,\n  \"auto_sync\": true,\n  \"sync_frequency\": \"daily\",\n  \"metadata\": {\n    \"service\": {\n      \"google\": {\n        \"email\": \"user@gmail.com\",\n        \"name\": \"John Doe\"\n      }\n    },\n    \"sync_config\": {\n      \"download_originals\": true,\n      \"ignore_before\": \"2015-01-01T00:00:00Z\"\n    }\n  },\n  \"created_at\": \"2024-01-15T08:00:00Z\",\n  \"updated_at\": \"2026-02-09T06:30:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 3: Disconnected Gmail Integration\n\n```json\n{\n  \"id\": \"int-550e8400-e29b-41d4-a716-446655440002\",\n  \"user_id\": \"user-123-uuid\",\n  \"integration_type\": \"gmail\",\n  \"integration_name\": \"Work Gmail\",\n  \"status\": \"disconnected\",\n  \"token_expires_at\": null,\n  \"last_sync_at\": \"2025-12-01T10:00:00Z\",\n  \"last_sync_status\": \"success\",\n  \"items_synced\": 5432,\n  \"items_failed\": 8,\n  \"is_enabled\": false,\n  \"auto_sync\": false,\n  \"sync_frequency\": \"manual\",\n  \"metadata\": {\n    \"service\": {\n      \"google\": {\n        \"email\": \"work@company.com\"\n      }\n    },\n    \"disconnect_reason\": \"user_requested\",\n    \"disconnect_timestamp\": \"2026-01-01T00:00:00Z\"\n  },\n  \"created_at\": \"2024-03-01T09:00:00Z\",\n  \"updated_at\": \"2026-01-01T00:00:00Z\",\n  \"deleted_at\": \"2026-01-01T00:00:00Z\"\n}\n```\n\n---\n\n## Lifecycle States\n\nIntegrations progress through the following states:\n\n### 1. Pending (OAuth Initiated)\n\n```yaml\nstate: \"pending\"\nstatus: \"pending\"\ncapabilities:\n  - OAuth flow in progress\n  - No syncing possible\n  - Token fields null\ntransitions:\n  - oauth_complete -> Connected\n  - timeout (1 hour) -> Auto-deleted\n```\n\n### 2. Connected (Active)\n\n```yaml\nstate: \"connected\"\nstatus: \"connected\"\nis_enabled: true\ncapabilities:\n  - Full syncing enabled\n  - Auto-sync scheduled\n  - Token refresh automatic\ntransitions:\n  - disconnect -> Disconnected\n  - auth_error -> Error\n  - token_expired -> Expired\n```\n\n### 3. Error (Temporary Failure)\n\n```yaml\nstate: \"error\"\nstatus: \"error\"\ncapabilities:\n  - Syncing paused\n  - User notified of error\n  - Manual reconnection available\ntransitions:\n  - reconnect -> Connected\n  - disconnect -> Disconnected\n  - timeout (7 days) -> Disconnected\n```\n\n### 4. Expired (Token Refresh Failed)\n\n```yaml\nstate: \"expired\"\nstatus: \"expired\"\ncapabilities:\n  - Token refresh failed\n  - Re-authorization required\n  - Historical data preserved\ntransitions:\n  - reauthorize -> Connected\n  - disconnect -> Disconnected\n```\n\n### 5. Disconnected (User Disabled)\n\n```yaml\nstate: \"disconnected\"\nstatus: \"disconnected\"\ndeleted_at: set\ncapabilities:\n  - No syncing\n  - Historical data preserved (unless deleted)\n  - Can reconnect\ntransitions:\n  - reconnect -> Connected\n  - hard_delete -> Permanently Removed\n```\n\n---\n\n## Notes for Implementers\n\n### Sync Implementation Pattern\n\n```python\nasync def sync_integration(integration_id: UUID):\n    \"\"\"Generic sync pattern for all integration types\"\"\"\n    integration = get_integration(integration_id)\n\n    # Pre-sync checks\n    if not integration.is_connected:\n        raise IntegrationNotConnected()\n    if not integration.is_enabled:\n        raise IntegrationDisabled()\n    if integration.needs_token_refresh:\n        await refresh_token(integration)\n\n    # Mark sync started\n    integration.mark_sync_started()\n\n    try:\n        # Get platform-specific sync handler\n        handler = get_sync_handler(integration.integration_type)\n\n        # Perform sync\n        result = await handler.sync(\n            integration=integration,\n            cursor=integration.sync_cursor\n        )\n\n        # Update integration\n        integration.mark_sync_complete(\n            status='success',\n            items_synced=result.items_synced,\n            items_failed=result.items_failed\n        )\n        integration.update_sync_cursor(result.next_cursor)\n\n    except RateLimitError as e:\n        # Backoff and retry\n        integration.mark_sync_complete(status='partial', error=str(e))\n        schedule_retry(integration_id, delay=e.retry_after)\n\n    except AuthenticationError as e:\n        # Mark as error, notify user\n        integration.status = 'error'\n        integration.last_sync_error = str(e)\n        notify_user(integration.user_id, 'integration_error', integration.id)\n```\n\n### Token Refresh Pattern\n\n```python\nasync def refresh_token(integration: Integration):\n    \"\"\"Refresh OAuth2 access token\"\"\"\n    # Get provider config\n    provider = get_oauth_provider(integration.integration_type)\n\n    # Decrypt refresh token\n    refresh_token = decrypt_token(\n        integration.metadata['oauth']['refresh_token_hash'],\n        key=get_encryption_key()\n    )\n\n    # Request new token\n    response = await provider.refresh_token(refresh_token)\n\n    # Update integration\n    integration.token_expires_at = response.expires_at\n    integration.last_token_refresh_at = datetime.utcnow()\n\n    # Store new tokens securely\n    integration.metadata['oauth']['access_token_hash'] = hash_token(response.access_token)\n    if response.refresh_token:\n        integration.metadata['oauth']['refresh_token_hash'] = hash_token(response.refresh_token)\n```\n\n### Background Job Scheduling\n\n```python\n# Schedule auto-sync jobs based on frequency\n@scheduler.task('cron', hour='*', minute='0')\nasync def schedule_hourly_syncs():\n    \"\"\"Find integrations that need hourly sync\"\"\"\n    integrations = get_integrations(\n        status='connected',\n        is_enabled=True,\n        auto_sync=True,\n        sync_frequency='hourly'\n    )\n    for integration in integrations:\n        queue_sync_job(integration.id)\n\n# Monitor token expiry\n@scheduler.task('cron', minute='*/5')\nasync def refresh_expiring_tokens():\n    \"\"\"Refresh tokens expiring in next 5 minutes\"\"\"\n    integrations = get_integrations_with_expiring_tokens(\n        threshold=timedelta(minutes=5)\n    )\n    for integration in integrations:\n        await refresh_token(integration)\n```\n\n---\n\n**Status:** Active - Phase 1 Priority\n**Version:** 1.0\n**Authority:** 0.0.1 - Core Types\n**Created:** 2026-02-09\n**Owner:** Hypernet Core (0.*)\n"
  },
  "created_at": "2026-02-15T11:54:04.591119+00:00",
  "updated_at": "2026-02-15T11:54:04.591119+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:0.0.1.2-INTEGRATION.md"
}