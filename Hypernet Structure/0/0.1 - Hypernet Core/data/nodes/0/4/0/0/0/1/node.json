{
  "address": "0.4.0.0.0.1",
  "type_address": null,
  "data": {
    "name": "00-How-To-Add-New-Types.md",
    "type": "file",
    "extension": ".md",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.4 - Object Type Registry\\0.0.0 - Registry Governance\\00-How-To-Add-New-Types.md",
    "size": 13423,
    "content": "# How to Add New Object Types to the Hypernet Registry\n\n**Authority:** 0.0 - Object Type Registry\n**Version:** 1.0\n**Status:** Canonical Process\n**Last Updated:** 2026-02-04\n\n---\n\n## Purpose\n\nThis document defines the **official process** for adding new object types to the Hypernet registry.\n\n**Rule:** Nothing can exist in Hypernet without being defined in 0.0 first.\n\n---\n\n## Who Can Propose New Types?\n\n**Anyone:**\n- Humans (developers, users, domain experts)\n- AI (agents, assistants, autonomous systems)\n- Organizations (businesses, institutions)\n- The community (via proposals and discussion)\n\n**Principle:** Good ideas can come from anywhere. The registry validates coherence, not source.\n\n---\n\n## When to Add a New Type\n\n### Valid Reasons\n\nAdd a new type when:\n1. **Represents distinct entity** - It's fundamentally different from existing types\n2. **Has unique properties** - Fields that don't fit existing types\n3. **Enables new use cases** - Unlocks functionality that wasn't possible\n4. **Widely useful** - Multiple users/integrations will benefit\n5. **Well-defined** - Clear boundaries and purpose\n\n### Invalid Reasons\n\n**Do NOT add a new type for:**\n1. **Minor variations** - Use metadata fields instead\n2. **Platform-specific quirks** - Use subtypes or metadata\n3. **One-off needs** - Use existing types with metadata\n4. **Premature optimization** - Wait until the need is proven\n5. **Personal preference** - Must have objective value\n\n### Examples\n\n**Good:**\n- Add `MedicalRecord` type (distinct from Document, has medical-specific fields)\n- Add `VoiceCall` type (different from ChatMessage, has call-specific properties)\n- Add `Transaction` type (financial data with unique validation rules)\n\n**Bad:**\n- Add `InstagramPhoto` type (just a Photo with instagram metadata)\n- Add `PNGImage` type (just a Photo with mime_type='image/png')\n- Add `MyCustomDocument` type (use Document with metadata instead)\n\n---\n\n## The Type Definition Template\n\nEvery new type must have a complete definition document with these sections:\n\n### 1. Identity\n```yaml\ntype_name: \"Photo\"\ntype_id: \"hypernet.media.photo\"\nversion: \"1.0\"\nparent_type: \"Media\" (if inheriting)\ncategory: \"0.0.2 - Media Types\"\n```\n\n### 2. Purpose\n```markdown\n## Purpose\n\n**What:** Images captured by cameras or created digitally\n**Why:** Central to personal data - photos are primary memories\n**When:** Use for any image file (JPEG, PNG, HEIC, etc.)\n```\n\n### 3. Core Fields\n\n**Inherited from BaseObject:**\n```yaml\nid: UUID\nuser_id: UUID\ncreated_at: DateTime\nupdated_at: DateTime\ndeleted_at: DateTime (soft delete)\nsource_type: String (where it came from)\nsource_id: String (external ID)\nmetadata: JSONB (extensible)\n```\n\n**Type-Specific Required:**\n```yaml\nfilename: String (255 chars max)\nmedia_type: Enum ['photo'] (fixed value for this type)\nmime_type: String (image/jpeg, image/png, etc.)\nfile_size: Integer (bytes)\nfile_path: String (location on disk)\nhash: String (SHA-256 for deduplication)\n```\n\n**Type-Specific Optional:**\n```yaml\nwidth: Integer (pixels)\nheight: Integer (pixels)\ntaken_at: DateTime (when photo was taken, not uploaded)\ngps_latitude: Float (-90 to 90)\ngps_longitude: Float (-180 to 180)\nprocessing_status: Enum ['pending', 'processing', 'ready', 'error']\nthumbnail_path: String (location of thumbnail)\n```\n\n### 4. Metadata Schema\n\nDefine expected metadata structure:\n```json\n{\n  \"exif\": {\n    \"camera_make\": \"Apple\",\n    \"camera_model\": \"iPhone 14 Pro\",\n    \"f_number\": 1.8,\n    \"exposure_time\": 0.00833,\n    \"iso\": 100\n  },\n  \"tags\": [\"vacation\", \"beach\", \"sunset\"],\n  \"ai_labels\": [\"beach\", \"ocean\", \"sky\"],\n  \"faces\": [\n    {\"person_id\": \"uuid\", \"bbox\": [x, y, w, h]}\n  ]\n}\n```\n\n### 5. Relationships\n\nDefine valid link types:\n```yaml\nOutgoing Links:\n  - can_be_contained_in: [Album]\n  - can_have_source: [Integration]\n  - can_be_duplicate_of: [Photo]\n  - can_be_variant_of: [Photo]\n  - can_be_related_to: [Photo, Video, Location, Event]\n\nIncoming Links:\n  - can_contain: [] (photos don't contain things)\n  - can_be_referenced_by: [Post, Message, Document]\n```\n\n### 6. Validation Rules\n\n```python\n# File size\nmax_size: 100MB (configurable)\n\n# Mime types\nallowed_mimes: ['image/jpeg', 'image/png', 'image/heic', 'image/webp']\n\n# Dimensions\nmax_width: 50000 pixels\nmax_height: 50000 pixels\n\n# GPS\nlatitude: -90 <= value <= 90\nlongitude: -180 <= value <= 180\n\n# Required fields\nfilename: not empty\nfile_path: must exist\nhash: must be 64-char hex (SHA-256)\n```\n\n### 7. API Endpoints\n\nList APIs that use this type:\n```yaml\nCreate:\n  - POST /api/v1/media/upload\n  - POST /api/v1/integrations/{id}/sync (imports from Instagram, etc.)\n\nRead:\n  - GET /api/v1/media/{id}\n  - GET /api/v1/media (list)\n  - GET /api/v1/albums/{id}/media (photos in album)\n\nUpdate:\n  - PATCH /api/v1/media/{id} (update metadata, tags)\n\nDelete:\n  - DELETE /api/v1/media/{id} (soft delete)\n```\n\n### 8. Examples\n\nProvide real-world instances:\n```json\n{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"user_id\": \"user-123\",\n  \"filename\": \"IMG_2024.jpg\",\n  \"media_type\": \"photo\",\n  \"mime_type\": \"image/jpeg\",\n  \"file_size\": 2048576,\n  \"file_path\": \"/media/user-123/2024/01/IMG_2024.jpg\",\n  \"hash\": \"a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3\",\n  \"width\": 4032,\n  \"height\": 3024,\n  \"taken_at\": \"2024-01-15T14:30:00Z\",\n  \"gps_latitude\": 37.7749,\n  \"gps_longitude\": -122.4194,\n  \"processing_status\": \"ready\",\n  \"thumbnail_path\": \"/media/user-123/2024/01/IMG_2024_thumb.jpg\",\n  \"created_at\": \"2024-01-15T15:00:00Z\",\n  \"updated_at\": \"2024-01-15T15:00:00Z\",\n  \"deleted_at\": null,\n  \"source_type\": \"upload\",\n  \"source_id\": null,\n  \"metadata\": {\n    \"exif\": {\n      \"camera_make\": \"Apple\",\n      \"camera_model\": \"iPhone 14 Pro\"\n    },\n    \"tags\": [\"san francisco\", \"golden gate bridge\"],\n    \"ai_labels\": [\"bridge\", \"landmark\", \"outdoor\"]\n  }\n}\n```\n\n### 9. Migration Path (if replacing existing type)\n\nIf this type replaces or modifies an existing type:\n```yaml\nFrom: Photo v1.0\nTo: Photo v2.0\n\nChanges:\n  - Added: processing_status field\n  - Removed: None\n  - Modified: hash field now required (was optional)\n\nMigration:\n  - All existing Photo v1.0 instances remain valid\n  - New instances must include processing_status\n  - System calculates hash for old instances without it\n\nBackward Compatible: Yes (v2.0 can read v1.0 data)\n```\n\n---\n\n## The Proposal Process\n\n### Step 1: Draft Proposal\n\nCreate a document using the template above. Include:\n- Complete identity section\n- Clear purpose statement\n- All required and optional fields\n- Validation rules\n- Examples\n\n**Where to submit:**\n- Create file in appropriate 0.0.X category\n- Or submit as pull request (if using git)\n- Or propose in community forum\n\n### Step 2: Community Review\n\n**Reviewers check:**\n- Is this distinct enough to warrant a new type?\n- Could existing types + metadata serve this need?\n- Are the fields well-defined?\n- Are validation rules appropriate?\n- Are relationships logical?\n\n**Timeline:** 7-14 days for review\n\n### Step 3: Refinement\n\nBased on feedback:\n- Adjust fields\n- Clarify purpose\n- Add missing validation\n- Improve examples\n\n**Iterate until consensus is reached.**\n\n### Step 4: Approval\n\n**Who approves:**\n- Matt Schaeffer (CEO/Owner) - for strategic decisions\n- AI Council (future) - for technical decisions\n- Community vote (future) - for non-critical types\n\n**Current Phase:** Matt approves all new types\n\n**Criteria for approval:**\n- Serves real need\n- Well-defined and complete\n- Doesn't conflict with existing types\n- Implementation is feasible\n\n### Step 5: Implementation\n\nOnce approved:\n\n1. **Add to 0.0 Registry**\n   - Create official definition document\n   - Update category README\n   - Add to master index\n\n2. **Implement in 0.1**\n   - Create SQLAlchemy model\n   - Add to database schema\n   - Write storage/retrieval logic\n\n3. **Expose in 0.2**\n   - Create API endpoints\n   - Write API documentation\n   - Add validation\n\n4. **Document**\n   - Update user guides\n   - Add examples\n   - Create tutorials if needed\n\n5. **Test**\n   - Unit tests for model\n   - Integration tests for API\n   - End-to-end tests\n\n**Timeline:** 1-4 weeks depending on complexity\n\n---\n\n## Type Hierarchies and Inheritance\n\n### Base Types\n\nAll objects inherit from `BaseObject`:\n```yaml\nBaseObject:\n  - id: UUID\n  - user_id: UUID\n  - created_at: DateTime\n  - updated_at: DateTime\n  - deleted_at: DateTime\n  - source_type: String\n  - source_id: String\n  - metadata: JSONB\n```\n\n### Intermediate Types\n\nSome types serve as parents:\n```yaml\nMedia (extends BaseObject):\n  - filename: String\n  - media_type: Enum\n  - mime_type: String\n  - file_size: Integer\n  - file_path: String\n  - hash: String\n\nPhoto (extends Media):\n  - media_type: 'photo' (fixed)\n  - width: Integer\n  - height: Integer\n  - taken_at: DateTime\n  - gps_latitude: Float\n  - gps_longitude: Float\n\nVideo (extends Media):\n  - media_type: 'video' (fixed)\n  - width: Integer\n  - height: Integer\n  - duration: Float\n  - codec: String\n```\n\n### Subtypes\n\nPlatform-specific specializations:\n```yaml\nInstagramPhoto (extends Photo):\n  - Inherits all Photo fields\n  - Adds instagram-specific metadata:\n    - instagram_id: String\n    - instagram_url: String\n    - likes_count: Integer\n    - comments_count: Integer\n```\n\n**Rule:** Subtypes can add fields but cannot remove or modify parent fields.\n\n---\n\n## Versioning Policy\n\n### Semantic Versioning\n\nTypes follow semantic versioning: **MAJOR.MINOR.PATCH**\n\n**MAJOR (e.g., 1.0 \u2192 2.0):**\n- Breaking changes\n- Removed fields\n- Changed field types\n- Requires data migration\n\n**MINOR (e.g., 1.0 \u2192 1.1):**\n- Added optional fields\n- New relationships\n- Backward compatible\n- No migration needed\n\n**PATCH (e.g., 1.0.0 \u2192 1.0.1):**\n- Documentation fixes\n- Clarifications\n- No schema changes\n\n### Backward Compatibility\n\n**Goal:** Maintain compatibility whenever possible\n\n**Rules:**\n1. New optional fields are OK (MINOR bump)\n2. New metadata keys are OK (no version bump)\n3. New link types are OK (MINOR bump)\n4. Removing fields requires MAJOR bump + migration\n5. Changing field types requires MAJOR bump + migration\n\n**Storage:**\nEvery object instance stores its schema version:\n```json\n{\n  \"id\": \"...\",\n  \"_schema_version\": \"1.1\",\n  ...\n}\n```\n\nSystem can handle multiple versions simultaneously during migration periods.\n\n---\n\n## Deprecation Process\n\n### When to Deprecate\n\nDeprecate a type when:\n- Better type available\n- No longer serves purpose\n- Security concerns\n- Replaced by improved version\n\n### Steps\n\n1. **Announce Deprecation**\n   - Mark type as deprecated in documentation\n   - Specify replacement type\n   - Set sunset date (minimum 6 months)\n\n2. **Migration Period**\n   - Provide migration tools\n   - Offer support for users\n   - Both old and new types coexist\n\n3. **Sunset**\n   - Stop accepting new instances of deprecated type\n   - Keep reading existing instances\n   - Provide read-only access indefinitely\n\n4. **Archive**\n   - Move definition to archive section\n   - Maintain for historical reference\n   - Keep implementation for existing data\n\n**Rule:** Never truly delete types - they become read-only archives.\n\n---\n\n## Quality Standards\n\n### Documentation Requirements\n\nEvery type definition must have:\n- [ ] Clear purpose statement\n- [ ] Complete field definitions\n- [ ] Validation rules\n- [ ] At least 3 realistic examples\n- [ ] API endpoint list\n- [ ] Relationship definitions\n\n### Code Requirements\n\nEvery type implementation must have:\n- [ ] SQLAlchemy model matching schema\n- [ ] Database migration script\n- [ ] API endpoints (CRUD minimum)\n- [ ] Unit tests (>80% coverage)\n- [ ] Integration tests\n- [ ] API documentation\n\n### Review Requirements\n\nBefore approval:\n- [ ] Reviewed by at least 2 people\n- [ ] No major objections\n- [ ] All feedback addressed\n- [ ] Complete documentation\n- [ ] Implementation plan exists\n\n---\n\n## Special Cases\n\n### AI-Proposed Types\n\nAI can propose types. Additional requirements:\n- Explain reasoning clearly\n- Provide use case examples\n- Show how it benefits users\n- Defer to humans for final approval\n\n**AI contributions are valued and encouraged.**\n\n### Emergency Types\n\nFor urgent needs:\n- Fast-track review (24-48 hours)\n- Implement first, formalize later\n- Document retroactively\n- Only for critical issues\n\n### Experimental Types\n\nFor testing new concepts:\n- Mark as `[EXPERIMENTAL]`\n- May change without notice\n- Don't use in production\n- Can be removed if not successful\n\n---\n\n## Current Status\n\n**Phase:** Bootstrap\n**Types Defined:** 0 (starting fresh)\n**Next:** Define first 25 types for Phase 1\n**Timeline:** 1-2 weeks\n\n---\n\n## Questions?\n\nContact:\n- **Strategic:** Matt Schaeffer (CEO/Owner)\n- **Technical:** AI Council (future) or Claude (current)\n- **Community:** Forums (future)\n\n---\n\n**This document is canonical. All types must follow this process.**\n\n**Version:** 1.0\n**Status:** Active\n**Authority:** 0.0.0 - Registry Governance\n"
  },
  "created_at": "2026-02-15T11:54:04.534085+00:00",
  "updated_at": "2026-02-15T11:54:04.534085+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:00-How-To-Add-New-Types.md"
}