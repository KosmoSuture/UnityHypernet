{
  "address": "0.4.0.0.1.7",
  "type_address": null,
  "data": {
    "name": "Link.md",
    "type": "file",
    "extension": ".md",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.4 - Object Type Registry\\0.0.1 - Core Types\\Link.md",
    "size": 5254,
    "content": "# Link - Relationship Between Objects\n\n**Type ID:** `hypernet.core.link`\n**Version:** 1.0\n**Category:** 0.0.1 - Core Types\n**Parent:** BaseObject\n**Status:** Active\n**Created:** 2026-02-04\n\n---\n\n## Identity\n\n```yaml\ntype_name: \"Link\"\ntype_id: \"hypernet.core.link\"\nversion: \"1.0\"\nparent_type: \"BaseObject\"\ncategory: \"0.0.1 - Core Types\"\n```\n\n---\n\n## Purpose\n\n### What\nFirst-class relationships between any two objects in Hypernet.\n\n### Why\n- NOT just foreign keys - links are objects themselves\n- Enable graph queries and traversal\n- Support many-to-many relationships\n- Capture relationship metadata (strength, confidence)\n- Foundation for knowledge graph\n\n### When to Use\n- Connect objects: Album contains Photos\n- Track provenance: Photo sourced from Instagram\n- Deduplicate: Photo is duplicate_of another Photo\n- Relate: Event related_to Location\n\n---\n\n## Inherited Fields\n```yaml\nid, user_id, created_at, updated_at, deleted_at, source_type, source_id, metadata\n```\n\n---\n\n## Required Fields\n\n```yaml\nfrom_object_id: UUID\n  - Source of relationship\n  - Can be any object type\n\nfrom_object_type: String(50)\n  - Type name: \"Photo\", \"Album\", \"User\", etc.\n\nto_object_id: UUID\n  - Target of relationship\n  - Can be any object type\n\nto_object_type: String(50)\n  - Type name\n\nlink_type: Enum(50)\n  - \"contains\" (Album contains Photos)\n  - \"source\" (Photo sourced from Integration)\n  - \"duplicate_of\" (exact duplicate)\n  - \"variant_of\" (different version)\n  - \"related_to\" (general relationship)\n```\n\n---\n\n## Optional Fields\n\n```yaml\nstrength: Float (0.0 to 1.0)\n  - Confidence or weight of relationship\n  - Default: 1.0\n  - Example: 0.85 for \"probably related\"\n\nis_bidirectional: Boolean\n  - Default: false\n  - If true, relationship works both ways\n  - Example: \"related_to\" is bidirectional\n\nsort_order: Integer\n  - For ordered relationships (photos in album)\n  - Nullable for unordered links\n```\n\n---\n\n## Metadata Schema\n\n```json\n{\n  \"relationship_details\": {\n    \"added_by\": \"user|ai|system\",\n    \"confidence\": 0.89,\n    \"reasoning\": \"Same location and timestamp\"\n  },\n  \"contains\": {\n    \"position\": 5,\n    \"featured\": true\n  },\n  \"source\": {\n    \"sync_timestamp\": \"2024-01-15T10:00:00Z\",\n    \"original_id\": \"instagram:12345\"\n  }\n}\n```\n\n---\n\n## Relationships\n\nLinks themselves can have metadata but typically don't link to other objects.\n\n---\n\n## Validation\n\n```sql\nCHECK (link_type IN ('contains', 'source', 'duplicate_of', 'variant_of', 'related_to'))\nCHECK (strength >= 0.0 AND strength <= 1.0)\nCHECK (from_object_id != to_object_id OR from_object_type != to_object_type) -- No self-links\n\n-- No duplicate links\nUNIQUE (from_object_id, to_object_id, link_type) WHERE deleted_at IS NULL\n\n-- Indexes for traversal\nINDEX ON (from_object_id, link_type) WHERE deleted_at IS NULL\nINDEX ON (to_object_id, link_type) WHERE deleted_at IS NULL\nINDEX ON (from_object_id, sort_order) WHERE deleted_at IS NULL AND sort_order IS NOT NULL\n```\n\n---\n\n## API Endpoints\n\n```http\nPOST /api/v1/links (create relationship)\nGET /api/v1/links?from_id={id}&link_type=contains (outgoing links)\nGET /api/v1/links?to_id={id}&link_type=source (incoming links)\nDELETE /api/v1/links/{id} (remove relationship)\n\n# Convenience endpoints\nPOST /api/v1/albums/{id}/add-media (creates contains link)\nGET /api/v1/albums/{id}/media (traverses contains links)\n```\n\n---\n\n## Graph Queries\n\n```python\n# Find all photos in album\nphotos = session.query(Photo).join(Link,\n    Link.to_object_id == Photo.id\n).filter(\n    Link.from_object_id == album_id,\n    Link.link_type == 'contains',\n    Link.deleted_at == None\n).order_by(Link.sort_order).all()\n\n# Find source integration for photo\nintegration = session.query(Integration).join(Link,\n    Link.to_object_id == Integration.id\n).filter(\n    Link.from_object_id == photo_id,\n    Link.link_type == 'source',\n    Link.deleted_at == None\n).first()\n\n# Find related photos (bidirectional)\nrelated = session.query(Photo).join(Link,\n    or_(\n        Link.to_object_id == Photo.id,\n        Link.from_object_id == Photo.id\n    )\n).filter(\n    Link.link_type == 'related_to',\n    or_(\n        Link.from_object_id == photo_id,\n        Link.to_object_id == photo_id\n    )\n).all()\n```\n\n---\n\n## Link Types Reference\n\n```yaml\ncontains:\n  - Parent contains child\n  - Examples: Album \u2192 Photo, Playlist \u2192 Audio\n  - Usually ordered (sort_order)\n  - One-directional\n\nsource:\n  - Object came from external source\n  - Examples: Photo \u2192 Integration, Email \u2192 EmailAccount\n  - One-directional\n  - Tracks provenance\n\nduplicate_of:\n  - Exact duplicate content\n  - Example: Photo \u2192 Photo (same hash)\n  - One-directional (points to original)\n  - Used for deduplication\n\nvariant_of:\n  - Different version of same content\n  - Examples: Photo (edited) \u2192 Photo (original)\n  - One-directional\n  - Preserves edit history\n\nrelated_to:\n  - General relationship\n  - Examples: Photo \u2194 Photo (same event), Photo \u2194 Location\n  - Can be bidirectional\n  - Flexible metadata\n```\n\n---\n\n**Status:** Active - Critical Core Type\n**Version:** 1.0\n"
  },
  "created_at": "2026-02-17T01:23:29.003215+00:00",
  "updated_at": "2026-02-17T01:23:29.003215+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:Link.md"
}