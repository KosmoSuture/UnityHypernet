{
  "address": "0.4.0.0.1.3",
  "type_address": null,
  "data": {
    "name": "0.0.1.3-LINK.md",
    "type": "file",
    "extension": ".md",
    "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.4 - Object Type Registry\\0.0.1 - Core Types\\0.0.1.3-LINK.md",
    "size": 32870,
    "content": "# LINK - Relationship Between Objects Type\n\n**Type ID:** `hypernet.core.link`\n**Version:** 1.0\n**Category:** 0.0.1 - Core Types\n**Parent:** BaseObject\n**Status:** Active - Critical Core Type\n**Created:** 2026-02-09\n**Last Updated:** 2026-02-09\n\n---\n\n## Object Type Metadata\n\n```yaml\ntype_name: \"Link\"\ntype_id: \"hypernet.core.link\"\nversion: \"1.0\"\nparent_type: \"BaseObject\"\ncategory: \"0.0.1 - Core Types\"\nabstract: false\ninstantiable: true\n```\n\n---\n\n## Purpose and Description\n\n### What is a Link?\n\nA Link is a first-class object that represents a typed relationship between any two objects in Hypernet. Unlike traditional foreign keys or join tables, Links are full-fledged objects with their own identity, metadata, and lifecycle. This design enables Hypernet to function as a knowledge graph where relationships are as important as the objects themselves.\n\n### Revolutionary Design Philosophy\n\nIn most systems, relationships are implicit (foreign keys) or hidden (join tables). Hypernet makes relationships explicit and first-class:\n- Links ARE objects, not just references\n- Links have IDs, timestamps, and metadata\n- Links can be queried, filtered, and analyzed\n- Links enable graph traversal and knowledge discovery\n- Links support AI reasoning about relationships\n\n### Core Functions\n\n1. **Object Relationships** - Connect any object to any other object with semantic meaning\n2. **Graph Structure** - Enable graph queries and traversal across all data\n3. **Provenance Tracking** - Record where data came from (Photo from Instagram)\n4. **Collection Management** - Organize objects into albums, playlists, folders\n5. **Deduplication** - Mark duplicates and variants without deletion\n6. **Knowledge Graph** - Foundation for AI understanding of user's data universe\n\n### When to Use\n\n- Album contains Photos: `Album --contains--> Photo`\n- Photo sourced from Instagram: `Photo --source--> Integration`\n- Two Photos are duplicates: `Photo --duplicate_of--> Photo`\n- Photo edited from original: `Photo --variant_of--> Photo`\n- Event happened at Location: `Event --located_at--> Location`\n- Email mentions Person: `Email --mentions--> Contact`\n- Any typed relationship between objects\n\n---\n\n## Inherited Fields from BaseObject\n\n```yaml\nid: UUID\n  - Unique link identifier\n  - Links are queryable objects\n\nuser_id: UUID\n  - Owner of this relationship\n  - Typically same as from_object owner\n  - Enables per-user relationship graphs\n\ncreated_at: DateTime\n  - When relationship was established\n  - Important for temporal graph analysis\n\nupdated_at: DateTime\n  - Last modification to relationship\n  - Updated when metadata changes\n\ndeleted_at: DateTime (nullable)\n  - Soft delete for relationships\n  - Preserves historical graph structure\n\nsource_type: String\n  - How relationship was created\n  - \"user\" (manually created)\n  - \"ai\" (AI detected)\n  - \"system\" (auto-generated)\n  - \"integration\" (from external service)\n\nsource_id: String\n  - Optional source identifier\n\nmetadata: JSONB\n  - Relationship-specific data\n  - Confidence scores, reasoning, attributes\n```\n\n---\n\n## Required Fields\n\n### Relationship Endpoints\n\n```yaml\nfrom_object_id: UUID\n  type: UUID\n  nullable: false\n  indexed: true\n  description: \"Source object ID in this relationship\"\n  constraints:\n    - Must be valid UUID\n    - Object should exist (soft constraint for flexibility)\n  purpose: \"Start point of directed relationship\"\n  examples:\n    - Album ID (in album --contains--> photo)\n    - Photo ID (in photo --source--> integration)\n    - Photo ID (in photo --duplicate_of--> photo)\n\nfrom_object_type: String(50)\n  type: String\n  max_length: 50\n  nullable: false\n  indexed: true\n  description: \"Type of source object\"\n  allowed_values:\n    - Any valid object type name: \"Photo\", \"Video\", \"Album\", \"User\", etc.\n  purpose: \"Enable type-specific queries and validation\"\n  validation:\n    - Must match actual object type\n    - Case-sensitive\n  examples:\n    - \"Album\"\n    - \"Photo\"\n    - \"User\"\n    - \"Event\"\n\nto_object_id: UUID\n  type: UUID\n  nullable: false\n  indexed: true\n  description: \"Target object ID in this relationship\"\n  constraints:\n    - Must be valid UUID\n    - Object should exist (soft constraint)\n  purpose: \"End point of directed relationship\"\n  examples:\n    - Photo ID (in album --contains--> photo)\n    - Integration ID (in photo --source--> integration)\n    - Original Photo ID (in edited --duplicate_of--> original)\n\nto_object_type: String(50)\n  type: String\n  max_length: 50\n  nullable: false\n  indexed: true\n  description: \"Type of target object\"\n  allowed_values:\n    - Any valid object type name\n  purpose: \"Enable type-specific queries and validation\"\n```\n\n### Relationship Type\n\n```yaml\nlink_type: String(50)\n  type: String\n  max_length: 50\n  nullable: false\n  indexed: true\n  description: \"Semantic type of relationship\"\n  allowed_values:\n    # Collection/Containment\n    - \"contains\": Parent contains child (Album \u2192 Photo)\n    - \"belongs_to\": Child belongs to parent (Photo \u2192 Album, inverse of contains)\n\n    # Provenance/Source\n    - \"source\": Object sourced from external service (Photo \u2192 Integration)\n    - \"imported_from\": Alternative to source\n    - \"exported_to\": Object exported to external service\n\n    # Duplication\n    - \"duplicate_of\": Exact duplicate (Photo \u2192 Photo)\n    - \"variant_of\": Different version (Edited \u2192 Original)\n    - \"derived_from\": Derived work (Thumbnail \u2192 Photo)\n\n    # Relationships\n    - \"related_to\": General relationship (Photo \u2194 Photo)\n    - \"similar_to\": Similarity relationship (Photo \u2194 Photo)\n    - \"references\": One object references another (Note \u2192 Photo)\n\n    # Location\n    - \"located_at\": Object at location (Event \u2192 Location)\n    - \"taken_at\": Photo taken at location (Photo \u2192 Location)\n\n    # People\n    - \"depicts\": Media depicts person (Photo \u2192 Contact)\n    - \"created_by\": Created by user/AI (Object \u2192 User)\n    - \"mentions\": Object mentions entity (Email \u2192 Contact)\n\n    # Temporal\n    - \"before\": Temporal ordering (Event \u2192 Event)\n    - \"after\": Temporal ordering (Event \u2192 Event)\n    - \"during\": Temporal containment (Event \u2192 Event)\n\n    # AI/Knowledge\n    - \"similar_embedding\": AI-detected similarity\n    - \"topic\": Object relates to topic (Note \u2192 Topic)\n    - \"tagged_with\": Object tagged with label (Photo \u2192 Tag)\n  validation:\n    - Must be lowercase with underscores\n    - Should be semantically clear\n  extensibility:\n    - New link types can be added\n    - Follow naming convention: verb or verb_preposition\n```\n\n---\n\n## Optional Fields\n\n### Relationship Attributes\n\n```yaml\nstrength: Float\n  type: Float\n  nullable: true\n  default: 1.0\n  range: 0.0 to 1.0\n  description: \"Confidence or weight of relationship\"\n  purpose: \"Express uncertainty or importance\"\n  examples:\n    - 1.0: Certain relationship (user-created)\n    - 0.95: High confidence AI detection\n    - 0.7: Moderate confidence similarity\n    - 0.3: Weak possible relationship\n  usage:\n    - AI-detected relationships have < 1.0 strength\n    - Filter low-confidence links\n    - Weight graph algorithms\n\nis_bidirectional: Boolean\n  type: Boolean\n  nullable: false\n  default: false\n  description: \"Whether relationship is symmetric\"\n  examples:\n    - false: \"contains\", \"source\", \"duplicate_of\" (directed)\n    - true: \"related_to\", \"similar_to\" (undirected)\n  purpose: \"Simplify bidirectional relationship queries\"\n  implementation:\n    - If true, query both directions without inverse link\n    - If false, need separate inverse link for reverse traversal\n\nsort_order: Integer\n  type: Integer\n  nullable: true\n  description: \"Position in ordered relationships\"\n  purpose: \"Maintain order in collections\"\n  examples:\n    - Photos in album: 1, 2, 3, ...\n    - Playlist tracks: 1, 2, 3, ...\n    - Timeline events: by timestamp\n  constraints:\n    - Null for unordered relationships\n    - Unique within (from_object_id, link_type) group\n  usage:\n    - ORDER BY sort_order in queries\n    - Drag-and-drop reordering updates sort_order\n```\n\n### Relationship Metadata\n\n```yaml\nconfidence_score: Float (in metadata)\n  description: \"AI confidence in relationship\"\n  range: 0.0 to 1.0\n  applicable: AI-detected relationships\n\nreasoning: String (in metadata)\n  description: \"Why relationship was created\"\n  examples:\n    - \"Same location and timestamp\"\n    - \"Visual similarity detected\"\n    - \"User manually added\"\n\nattributes: Object (in metadata)\n  description: \"Type-specific attributes\"\n  examples:\n    - contains: {\"position\": 5, \"featured\": true}\n    - depicts: {\"face_box\": [x, y, w, h], \"name\": \"John\"}\n    - similar_to: {\"similarity_score\": 0.87, \"method\": \"embedding\"}\n```\n\n---\n\n## Metadata Schema\n\nThe `metadata` JSONB field stores relationship-specific data:\n\n```json\n{\n  \"relationship_details\": {\n    \"added_by\": \"user|ai|system\",\n    \"added_at\": \"2026-02-09T10:00:00Z\",\n    \"confidence\": 0.89,\n    \"reasoning\": \"Same location and timestamp\",\n    \"method\": \"rule_based|ml_model|user_action\"\n  },\n  \"contains\": {\n    \"position\": 5,\n    \"featured\": true,\n    \"caption\": \"Sunset at the beach\",\n    \"added_to_album_at\": \"2026-02-09T10:00:00Z\"\n  },\n  \"source\": {\n    \"sync_timestamp\": \"2026-02-09T09:00:00Z\",\n    \"original_id\": \"instagram:12345\",\n    \"original_url\": \"https://instagram.com/p/xyz\",\n    \"sync_batch_id\": \"batch-uuid\"\n  },\n  \"duplicate_of\": {\n    \"detection_method\": \"perceptual_hash\",\n    \"hash_similarity\": 1.0,\n    \"file_size_diff\": 0,\n    \"confirmed_by_user\": false\n  },\n  \"similar_to\": {\n    \"similarity_score\": 0.87,\n    \"similarity_method\": \"clip_embedding\",\n    \"embedding_distance\": 0.13,\n    \"model_version\": \"openai-clip-vit-l-14\"\n  },\n  \"depicts\": {\n    \"face_bounding_box\": {\n      \"x\": 100,\n      \"y\": 150,\n      \"width\": 80,\n      \"height\": 100\n    },\n    \"face_confidence\": 0.98,\n    \"recognized_as\": \"contact-uuid\",\n    \"recognition_confidence\": 0.92\n  },\n  \"located_at\": {\n    \"precision\": \"exact|approximate|city|country\",\n    \"source\": \"gps|exif|user_added|ai_detected\",\n    \"confidence\": 0.95\n  },\n  \"tags\": {\n    \"tag_name\": \"vacation\",\n    \"auto_generated\": true,\n    \"tag_source\": \"ai_vision\"\n  }\n}\n```\n\n---\n\n## Relationships to Other Object Types\n\nLinks connect to two arbitrary objects, making them highly flexible:\n\n### From Object (Source)\n\n```yaml\nfrom: Any Object Type\n  description: \"Source object in this relationship\"\n  cardinality: \"N:1 (many links from one object)\"\n  implementation: \"from_object_id + from_object_type\"\n  queries:\n    - Get all links FROM a Photo\n    - Get all contains links FROM an Album\n```\n\n### To Object (Target)\n\n```yaml\nto: Any Object Type\n  description: \"Target object in this relationship\"\n  cardinality: \"N:1 (many links to one object)\"\n  implementation: \"to_object_id + to_object_type\"\n  queries:\n    - Get all links TO a Photo\n    - Get all source links TO an Integration\n```\n\n### Owner\n\n```yaml\nowned_by: User\n  description: \"User who owns this relationship\"\n  cardinality: \"N:1 (many links, one user)\"\n  implementation: \"user_id foreign key\"\n  constraints:\n    - Typically same as from_object owner\n    - Can differ for shared relationships\n```\n\n---\n\n## API Endpoints\n\n### Link Management\n\n```http\nPOST /api/v1/links\n  Description: Create new relationship between objects\n  Request Body:\n    {\n      \"from_object_id\": \"album-uuid\",\n      \"from_object_type\": \"Album\",\n      \"to_object_id\": \"photo-uuid\",\n      \"to_object_type\": \"Photo\",\n      \"link_type\": \"contains\",\n      \"sort_order\": 10,\n      \"strength\": 1.0,\n      \"metadata\": {\n        \"featured\": true\n      }\n    }\n  Response: 201 Created\n    {link object with all fields}\n  Validation:\n    - Objects must exist (or skip_validation=true)\n    - User must own from_object\n    - No duplicate link (same from, to, type)\n  Security:\n    - User must own from_object\n    - User must have read access to to_object\n\nGET /api/v1/links/{id}\n  Description: Get single link details\n  Path Parameters:\n    id: UUID (required) - link ID\n  Response: 200 OK\n    {link object}\n  Security:\n    - User must own link or have access to linked objects\n\nPATCH /api/v1/links/{id}\n  Description: Update link attributes\n  Request Body:\n    {\n      \"sort_order\": 15,\n      \"strength\": 0.9,\n      \"metadata\": {additional metadata}\n    }\n  Response: 200 OK\n    {updated link object}\n  Validation:\n    - Cannot change: from/to objects, link_type\n    - Can change: sort_order, strength, metadata\n\nDELETE /api/v1/links/{id}\n  Description: Delete relationship (soft delete)\n  Response: 204 No Content\n  Security:\n    - User must own link\n```\n\n### Link Queries\n\n```http\nGET /api/v1/links\n  Description: Query links with flexible filtering\n  Query Parameters:\n    from_id: UUID - filter by source object\n    from_type: string - filter by source type\n    to_id: UUID - filter by target object\n    to_type: string - filter by target type\n    link_type: string - filter by relationship type\n    is_bidirectional: boolean\n    min_strength: float (0.0-1.0)\n    include_deleted: boolean\n    limit: integer (default 50, max 500)\n    offset: integer (default 0)\n  Response: 200 OK\n    {\n      \"items\": [{link}, {link}, ...],\n      \"total\": 150,\n      \"limit\": 50,\n      \"offset\": 0\n    }\n  Examples:\n    - GET /api/v1/links?from_id={album_id}&link_type=contains\n      \u2192 Get all photos in album\n    - GET /api/v1/links?to_id={integration_id}&link_type=source\n      \u2192 Get all media from integration\n    - GET /api/v1/links?from_id={photo_id}&link_type=similar_to&min_strength=0.8\n      \u2192 Get similar photos with high confidence\n\nGET /api/v1/objects/{id}/links/outgoing\n  Description: Get all links FROM this object\n  Path Parameters:\n    id: UUID - source object ID\n  Query Parameters:\n    link_type: string - filter by type\n    to_type: string - filter by target type\n  Response: 200 OK\n    {\n      \"items\": [{link with target object}, ...],\n      \"total\": 25\n    }\n\nGET /api/v1/objects/{id}/links/incoming\n  Description: Get all links TO this object\n  Path Parameters:\n    id: UUID - target object ID\n  Query Parameters:\n    link_type: string - filter by type\n    from_type: string - filter by source type\n  Response: 200 OK\n    {\n      \"items\": [{link with source object}, ...],\n      \"total\": 10\n    }\n```\n\n### Convenience Endpoints\n\n```http\nPOST /api/v1/albums/{id}/add-media\n  Description: Add media to album (creates contains link)\n  Path Parameters:\n    id: UUID - album ID\n  Request Body:\n    {\n      \"media_ids\": [\"photo-uuid-1\", \"photo-uuid-2\"],\n      \"sort_order_start\": 10\n    }\n  Response: 201 Created\n    {\n      \"links_created\": 2,\n      \"links\": [{link}, {link}]\n    }\n  Implementation:\n    - Creates contains link for each media item\n    - Auto-assigns sort_order if not specified\n\nGET /api/v1/albums/{id}/media\n  Description: Get all media in album (traverses contains links)\n  Path Parameters:\n    id: UUID - album ID\n  Query Parameters:\n    sort_by: \"sort_order|created_at|updated_at\"\n    order: \"asc|desc\"\n  Response: 200 OK\n    {\n      \"items\": [\n        {\n          \"photo\": {photo object},\n          \"link\": {link object},\n          \"position\": 1\n        }\n      ]\n    }\n  Implementation:\n    - Query links WHERE from_id=album_id AND link_type='contains'\n    - Join with Photo/Video objects\n    - Order by sort_order\n\nDELETE /api/v1/albums/{id}/media/{media_id}\n  Description: Remove media from album (deletes contains link)\n  Response: 204 No Content\n```\n\n### Graph Traversal\n\n```http\nGET /api/v1/graph/traverse\n  Description: Multi-hop graph traversal\n  Query Parameters:\n    start_id: UUID (required) - starting object\n    link_types: string[] - relationship types to follow\n    max_depth: integer (default 2, max 5)\n    direction: \"outgoing|incoming|both\"\n  Response: 200 OK\n    {\n      \"nodes\": [{object}, {object}, ...],\n      \"edges\": [{link}, {link}, ...],\n      \"paths\": [\n        {\n          \"start\": \"obj-1\",\n          \"end\": \"obj-10\",\n          \"path\": [\"obj-1\", \"obj-5\", \"obj-10\"],\n          \"depth\": 2\n        }\n      ]\n    }\n  Examples:\n    - Find all photos related to a location (direct + indirect)\n    - Find connection path between two objects\n    - Discover clusters of related content\n```\n\n---\n\n## Database Schema (SQLAlchemy Model Reference)\n\n```python\nfrom sqlalchemy import (\n    Column, String, Boolean, Integer, Float,\n    DateTime, ForeignKey, Index, CheckConstraint, UniqueConstraint\n)\nfrom sqlalchemy.dialects.postgresql import UUID, JSONB\nfrom sqlalchemy.orm import relationship\nfrom app.models.base import BaseObject\n\nclass Link(BaseObject):\n    \"\"\"\n    First-class relationship between any two objects\n\n    Inherits from BaseObject: id, user_id, created_at, updated_at,\n    deleted_at, source_type, source_id, metadata\n    \"\"\"\n\n    __tablename__ = \"links\"\n\n    # Relationship Endpoints\n    from_object_id = Column(\n        UUID(as_uuid=True),\n        nullable=False,\n        index=True,\n        doc=\"Source object ID in relationship\"\n    )\n    from_object_type = Column(\n        String(50),\n        nullable=False,\n        index=True,\n        doc=\"Type of source object\"\n    )\n\n    to_object_id = Column(\n        UUID(as_uuid=True),\n        nullable=False,\n        index=True,\n        doc=\"Target object ID in relationship\"\n    )\n    to_object_type = Column(\n        String(50),\n        nullable=False,\n        index=True,\n        doc=\"Type of target object\"\n    )\n\n    # Relationship Type\n    link_type = Column(\n        String(50),\n        nullable=False,\n        index=True,\n        doc=\"Semantic type of relationship\"\n    )\n\n    # Relationship Attributes\n    strength = Column(\n        Float,\n        nullable=True,\n        default=1.0,\n        doc=\"Confidence or weight (0.0-1.0)\"\n    )\n    is_bidirectional = Column(\n        Boolean,\n        nullable=False,\n        default=False,\n        doc=\"Whether relationship is symmetric\"\n    )\n    sort_order = Column(\n        Integer,\n        nullable=True,\n        doc=\"Position in ordered relationships\"\n    )\n\n    # Table Constraints\n    __table_args__ = (\n        # No self-links (same object, same type)\n        CheckConstraint(\n            \"(from_object_id != to_object_id) OR (from_object_type != to_object_type)\",\n            name=\"check_no_self_links\"\n        ),\n        # Strength must be 0.0 to 1.0\n        CheckConstraint(\n            \"strength IS NULL OR (strength >= 0.0 AND strength <= 1.0)\",\n            name=\"check_strength_range\"\n        ),\n        # No duplicate links (same from, to, type)\n        UniqueConstraint(\n            'from_object_id', 'to_object_id', 'link_type',\n            name='uq_link_from_to_type',\n            postgresql_where=\"deleted_at IS NULL\"\n        ),\n        # Composite indexes for common queries\n        Index('idx_link_from', 'from_object_id', 'link_type', 'deleted_at'),\n        Index('idx_link_to', 'to_object_id', 'link_type', 'deleted_at'),\n        Index('idx_link_type', 'link_type', 'from_object_type', 'to_object_type'),\n        Index('idx_link_ordered', 'from_object_id', 'link_type', 'sort_order',\n              postgresql_where=\"sort_order IS NOT NULL AND deleted_at IS NULL\"),\n        Index('idx_link_strength', 'link_type', 'strength',\n              postgresql_where=\"strength IS NOT NULL\"),\n        Index('idx_link_bidirectional', 'is_bidirectional', 'link_type',\n              postgresql_where=\"is_bidirectional = true\"),\n    )\n\n    def __repr__(self):\n        return f\"<Link(id={self.id}, type={self.link_type}, \" \\\n               f\"from={self.from_object_type}:{self.from_object_id}, \" \\\n               f\"to={self.to_object_type}:{self.to_object_id})>\"\n\n    @property\n    def is_ordered(self):\n        \"\"\"Check if this is part of an ordered relationship\"\"\"\n        return self.sort_order is not None\n\n    @property\n    def is_certain(self):\n        \"\"\"Check if relationship is certain (strength = 1.0)\"\"\"\n        return self.strength is None or self.strength == 1.0\n\n    def inverse_link_type(self):\n        \"\"\"Get inverse link type for bidirectional relationships\"\"\"\n        inverse_map = {\n            'contains': 'belongs_to',\n            'belongs_to': 'contains',\n            'before': 'after',\n            'after': 'before',\n            'created_by': 'created',\n        }\n        return inverse_map.get(self.link_type)\n\n    @classmethod\n    def create_bidirectional(cls, from_id, from_type, to_id, to_type,\n                            link_type, user_id, **kwargs):\n        \"\"\"Create a bidirectional link (single record)\"\"\"\n        return cls(\n            from_object_id=from_id,\n            from_object_type=from_type,\n            to_object_id=to_id,\n            to_object_type=to_type,\n            link_type=link_type,\n            is_bidirectional=True,\n            user_id=user_id,\n            **kwargs\n        )\n\n    @classmethod\n    def create_pair(cls, obj1_id, obj1_type, obj2_id, obj2_type,\n                   link_type, inverse_type, user_id, **kwargs):\n        \"\"\"Create pair of directed links (obj1->obj2 and obj2->obj1)\"\"\"\n        link1 = cls(\n            from_object_id=obj1_id,\n            from_object_type=obj1_type,\n            to_object_id=obj2_id,\n            to_object_type=obj2_type,\n            link_type=link_type,\n            user_id=user_id,\n            **kwargs\n        )\n        link2 = cls(\n            from_object_id=obj2_id,\n            from_object_type=obj2_type,\n            to_object_id=obj1_id,\n            to_object_type=obj1_type,\n            link_type=inverse_type,\n            user_id=user_id,\n            **kwargs\n        )\n        return link1, link2\n```\n\n---\n\n## Privacy and Security Considerations\n\n### Access Control\n\n1. **Link Creation**\n   - User must own from_object\n   - User must have read access to to_object\n   - Cannot create links between other users' private objects\n\n2. **Link Visibility**\n   - Link visible if user has access to BOTH linked objects\n   - Private object links not exposed in public APIs\n   - User can only query their own links\n\n3. **Link Deletion**\n   - Only link owner can delete\n   - Deleting object should cascade delete its links\n   - Soft delete preserves historical relationships\n\n### Data Protection\n\n1. **Relationship Privacy**\n   - Links reveal connections between objects\n   - Sensitive relationships (medical, financial) require care\n   - AI-detected links should have lower default visibility\n\n2. **Graph Traversal Limits**\n   - Max depth limits prevent unbounded queries\n   - Rate limiting on graph endpoints\n   - Prevent privacy leaks through indirect connections\n\n---\n\n## Validation Rules\n\n### On Creation\n\n```yaml\nfrom_object_id and to_object_id:\n  - Must be valid UUIDs\n  - Objects should exist (can skip with flag)\n  - Cannot be same object with same type\n\nfrom_object_type and to_object_type:\n  - Must be valid object type names\n  - Case-sensitive\n\nlink_type:\n  - Must be in allowed list or new type with admin approval\n  - Lowercase with underscores\n\nstrength:\n  - Must be 0.0 to 1.0 if specified\n  - Null treated as 1.0\n\nsort_order:\n  - Must be integer if specified\n  - Should be unique within (from_object_id, link_type) for ordered relationships\n\nuser_id:\n  - Typically same as from_object owner\n  - Must have permission to create link\n```\n\n### On Update\n\n```yaml\nimmutable_fields:\n  - id\n  - user_id\n  - from_object_id\n  - from_object_type\n  - to_object_id\n  - to_object_type\n  - link_type\n  - created_at\n\nmutable_fields:\n  - strength\n  - is_bidirectional\n  - sort_order\n  - metadata\n  - updated_at\n```\n\n### Database Constraints\n\n```sql\n-- Check constraints\nCHECK ((from_object_id != to_object_id) OR (from_object_type != to_object_type))\nCHECK (strength IS NULL OR (strength >= 0.0 AND strength <= 1.0))\n\n-- Unique constraint (no duplicate links)\nUNIQUE (from_object_id, to_object_id, link_type) WHERE deleted_at IS NULL\n\n-- Indexes for performance\nCREATE INDEX idx_link_from ON links(from_object_id, link_type) WHERE deleted_at IS NULL;\nCREATE INDEX idx_link_to ON links(to_object_id, link_type) WHERE deleted_at IS NULL;\nCREATE INDEX idx_link_type ON links(link_type, from_object_type, to_object_type);\nCREATE INDEX idx_link_ordered ON links(from_object_id, link_type, sort_order)\n  WHERE sort_order IS NOT NULL AND deleted_at IS NULL;\nCREATE INDEX idx_link_user ON links(user_id, link_type) WHERE deleted_at IS NULL;\n```\n\n---\n\n## Use Cases and Examples\n\n### Example 1: Album Contains Photos\n\n```json\n{\n  \"id\": \"link-550e8400-e29b-41d4-a716-446655440000\",\n  \"user_id\": \"user-123-uuid\",\n  \"from_object_id\": \"album-uuid-abc\",\n  \"from_object_type\": \"Album\",\n  \"to_object_id\": \"photo-uuid-xyz\",\n  \"to_object_type\": \"Photo\",\n  \"link_type\": \"contains\",\n  \"strength\": 1.0,\n  \"is_bidirectional\": false,\n  \"sort_order\": 5,\n  \"metadata\": {\n    \"added_to_album_at\": \"2026-02-09T10:00:00Z\",\n    \"featured\": true,\n    \"caption\": \"Sunset at the beach\"\n  },\n  \"source_type\": \"user\",\n  \"created_at\": \"2026-02-09T10:00:00Z\",\n  \"updated_at\": \"2026-02-09T10:00:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 2: Photo Sourced from Integration\n\n```json\n{\n  \"id\": \"link-550e8400-e29b-41d4-a716-446655440001\",\n  \"user_id\": \"user-123-uuid\",\n  \"from_object_id\": \"photo-uuid-xyz\",\n  \"from_object_type\": \"Photo\",\n  \"to_object_id\": \"integration-uuid-instagram\",\n  \"to_object_type\": \"Integration\",\n  \"link_type\": \"source\",\n  \"strength\": 1.0,\n  \"is_bidirectional\": false,\n  \"sort_order\": null,\n  \"metadata\": {\n    \"sync_timestamp\": \"2026-02-09T09:00:00Z\",\n    \"original_id\": \"instagram:12345678\",\n    \"original_url\": \"https://instagram.com/p/ABC123\",\n    \"sync_batch_id\": \"batch-uuid\"\n  },\n  \"source_type\": \"integration\",\n  \"source_id\": \"instagram:12345678\",\n  \"created_at\": \"2026-02-09T09:00:00Z\",\n  \"updated_at\": \"2026-02-09T09:00:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 3: Photo Duplicate Detection\n\n```json\n{\n  \"id\": \"link-550e8400-e29b-41d4-a716-446655440002\",\n  \"user_id\": \"user-123-uuid\",\n  \"from_object_id\": \"photo-uuid-duplicate\",\n  \"from_object_type\": \"Photo\",\n  \"to_object_id\": \"photo-uuid-original\",\n  \"to_object_type\": \"Photo\",\n  \"link_type\": \"duplicate_of\",\n  \"strength\": 1.0,\n  \"is_bidirectional\": false,\n  \"sort_order\": null,\n  \"metadata\": {\n    \"detection_method\": \"perceptual_hash\",\n    \"hash_similarity\": 1.0,\n    \"file_size_diff\": 0,\n    \"pixel_dimensions_match\": true,\n    \"confirmed_by_user\": false\n  },\n  \"source_type\": \"system\",\n  \"created_at\": \"2026-02-09T09:30:00Z\",\n  \"updated_at\": \"2026-02-09T09:30:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 4: AI-Detected Similar Photos\n\n```json\n{\n  \"id\": \"link-550e8400-e29b-41d4-a716-446655440003\",\n  \"user_id\": \"user-123-uuid\",\n  \"from_object_id\": \"photo-uuid-1\",\n  \"from_object_type\": \"Photo\",\n  \"to_object_id\": \"photo-uuid-2\",\n  \"to_object_type\": \"Photo\",\n  \"link_type\": \"similar_to\",\n  \"strength\": 0.87,\n  \"is_bidirectional\": true,\n  \"sort_order\": null,\n  \"metadata\": {\n    \"similarity_score\": 0.87,\n    \"similarity_method\": \"clip_embedding\",\n    \"embedding_distance\": 0.13,\n    \"model_version\": \"openai-clip-vit-l-14\",\n    \"detected_at\": \"2026-02-09T11:00:00Z\",\n    \"reasoning\": \"Similar visual content and composition\"\n  },\n  \"source_type\": \"ai\",\n  \"created_at\": \"2026-02-09T11:00:00Z\",\n  \"updated_at\": \"2026-02-09T11:00:00Z\",\n  \"deleted_at\": null\n}\n```\n\n### Example 5: Photo Depicts Person\n\n```json\n{\n  \"id\": \"link-550e8400-e29b-41d4-a716-446655440004\",\n  \"user_id\": \"user-123-uuid\",\n  \"from_object_id\": \"photo-uuid\",\n  \"from_object_type\": \"Photo\",\n  \"to_object_id\": \"contact-uuid\",\n  \"to_object_type\": \"Contact\",\n  \"link_type\": \"depicts\",\n  \"strength\": 0.92,\n  \"is_bidirectional\": false,\n  \"sort_order\": null,\n  \"metadata\": {\n    \"face_bounding_box\": {\n      \"x\": 100,\n      \"y\": 150,\n      \"width\": 80,\n      \"height\": 100\n    },\n    \"face_confidence\": 0.98,\n    \"recognition_confidence\": 0.92,\n    \"recognition_method\": \"facenet_v2\",\n    \"manually_confirmed\": true\n  },\n  \"source_type\": \"ai\",\n  \"created_at\": \"2026-02-09T09:00:00Z\",\n  \"updated_at\": \"2026-02-09T12:00:00Z\",\n  \"deleted_at\": null\n}\n```\n\n---\n\n## Lifecycle States\n\nLinks have simpler lifecycle than other objects:\n\n### 1. Active (Normal State)\n\n```yaml\nstate: \"active\"\ndeleted_at: null\ncapabilities:\n  - Relationship is valid\n  - Appears in queries\n  - Can be traversed\ntransitions:\n  - delete -> Deleted\n```\n\n### 2. Deleted (Soft Delete)\n\n```yaml\nstate: \"deleted\"\ndeleted_at: not null\ncapabilities:\n  - Relationship is hidden\n  - Excluded from queries (unless explicitly included)\n  - Can be restored\n  - Preserved for audit\ntransitions:\n  - restore -> Active\n  - hard_delete -> Permanently Removed\n```\n\n---\n\n## Notes for Implementers\n\n### Query Patterns\n\n```python\n# Get all photos in album (ordered)\nphotos = session.query(Photo).join(Link,\n    Link.to_object_id == Photo.id\n).filter(\n    Link.from_object_id == album_id,\n    Link.from_object_type == 'Album',\n    Link.to_object_type == 'Photo',\n    Link.link_type == 'contains',\n    Link.deleted_at == None\n).order_by(Link.sort_order).all()\n\n# Get source integration for photo\nintegration = session.query(Integration).join(Link,\n    Link.to_object_id == Integration.id\n).filter(\n    Link.from_object_id == photo_id,\n    Link.link_type == 'source',\n    Link.deleted_at == None\n).first()\n\n# Get similar photos (bidirectional)\nsimilar = session.query(Photo).join(Link,\n    or_(\n        and_(Link.to_object_id == Photo.id,\n             Link.from_object_id == photo_id),\n        and_(Link.from_object_id == Photo.id,\n             Link.to_object_id == photo_id)\n    )\n).filter(\n    Link.link_type == 'similar_to',\n    Link.is_bidirectional == True,\n    Link.strength >= 0.8,\n    Link.deleted_at == None\n).all()\n\n# Get all related objects (any type, any direction)\nrelated = session.query(Link).filter(\n    or_(\n        Link.from_object_id == object_id,\n        Link.to_object_id == object_id\n    ),\n    Link.deleted_at == None\n).all()\n```\n\n### Graph Traversal Algorithm\n\n```python\ndef traverse_graph(start_id, link_types=None, max_depth=2, direction='outgoing'):\n    \"\"\"Multi-hop graph traversal\"\"\"\n    visited = set()\n    queue = [(start_id, 0)]  # (object_id, depth)\n    nodes = []\n    edges = []\n\n    while queue:\n        current_id, depth = queue.pop(0)\n\n        if current_id in visited or depth > max_depth:\n            continue\n\n        visited.add(current_id)\n\n        # Get links from current node\n        if direction in ['outgoing', 'both']:\n            outgoing = session.query(Link).filter(\n                Link.from_object_id == current_id,\n                Link.deleted_at == None\n            )\n            if link_types:\n                outgoing = outgoing.filter(Link.link_type.in_(link_types))\n\n            for link in outgoing:\n                edges.append(link)\n                if link.to_object_id not in visited:\n                    queue.append((link.to_object_id, depth + 1))\n\n        if direction in ['incoming', 'both']:\n            incoming = session.query(Link).filter(\n                Link.to_object_id == current_id,\n                Link.deleted_at == None\n            )\n            if link_types:\n                incoming = incoming.filter(Link.link_type.in_(link_types))\n\n            for link in incoming:\n                edges.append(link)\n                if link.from_object_id not in visited:\n                    queue.append((link.from_object_id, depth + 1))\n\n    return visited, edges\n```\n\n### Cascade Delete Handling\n\n```python\n@event.listens_for(Photo, 'before_delete')\ndef delete_photo_links(mapper, connection, target):\n    \"\"\"Delete all links when photo is deleted\"\"\"\n    connection.execute(\n        Link.__table__.update().where(\n            or_(\n                Link.from_object_id == target.id,\n                Link.to_object_id == target.id\n            )\n        ).values(deleted_at=datetime.utcnow())\n    )\n```\n\n---\n\n**Status:** Active - Critical Core Type\n**Version:** 1.0\n**Authority:** 0.0.1 - Core Types\n**Created:** 2026-02-09\n**Owner:** Hypernet Core (0.*)\n"
  },
  "created_at": "2026-02-17T01:23:28.944213+00:00",
  "updated_at": "2026-02-17T01:23:28.944213+00:00",
  "deleted_at": null,
  "source_type": "import",
  "source_id": "file:0.0.1.3-LINK.md"
}