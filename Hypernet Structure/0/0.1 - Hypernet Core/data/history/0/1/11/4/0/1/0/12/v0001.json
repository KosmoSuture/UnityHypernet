{
  "version": 1,
  "content_hash": "fb11f4332edd9907",
  "snapshot_at": "2026-02-17T01:22:19.916043+00:00",
  "node": {
    "address": "0.1.11.4.0.1.0.12",
    "type_address": null,
    "data": {
      "name": "12",
      "type": "folder",
      "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\data\\nodes\\0\\1\\0\\12",
      "content_preview": "{\n  \"address\": \"0.1.0.12\",\n  \"type_address\": null,\n  \"data\": {\n    \"name\": \"Database-Design\",\n    \"type\": \"folder\",\n    \"path\": \"C:\\\\Hypernet\\\\Hypernet Structure\\\\0\\\\0.1 - Hypernet Core\\\\0.1.0 - Planning & Documentation\\\\Database-Design\",\n    \"content_preview\": \"# Database Design Documentation\\n\\n## Overview\\n\\nThis directory contains the complete PostgreSQL database schema for Hypernet Core 0.1, implementing the object model and link model specifications.\\n\\n---\\n\\n## Documents\\n\\n### 1. Database Schema (15KB)\\n**File:** `01-Database-Schema.md`\\n\\nComplete PostgreSQL schema design with:\\n- 8 tables (users, media, albums, integrations, integration_secrets, links, refresh_tokens, audit_log)\\n- Indexes for performance\\n- Constraints for data integrity\\n- Triggers for auto-updating timestamps\\n- Views for convenience queries\\n- Common query examples\\n\\n### 2. Initial Migration SQL (7KB)\\n**File:** `02-Initial-Migration.sql`\\n\\nReady-to-run SQL script that creates:\\n- All tables\\n- All indexes\\n- All constraints\\n- All triggers\\n- Convenience views\\n- Test admin user\\n\\n**Usage:**\\n```bash\\npsql -U hypernet -d hypernet -f 02-Initial-Migration.sql\\n```\\n\\n---\\n\\n## Schema Summary\\n\\n### Core Tables\\n\\n| Table | Purpose | Key Fields |\\n|-------|---------|------------|\\n| **users** | Accounts & auth | email, password_hash, storage_quota |\\n| **media** | Photos/videos | filename, hash, file_path, metadata (JSONB) |\\n| **albums** | Collections | name, cover_media_id, media_count |\\n| **integrations** | External services | integration_type, status, sync_cursor |\\n| **integration_secrets** | OAuth tokens | access_token, refresh_token (encrypted) |\\n| **links** | Relationships | from/to object, link_type, strength |\\n\\n### Supporting Tables\\n\\n| Table | Purpose |\\n|-------|---------|\\n| **refresh_tokens** | JWT refresh token management |\\n| **audit_log** | Security audit trail |\\n\\n---\\n\\n## Key Design Decisions\\n\\n### 1. Hybrid Schema (Core + Metadata)\\n\\n**Core fields:** Strongly typed, indexed, frequently queried\\n```sql\\nfilename VARCHAR(255) NOT NULL\\nmedia_type VARCHAR(50) NOT NULL\\ntaken_at TIMESTAMP WITH TIME ZONE\\n```\\n\\n**Metadata field:** Flexible JSONB for integration-specific data\\n```sql\\nmetadata JSONB NOT NULL DEFAULT '{}'::jsonb\\n```\\n\\n**Benefits:**\\n- \\u2705 Performant queries on common fields\\n- \\u2705 Extensible for new integrations\\n- \\u2705 No schema changes needed for new data types\\n\\n### 2. Soft Deletes\\n\\nAll main tables have `deleted_at` column:\\n```sql\\ndeleted_at TIMESTAMP WITH TIME ZONE\\n```\\n\\n**Benefits:**\\n- Can restore accidentally deleted data\\n- Audit trail preserved\\n- Hard delete after retention period (30 days)\\n\\n**Indexes exclude deleted:**\\n```sql\\nCREATE INDEX idx_media_user_id ON media(user_id) WHERE deleted_at IS NULL;\\n```\\n\\n### 3. First-Class Links\\n\\nLinks are objects, not just foreign keys:\\n\\n**Traditional approach:**\\n```sql\\n-- Media can only be in ONE album\\nALTER TABLE media ADD COLUMN album_id UUID;\\n```\\n\\n**Hypernet approach:**\\n```sql\\n-- Media can be in MANY albums via links\\nINSERT INTO links (from_object_id, to_object_id, link_type)\\nVALUES (album_id, media_id, 'contains');\\n```\\n\\n**Benefits:**\\n- Many-to-many relationships\\n- Rich metadata on relationships\\n- Easy to query all relationships\\n- Flexible relationship types\\n\\n### 4. UUIDs for All IDs\\n\\n```sql\\nid UUID PRIMARY KEY DEFAULT gen_random_uuid()\\n```\\n\\n**Benefits:**\\n- Globally unique (can merge databases)\\n- No auto-increment race conditions\\n- Can generate client-side\\n- Security (not sequential)\\n\\n### 5. Denormalized Counts\\n\\n```sql\\nALTER TABLE albums ADD COLUMN media_count INTEGER NOT NULL DEFAULT 0;\\n```\\n\\n**Trade-off:**\\n- \\u2705 Fast reads (no COUNT query)\\n- \\u274c Slower writes (must update count)\\n- \\u2705 Worth it for frequently displayed data\\n\\n---\\n\\n## Relationships\\n\\n### Ownership (1:N)\\n```\\nUser \\u2192 Media (user_id foreign key)\\nUser \\u2192 Albums (user_id foreign key)\\nUser \\u2192 Integrations (user_id foreign key)\\nUser \\u2192 Links (user_id foreign key)\\n```\\n\\nAll with `ON DELETE CASCADE` - deleting user deletes all their data.\\n\\n### Links (M:N via link objects)\\n```\\nAlbum \\u2192 Media (via Link, type='contains')\\nMedia \\u2192 Integration (via Link, type='source')\\nMedia \\u2194 Media (via Link, type='duplicate_of', bidirectional)\\nMedia \\u2192 Media (via Link, type='variant_of', thumbnails)\\n```\\n\\n### Direct Foreign Keys\\n```\\nAlbum \\u2192 Media (cover_media_id, ON DELETE SET NULL)\\n```\\n\\n---\\n\\n## Common Queries\\n\\n### Get user's media (paginated)\\n```sql\\nSELECT * FROM media\\nWHERE user_id = $1 AND deleted_at IS NULL\\nORDER BY taken_at DESC NULLS LAST\\nLIMIT 50 OFFSET 0;\\n```\\n\\n### Get media in album\\n```sql\\nSELECT m.*, l.sort_order\\nFROM media m\\nJOIN links l ON l.to_object_id = m.id\\nWHERE l.from_object_id = $1  -- album_id\\n  AND l.link_type = 'contains'\\n  AND l.deleted_at IS NULL\\n  AND m.deleted_at IS NULL\\nORDER BY l.sort_order;\\n```\\n\\n### Check if media already imported\\n```sql\\nSELECT m.id FROM media m\\nJOIN links l ON l.from_object_id = m.id\\nWHERE m.user_id = $1\\n  AND l.to_object_id = $2  -- integration_id\\n  AND l.link_type = 'source'\\n  AND l.metadata->>'external_id' = $3\\n  AND m.deleted_at IS NULL\\nLIMIT 1;\\n```\\n\\n---\\n\\n## Indexes Strategy\\n\\n### Partial Indexes (Exclude Soft-Deleted)\\n```sql\\nCREATE INDEX idx_media_user_id ON media(user_id)\\nWHERE deleted_at IS NULL;\\n```\\n\\n**Benefit:** Index only includes active rows, smaller and faster.\\n\\n### Composite Indexes\\n```sql\\nCREATE INDEX idx_media_source\\nON media(user_id, source_type, source_id)\\nWHERE deleted_at IS NULL;\\n```\\n\\n**Benefit:** Fast deduplication queries during sync.\\n\\n### GIN Indexes (JSONB)\\n```sql\\nCREATE INDEX idx_media_metadata\\nON media USING GIN(metadata);\\n```\\n\\n**Benefit:** Query inside JSON metadata.\\n```sql\\nWHERE metadata->>'camera' = 'iPhone 15'\\n```\\n\\n### Unique Indexes\\n```sql\\nCREATE UNIQUE INDEX idx_links_unique\\nON links(from_object_id, to_object_id, link_type)\\nWHERE deleted_at IS NULL;\\n```\\n\\n**Benefit:** Prevent duplicate links.\\n\\n---\\n\\n## Security\\n\\n### Database-Level Encryption\\n\\nEntire `/data` partition encrypted with LUKS2:\\n```bash\\ncryptsetup luksFormat /dev/sda4\\ncryptsetup open /dev/sda4 data-encrypted\\nmkfs.ext4 /dev/mapper/data-encrypted\\n```\\n\\n### Column-Level Encryption (Optional)\\n\\nFor sensitive fields like OAuth tokens:\\n```sql\\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\\n\\n-- Encrypt on insert\\nINSERT INTO integration_secrets (access_token)\\nVALUES (pgp_sym_encrypt($1, 'encryption-key'));\\n\\n-- Decrypt on read\\nSELECT pgp_sym_decrypt(access_token::bytea, 'encryption-key')\\nFROM integration_secrets WHERE integration_id = $1;\\n```\\n\\n### Row-Level Security (Future)\\n\\n```sql\\nALTER TABLE media ENABLE ROW LEVEL SECURITY;\\n\\nCREATE POLICY media_user_isolation ON media\\nFOR ALL\\nUSING (user_id = current_setting('app.current_user_id')::uuid);\\n```\\n\\nApplication sets context:\\n```sql\\nSET app.current_user_id = 'user-uuid';\\n```\\n\\n---\\n\\n## Performance Optimization\\n\\n### Query Performance\\n1. **Always filter by deleted_at IS NULL**\\n2. **Use LIMIT for large result sets**\\n3. **Leverage partial indexes** (WHERE deleted_at IS NULL)\\n4. **Use EXPLAIN ANALYZE** to check query plans\\n\\n### Write Performance\\n1. **Batch inserts** when importing from integrations\\n2. **Update denormalized counts** asynchronously if needed\\n3. **Use transactions** for multi-step operations\\n\\n### Maintenance\\n```sql\\n-- Run weekly\\nVACUUM ANALYZE;\\n\\n-- Or per table\\nVACUUM ANALYZE media;\\n```\\n\\n---\\n\\n## Backup Strategy\\n\\n### Daily Backups\\n```bash\\n# Backup\\npg_dump -U hypernet -d hypernet -F c \\\\\\n  -f /backup/db/hypernet-$(date +%Y%m%d).dump\\n\\n# Restore\\npg_restore -U hypernet -d hypernet \\\\\\n  /backup/db/hypernet-20260203.dump\\n```\\n\\n### Point-in-Time Recovery (PITR)\\n\\nEnable WAL archiving in `postgresql.conf`:\\n```\\nwal_level = replica\\narchive_mode = on\\narchive_command = 'cp %p /backup/wal/%f'\\n```\\n\\n---\\n\\n## Migration Strategy\\n\\n### Alembic (SQLAlchemy Migrations)\\n\\n**Directory structure:**\\n```\\nalembic/\\n  \\u251c\\u2500\\u2500 versions/\\n  \\u2502   \\u251c\\u2500\\u2500 0001_initial.py\\n  \\u2502   \\u251c\\u2500\\u2500 0002_add_ai_tags.py\\n  \\u2502   \\u2514\\u2500\\u2500 ...\\n  \\u251c\\u2500\\u2500 env.py\\n  \\u2514\\u2500\\u2500 alembic.ini\\n```\\n\\n**Create migration:**\\n```bash\\nalembic revision --autogenerate -m \\\"Add AI tags to media\\\"\\n```\\n\\n**Apply migrations:**\\n```bash\\nalembic upgrade head\\n```\\n\\n**Rollback:**\\n```bash\\nalembic downgrade -1\\n```\\n\\n---\\n\\n## Testing the Schema\\n\\n### 1. Create Database\\n```bash\\ncreatedb -U postgres hypernet\\npsql -U postgres -d hypernet -c \\\"CREATE ROLE hypernet WITH LOGIN PASSWORD 'secure-password';\\\"\\npsql -U postgres -d hypernet -c \\\"GRANT ALL PRIVILEGES ON DATABASE hypernet TO hypernet;\\\"\\n```\\n\\n### 2. Run Migration\\n```bash\\npsql -U hypernet -d hypernet -f 02-Initial-Migration.sql\\n```\\n\\n### 3. Verify Tables\\n```sql\\n\\\\dt  -- List tables\\n\\\\d users  -- Describe users table\\n\\\\di  -- List indexes\\n```\\n\\n### 4. Insert Test Data\\n```sql\\n-- Create test user\\nINSERT INTO users (email, password_hash, display_name)\\nVALUES ('test@example.com', 'hashed-password', 'Test User');\\n\\n-- Create test media\\nINSERT INTO media (user_id, filename, media_type, mime_type, size, file_path, hash)\\nVALUES (\\n  (SELECT id FROM users WHERE email = 'test@example.com'),\\n  'test-photo.jpg',\\n  'photo',\\n  'image/jpeg',\\n  1024000,\\n  'users/.../media/2026/02/test.jpg',\\n  'abcd1234...'\\n);\\n\\n-- Create test album\\nINSERT INTO albums (user_id, name)\\nVALUES (\\n  (SELECT id FROM users WHERE email = 'test@example.com'),\\n  'Test Album'\\n);\\n\\n-- Link media to album\\nINSERT INTO links (user_id, from_object_id, from_object_type, to_object_id, to_object_type, link_type)\\nVALUES (\\n  (SELECT id FROM users WHERE email = 'test@example.com'),\\n  (SELECT id FROM albums WHERE name = 'Test Album'),\\n  'album',\\n  (SELECT id FROM media WHERE fi\n... [truncated]",
      "content_file": "node.json"
    },
    "created_at": "2026-02-17T01:20:10.269266+00:00",
    "updated_at": "2026-02-17T01:20:10.269266+00:00",
    "deleted_at": null,
    "source_type": "import",
    "source_id": "folder:12"
  }
}