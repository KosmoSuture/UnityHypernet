{
  "version": 1,
  "content_hash": "c1867190b421ca6e",
  "snapshot_at": "2026-02-17T01:21:59.104708+00:00",
  "node": {
    "address": "0.1.1.9.6.1",
    "type_address": null,
    "data": {
      "name": "README.md",
      "type": "file",
      "extension": ".md",
      "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\services\\README.md",
      "size": 20854,
      "content": "# Services - Business Logic Layer\n\n**Purpose:** Business logic services for Hypernet Core application\n\n**Status:** Active development\n\n---\n\n## Overview\n\nThis directory contains the **service layer** for Hypernet Core - the business logic that sits between the API routes and the database models. Services encapsulate complex operations, enforce business rules, and coordinate between multiple models.\n\n---\n\n## Architecture Pattern\n\nHypernet follows a **layered architecture**:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Routes (app/routes/)                       \u2502\n\u2502  - Handle HTTP requests/responses           \u2502\n\u2502  - Validate input (Pydantic)                \u2502\n\u2502  - Authentication/authorization checks      \u2502\n\u2502  - Call service layer                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Services (app/services/) \u2190 YOU ARE HERE    \u2502\n\u2502  - Business logic                           \u2502\n\u2502  - Transaction management                   \u2502\n\u2502  - Orchestrate multiple models              \u2502\n\u2502  - Enforce business rules                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Models (app/models/)                       \u2502\n\u2502  - SQLAlchemy ORM models                    \u2502\n\u2502  - Database schema definitions              \u2502\n\u2502  - Basic CRUD operations                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Database (PostgreSQL)                      \u2502\n\u2502  - Persistent storage                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## Why Services?\n\n### Problems Services Solve\n\n**1. Fat Routes**\n```python\n# \u274c BAD: Business logic in route handler\n@router.post(\"/albums/{album_id}/media\")\nasync def add_media_to_album(album_id: UUID, media_id: UUID, db: Session):\n    # Complex logic mixed with HTTP handling\n    album = db.query(Album).filter(Album.id == album_id).first()\n    if not album:\n        raise HTTPException(404)\n    media = db.query(Media).filter(Media.id == media_id).first()\n    if not media:\n        raise HTTPException(404)\n    link = Link(from_object_id=album_id, to_object_id=media_id, ...)\n    db.add(link)\n    album.media_count += 1\n    db.commit()\n    return link\n```\n\n**2. Duplicated Code**\n```python\n# Same logic repeated in multiple routes\n@router.post(\"/albums/{id}/media\")  # Adds to album.media_count\n@router.delete(\"/albums/{id}/media/{media_id}\")  # Decrements album.media_count\n# Both need same logic - better in service!\n```\n\n**3. Hard to Test**\n```python\n# Testing routes requires mocking HTTP layer\n# Testing services only requires database session\n```\n\n**4. Transaction Management**\n```python\n# Multiple database operations need to be atomic\n# Services handle transaction boundaries\n```\n\n### Benefits of Services\n\n\u2705 **Reusability:** Logic can be called from routes, background jobs, CLI tools\n\u2705 **Testability:** Easy to unit test without HTTP mocking\n\u2705 **Maintainability:** Business logic in one place\n\u2705 **Transactions:** Proper transaction boundaries\n\u2705 **Separation of Concerns:** Routes handle HTTP, services handle business logic\n\n---\n\n## Service Structure\n\n### Naming Convention\n\nFiles named after the primary model they work with:\n\n```\napp/services/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 user_service.py         # User account operations\n\u251c\u2500\u2500 media_service.py        # Media upload, processing, metadata\n\u251c\u2500\u2500 album_service.py        # Album creation, media organization\n\u251c\u2500\u2500 integration_service.py  # Integration connection, sync\n\u251c\u2500\u2500 link_service.py         # Link creation, querying\n\u2514\u2500\u2500 auth_service.py         # Authentication, token management\n```\n\n### Service Class Structure\n\n```python\n# app/services/media_service.py\nfrom sqlalchemy.orm import Session\nfrom app.models.media import Media\nfrom app.models.link import Link\nfrom uuid import UUID\n\nclass MediaService:\n    \"\"\"\n    Business logic for media operations.\n\n    Responsibilities:\n    - Upload and process media files\n    - Extract metadata (EXIF)\n    - Generate thumbnails\n    - Manage media lifecycle\n    - Link media to albums and integrations\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Initialize service with database session.\n\n        Args:\n            db: SQLAlchemy database session\n        \"\"\"\n        self.db = db\n\n    def upload_media(self, user_id: UUID, file, metadata: dict) -> Media:\n        \"\"\"\n        Upload and process a media file.\n\n        Args:\n            user_id: Owner of the media\n            file: Uploaded file object\n            metadata: Additional metadata\n\n        Returns:\n            Created Media object\n\n        Raises:\n            ValueError: Invalid file type or size\n            StorageError: Failed to save file\n        \"\"\"\n        # Business logic here\n        pass\n\n    def add_to_album(self, media_id: UUID, album_id: UUID, user_id: UUID) -> Link:\n        \"\"\"\n        Add media to an album.\n\n        This is a transactional operation:\n        1. Create link object\n        2. Increment album.media_count\n        3. Commit or rollback both\n\n        Args:\n            media_id: Media to add\n            album_id: Target album\n            user_id: User performing operation (for authorization)\n\n        Returns:\n            Created Link object\n\n        Raises:\n            NotFoundError: Media or album doesn't exist\n            PermissionError: User doesn't own media or album\n            DuplicateError: Media already in album\n        \"\"\"\n        # Business logic here\n        pass\n```\n\n---\n\n## Service Patterns\n\n### 1. Create Operation\n\n```python\ndef create_album(self, user_id: UUID, name: str, description: str = None) -> Album:\n    \"\"\"Create a new album.\"\"\"\n\n    # Validate business rules\n    if not name or len(name.strip()) == 0:\n        raise ValueError(\"Album name cannot be empty\")\n\n    if len(name) > 100:\n        raise ValueError(\"Album name too long (max 100 characters)\")\n\n    # Create object\n    album = Album(\n        user_id=user_id,\n        name=name.strip(),\n        description=description.strip() if description else None,\n        media_count=0\n    )\n\n    # Save to database\n    self.db.add(album)\n    self.db.commit()\n    self.db.refresh(album)\n\n    return album\n```\n\n### 2. Read/Query Operation\n\n```python\ndef get_album_media(\n    self,\n    album_id: UUID,\n    user_id: UUID,\n    limit: int = 50,\n    offset: int = 0\n) -> list[Media]:\n    \"\"\"Get media in an album (paginated).\"\"\"\n\n    # Verify ownership\n    album = self.db.query(Album).filter(Album.id == album_id).first()\n    if not album:\n        raise NotFoundError(f\"Album {album_id} not found\")\n\n    if album.user_id != user_id:\n        raise PermissionError(\"You don't own this album\")\n\n    # Query with joins\n    media = (\n        self.db.query(Media)\n        .join(Link, Link.to_object_id == Media.id)\n        .filter(\n            Link.from_object_id == album_id,\n            Link.link_type == \"contains\",\n            Link.deleted_at.is_(None),\n            Media.deleted_at.is_(None)\n        )\n        .order_by(Link.sort_order)\n        .limit(limit)\n        .offset(offset)\n        .all()\n    )\n\n    return media\n```\n\n### 3. Update Operation\n\n```python\ndef update_album(\n    self,\n    album_id: UUID,\n    user_id: UUID,\n    name: str = None,\n    description: str = None\n) -> Album:\n    \"\"\"Update album details.\"\"\"\n\n    # Get and verify ownership\n    album = self.db.query(Album).filter(Album.id == album_id).first()\n    if not album:\n        raise NotFoundError(f\"Album {album_id} not found\")\n\n    if album.user_id != user_id:\n        raise PermissionError(\"You don't own this album\")\n\n    # Update fields\n    if name is not None:\n        if not name.strip():\n            raise ValueError(\"Album name cannot be empty\")\n        album.name = name.strip()\n\n    if description is not None:\n        album.description = description.strip() if description else None\n\n    # Save changes\n    self.db.commit()\n    self.db.refresh(album)\n\n    return album\n```\n\n### 4. Delete Operation (Soft Delete)\n\n```python\ndef delete_album(self, album_id: UUID, user_id: UUID) -> None:\n    \"\"\"Soft delete an album.\"\"\"\n\n    # Get and verify ownership\n    album = self.db.query(Album).filter(Album.id == album_id).first()\n    if not album:\n        raise NotFoundError(f\"Album {album_id} not found\")\n\n    if album.user_id != user_id:\n        raise PermissionError(\"You don't own this album\")\n\n    # Soft delete (set deleted_at)\n    from datetime import datetime, timezone\n    album.deleted_at = datetime.now(timezone.utc)\n\n    # Also soft delete all links\n    self.db.query(Link).filter(\n        Link.from_object_id == album_id,\n        Link.deleted_at.is_(None)\n    ).update({\"deleted_at\": datetime.now(timezone.utc)})\n\n    self.db.commit()\n```\n\n### 5. Complex Transaction\n\n```python\ndef sync_from_integration(\n    self,\n    integration_id: UUID,\n    user_id: UUID,\n    limit: int = 100\n) -> dict:\n    \"\"\"\n    Sync media from an integration.\n\n    This is a complex multi-step transaction:\n    1. Fetch items from external API\n    2. Check for duplicates\n    3. Download new media\n    4. Create Media objects\n    5. Create Link objects (media \u2192 integration)\n    6. Update integration sync state\n\n    Returns:\n        Sync summary (new_count, skipped_count, error_count)\n    \"\"\"\n\n    try:\n        # Get integration\n        integration = self.db.query(Integration).filter(\n            Integration.id == integration_id,\n            Integration.user_id == user_id\n        ).first()\n\n        if not integration:\n            raise NotFoundError(\"Integration not found\")\n\n        # Fetch from external API (using integration-specific client)\n        client = self._get_integration_client(integration)\n        items = client.fetch_media(cursor=integration.sync_cursor, limit=limit)\n\n        new_count = 0\n        skipped_count = 0\n\n        for item in items:\n            # Check if already imported\n            existing = self.db.query(Link).filter(\n                Link.to_object_id == integration_id,\n                Link.link_type == \"source\",\n                Link.metadata[\"external_id\"].astext == item.id\n            ).first()\n\n            if existing:\n                skipped_count += 1\n                continue\n\n            # Download and create media\n            file_path = self._download_media(item.url)\n            media = self._create_media(user_id, file_path, item.metadata)\n\n            # Create source link\n            link = Link(\n                user_id=user_id,\n                from_object_id=media.id,\n                to_object_id=integration_id,\n                link_type=\"source\",\n                metadata={\"external_id\": item.id, \"external_url\": item.url}\n            )\n            self.db.add(link)\n\n            new_count += 1\n\n        # Update sync cursor\n        integration.sync_cursor = items[-1].cursor if items else integration.sync_cursor\n        integration.last_sync_at = datetime.now(timezone.utc)\n\n        self.db.commit()\n\n        return {\n            \"new_count\": new_count,\n            \"skipped_count\": skipped_count,\n            \"next_cursor\": integration.sync_cursor\n        }\n\n    except Exception as e:\n        self.db.rollback()\n        raise SyncError(f\"Sync failed: {str(e)}\")\n```\n\n---\n\n## Error Handling\n\n### Custom Exceptions\n\nDefine service-specific exceptions:\n\n```python\n# app/services/exceptions.py\n\nclass ServiceError(Exception):\n    \"\"\"Base exception for service errors.\"\"\"\n    pass\n\nclass NotFoundError(ServiceError):\n    \"\"\"Resource not found.\"\"\"\n    pass\n\nclass PermissionError(ServiceError):\n    \"\"\"User doesn't have permission.\"\"\"\n    pass\n\nclass ValidationError(ServiceError):\n    \"\"\"Business rule validation failed.\"\"\"\n    pass\n\nclass DuplicateError(ServiceError):\n    \"\"\"Resource already exists.\"\"\"\n    pass\n\nclass StorageError(ServiceError):\n    \"\"\"File storage operation failed.\"\"\"\n    pass\n\nclass SyncError(ServiceError):\n    \"\"\"Integration sync failed.\"\"\"\n    pass\n```\n\n### Routes Handle HTTP Status\n\n```python\n# app/routes/albums.py\nfrom fastapi import HTTPException\nfrom app.services.album_service import AlbumService\nfrom app.services.exceptions import NotFoundError, PermissionError\n\n@router.get(\"/albums/{album_id}\")\nasync def get_album(album_id: UUID, db: Session = Depends(get_db)):\n    service = AlbumService(db)\n\n    try:\n        album = service.get_album(album_id, user_id=current_user.id)\n        return album\n\n    except NotFoundError:\n        raise HTTPException(status_code=404, detail=\"Album not found\")\n\n    except PermissionError:\n        raise HTTPException(status_code=403, detail=\"Access denied\")\n```\n\n---\n\n## Testing Services\n\n### Unit Tests\n\nServices are easy to test:\n\n```python\n# tests/services/test_album_service.py\nimport pytest\nfrom app.services.album_service import AlbumService\nfrom app.services.exceptions import NotFoundError, ValidationError\n\ndef test_create_album(db_session, test_user):\n    \"\"\"Test album creation.\"\"\"\n    service = AlbumService(db_session)\n\n    album = service.create_album(\n        user_id=test_user.id,\n        name=\"Vacation Photos\",\n        description=\"Summer 2026\"\n    )\n\n    assert album.id is not None\n    assert album.name == \"Vacation Photos\"\n    assert album.media_count == 0\n\ndef test_create_album_empty_name(db_session, test_user):\n    \"\"\"Test album creation with empty name fails.\"\"\"\n    service = AlbumService(db_session)\n\n    with pytest.raises(ValidationError):\n        service.create_album(user_id=test_user.id, name=\"\")\n\ndef test_get_album_not_found(db_session, test_user):\n    \"\"\"Test getting non-existent album.\"\"\"\n    service = AlbumService(db_session)\n\n    from uuid import uuid4\n    with pytest.raises(NotFoundError):\n        service.get_album(album_id=uuid4(), user_id=test_user.id)\n```\n\n---\n\n## Service Dependencies\n\n### Dependency Injection\n\nServices can depend on other services:\n\n```python\nclass MediaService:\n    def __init__(self, db: Session, link_service: LinkService = None):\n        self.db = db\n        self.link_service = link_service or LinkService(db)\n\n    def add_to_album(self, media_id: UUID, album_id: UUID, user_id: UUID):\n        # Use link_service to create link\n        link = self.link_service.create_link(\n            from_object_id=album_id,\n            to_object_id=media_id,\n            link_type=\"contains\",\n            user_id=user_id\n        )\n\n        # Update denormalized count\n        album = self.db.query(Album).filter(Album.id == album_id).first()\n        album.media_count += 1\n        self.db.commit()\n\n        return link\n```\n\n---\n\n## Background Jobs\n\nServices can be called from background workers:\n\n```python\n# app/workers/sync_worker.py\nfrom celery import Celery\nfrom app.services.integration_service import IntegrationService\nfrom app.core.database import SessionLocal\n\napp = Celery('hypernet')\n\n@app.task\ndef sync_integration_task(integration_id: str, user_id: str):\n    \"\"\"Background task to sync from integration.\"\"\"\n\n    db = SessionLocal()\n    try:\n        service = IntegrationService(db)\n        result = service.sync_from_integration(\n            integration_id=UUID(integration_id),\n            user_id=UUID(user_id)\n        )\n        return result\n    finally:\n        db.close()\n```\n\n---\n\n## Planned Services\n\n### Phase 1 (Weeks 3-16)\n\n1. **AuthService** - Authentication and token management\n   - `register_user()`\n   - `authenticate_user()`\n   - `create_tokens()`\n   - `refresh_access_token()`\n\n2. **UserService** - User account management\n   - `get_user()`\n   - `update_user()`\n   - `change_password()`\n   - `delete_user()`\n\n3. **MediaService** - Media upload and processing\n   - `upload_media()`\n   - `get_media()`\n   - `update_media()`\n   - `delete_media()`\n   - `generate_thumbnail()`\n   - `extract_exif()`\n\n4. **AlbumService** - Album organization\n   - `create_album()`\n   - `get_album()`\n   - `update_album()`\n   - `delete_album()`\n   - `get_album_media()`\n   - `add_media_to_album()`\n   - `remove_media_from_album()`\n\n5. **IntegrationService** - External integrations\n   - `connect_integration()`\n   - `sync_from_integration()`\n   - `disconnect_integration()`\n   - `get_sync_status()`\n\n6. **LinkService** - Relationship management\n   - `create_link()`\n   - `get_links()`\n   - `delete_link()`\n   - `find_related()`\n\n### Phase 2+ (Future)\n\n7. **SearchService** - Full-text search\n8. **TagService** - AI-powered tagging\n9. **ShareService** - Sharing and permissions\n10. **ExportService** - Data export (GDPR)\n\n---\n\n## Best Practices\n\n### 1. Single Responsibility\nEach service focuses on one domain:\n```python\n# \u2705 GOOD\nclass MediaService:  # Only media operations\nclass AlbumService:  # Only album operations\n\n# \u274c BAD\nclass MediaAlbumService:  # Mixed responsibilities\n```\n\n### 2. Explicit Dependencies\n```python\n# \u2705 GOOD\ndef __init__(self, db: Session):\n    self.db = db\n\n# \u274c BAD\ndef __init__(self):\n    from app.core.database import db  # Hidden dependency\n    self.db = db\n```\n\n### 3. Return Domain Objects\n```python\n# \u2705 GOOD\ndef get_album(self, album_id: UUID) -> Album:\n    return album  # ORM model\n\n# \u274c BAD\ndef get_album(self, album_id: UUID) -> dict:\n    return {\"id\": ..., \"name\": ...}  # Route should convert to dict\n```\n\n### 4. Handle Transactions\n```python\n# \u2705 GOOD\ndef complex_operation(self):\n    try:\n        # Multiple DB operations\n        self.db.commit()\n    except:\n        self.db.rollback()\n        raise\n\n# \u274c BAD\ndef complex_operation(self):\n    # Operations without transaction handling\n```\n\n### 5. Validate Business Rules\n```python\n# \u2705 GOOD\nif album.media_count >= 10000:\n    raise ValidationError(\"Album cannot exceed 10,000 items\")\n\n# \u274c BAD\n# No validation, let database fail\n```\n\n---\n\n## Quick Reference\n\n### Creating a New Service\n\n1. Create file: `app/services/[domain]_service.py`\n2. Define service class with `__init__(self, db: Session)`\n3. Add methods for business operations\n4. Define custom exceptions if needed\n5. Write unit tests in `tests/services/test_[domain]_service.py`\n6. Use in routes via `service = DomainService(db)`\n\n### Service Method Signature\n\n```python\ndef operation_name(\n    self,\n    # Required parameters\n    resource_id: UUID,\n    user_id: UUID,\n    # Optional parameters\n    optional_param: str = None,\n    # Pagination\n    limit: int = 50,\n    offset: int = 0\n) -> ReturnType:\n    \"\"\"\n    Brief description.\n\n    Args:\n        resource_id: Description\n        user_id: For authorization\n        optional_param: Description\n        limit: Max results\n        offset: Skip N results\n\n    Returns:\n        Description of return value\n\n    Raises:\n        NotFoundError: When resource doesn't exist\n        PermissionError: When user lacks permission\n        ValidationError: When business rule violated\n    \"\"\"\n```\n\n---\n\n## Status\n\n**Services Implemented:** 0 (folder ready for development)\n**Next Services to Build:**\n1. AuthService (authentication)\n2. UserService (user management)\n3. MediaService (file upload and processing)\n\n**Priority:** High - Needed for API implementation\n\n---\n\n**Location:** `C:\\Hypernet\\Hypernet Structure\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\services\\`\n**Version:** 1.0\n**Created:** 2026-02-10\n**Maintainer:** Hypernet Development Team\n"
    },
    "created_at": "2026-02-17T01:20:05.093571+00:00",
    "updated_at": "2026-02-17T01:20:05.093571+00:00",
    "deleted_at": null,
    "source_type": "import",
    "source_id": "file:README.md"
  }
}