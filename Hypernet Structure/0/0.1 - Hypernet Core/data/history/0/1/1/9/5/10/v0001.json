{
  "version": 1,
  "content_hash": "24500d19a0bfe7f4",
  "snapshot_at": "2026-02-17T01:21:58.962172+00:00",
  "node": {
    "address": "0.1.1.9.5.10",
    "type_address": null,
    "data": {
      "name": "media.py",
      "type": "file",
      "extension": ".py",
      "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\app\\routes\\media.py",
      "size": 8679,
      "content": "\"\"\"\nMedia Routes\n\nEndpoints for media upload, retrieval, and management.\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Query\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom uuid import UUID\n\nfrom app.core.database import get_db\nfrom app.core.dependencies import get_current_user\nfrom app.models.user import User\nfrom app.models.media import Media\n\nrouter = APIRouter()\n\n\n# Request/Response Models\nclass MediaCreate(BaseModel):\n    \"\"\"Media creation request\"\"\"\n    media_type: str = Field(..., description=\"photo, video, audio, document, screenshot\")\n    title: Optional[str] = Field(None, max_length=500)\n    description: Optional[str] = None\n    file_path: str = Field(..., max_length=512)\n    file_size: int = Field(..., ge=0)\n    mime_type: str = Field(..., max_length=100)\n    width: Optional[int] = Field(None, ge=0)\n    height: Optional[int] = Field(None, ge=0)\n    duration: Optional[int] = Field(None, ge=0)\n    taken_at: Optional[datetime] = None\n    gps_latitude: Optional[float] = Field(None, ge=-90, le=90)\n    gps_longitude: Optional[float] = Field(None, ge=-180, le=180)\n\n\nclass MediaUpdate(BaseModel):\n    \"\"\"Media update request\"\"\"\n    title: Optional[str] = Field(None, max_length=500)\n    description: Optional[str] = None\n    tags: Optional[List[str]] = None\n    is_favorite: Optional[bool] = None\n\n\nclass MediaResponse(BaseModel):\n    \"\"\"Media response\"\"\"\n    id: str\n    user_id: str\n    media_type: str\n    title: Optional[str]\n    description: Optional[str]\n    file_path: str\n    file_size: int\n    mime_type: str\n    width: Optional[int]\n    height: Optional[int]\n    duration: Optional[int]\n    taken_at: Optional[datetime]\n    created_at: datetime\n    is_favorite: bool\n    tags: Optional[List[str]]\n\n    class Config:\n        from_attributes = True\n\n\nclass MediaListResponse(BaseModel):\n    \"\"\"Paginated media list response\"\"\"\n    items: List[MediaResponse]\n    total: int\n    page: int\n    page_size: int\n\n\n@router.post(\"\", response_model=MediaResponse, status_code=status.HTTP_201_CREATED)\nasync def create_media(\n    request: MediaCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new media record.\n\n    This endpoint creates a media database record. File upload should be handled\n    separately by the upload endpoint.\n\n    - **media_type**: photo, video, audio, document, screenshot\n    - **file_path**: Path where the file is stored\n    - **file_size**: Size in bytes\n    - **mime_type**: MIME type (e.g., image/jpeg)\n    \"\"\"\n    # Create media object\n    media = Media(\n        user_id=current_user.id,\n        media_type=request.media_type,\n        title=request.title,\n        description=request.description,\n        file_path=request.file_path,\n        file_size=request.file_size,\n        mime_type=request.mime_type,\n        width=request.width,\n        height=request.height,\n        duration=request.duration,\n        taken_at=request.taken_at,\n        gps_latitude=request.gps_latitude,\n        gps_longitude=request.gps_longitude,\n        processing_status='ready'\n    )\n\n    db.add(media)\n    db.commit()\n    db.refresh(media)\n\n    return MediaResponse.model_validate(media)\n\n\n@router.get(\"\", response_model=MediaListResponse)\nasync def list_media(\n    media_type: Optional[str] = Query(None, description=\"Filter by media type\"),\n    is_favorite: Optional[bool] = Query(None, description=\"Filter favorites\"),\n    tag: Optional[str] = Query(None, description=\"Filter by tag\"),\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(50, ge=1, le=100, description=\"Items per page\"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List media items for the current user.\n\n    Supports filtering by:\n    - **media_type**: photo, video, audio, document, screenshot\n    - **is_favorite**: true/false\n    - **tag**: Search for media with specific tag\n    - Pagination with page and page_size\n    \"\"\"\n    # Build query\n    query = db.query(Media).filter(\n        and_(\n            Media.user_id == current_user.id,\n            Media.deleted_at.is_(None)\n        )\n    )\n\n    # Apply filters\n    if media_type:\n        query = query.filter(Media.media_type == media_type)\n\n    if is_favorite is not None:\n        query = query.filter(Media.is_favorite == is_favorite)\n\n    if tag:\n        query = query.filter(Media.tags.contains([tag]))\n\n    # Get total count\n    total = query.count()\n\n    # Apply pagination\n    offset = (page - 1) * page_size\n    items = query.order_by(Media.created_at.desc()).offset(offset).limit(page_size).all()\n\n    return MediaListResponse(\n        items=[MediaResponse.model_validate(item) for item in items],\n        total=total,\n        page=page,\n        page_size=page_size\n    )\n\n\n@router.get(\"/{media_id}\", response_model=MediaResponse)\nasync def get_media(\n    media_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific media item by ID.\n\n    Returns full media details including metadata.\n    \"\"\"\n    media = db.query(Media).filter(\n        and_(\n            Media.id == media_id,\n            Media.user_id == current_user.id,\n            Media.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not media:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Media not found\"\n        )\n\n    return MediaResponse.model_validate(media)\n\n\n@router.patch(\"/{media_id}\", response_model=MediaResponse)\nasync def update_media(\n    media_id: UUID,\n    request: MediaUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update media metadata.\n\n    Can update:\n    - **title**: Media title\n    - **description**: Media description\n    - **tags**: List of tags\n    - **is_favorite**: Favorite status\n    \"\"\"\n    media = db.query(Media).filter(\n        and_(\n            Media.id == media_id,\n            Media.user_id == current_user.id,\n            Media.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not media:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Media not found\"\n        )\n\n    # Update fields\n    if request.title is not None:\n        media.title = request.title\n    if request.description is not None:\n        media.description = request.description\n    if request.tags is not None:\n        media.tags = request.tags\n    if request.is_favorite is not None:\n        media.is_favorite = request.is_favorite\n\n    db.commit()\n    db.refresh(media)\n\n    return MediaResponse.model_validate(media)\n\n\n@router.delete(\"/{media_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_media(\n    media_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Soft delete a media item.\n\n    The media is not permanently deleted, just marked as deleted\n    and can be restored later.\n    \"\"\"\n    media = db.query(Media).filter(\n        and_(\n            Media.id == media_id,\n            Media.user_id == current_user.id,\n            Media.deleted_at.is_(None)\n        )\n    ).first()\n\n    if not media:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Media not found\"\n        )\n\n    # Soft delete\n    media.soft_delete()\n    db.commit()\n\n    return None\n\n\n@router.post(\"/{media_id}/restore\", response_model=MediaResponse)\nasync def restore_media(\n    media_id: UUID,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Restore a soft-deleted media item.\n\n    Brings back a media item that was previously deleted.\n    \"\"\"\n    media = db.query(Media).filter(\n        and_(\n            Media.id == media_id,\n            Media.user_id == current_user.id,\n            Media.deleted_at.isnot(None)\n        )\n    ).first()\n\n    if not media:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Deleted media not found\"\n        )\n\n    # Restore\n    media.restore()\n    db.commit()\n    db.refresh(media)\n\n    return MediaResponse.model_validate(media)\n"
    },
    "created_at": "2026-02-17T01:20:05.065059+00:00",
    "updated_at": "2026-02-17T01:20:05.065059+00:00",
    "deleted_at": null,
    "source_type": "import",
    "source_id": "file:media.py"
  }
}