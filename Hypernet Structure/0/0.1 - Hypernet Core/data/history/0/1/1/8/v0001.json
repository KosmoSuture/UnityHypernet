{
  "version": 1,
  "content_hash": "0e079fca2221a892",
  "snapshot_at": "2026-02-17T01:21:58.340080+00:00",
  "node": {
    "address": "0.1.1.8",
    "type_address": null,
    "data": {
      "name": "api.py",
      "type": "file",
      "extension": ".py",
      "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\api.py",
      "size": 21248,
      "content": "\"\"\"\nHypernet MVP API\nFastAPI backend for VR demo\nEndpoints: Photos, Search, Timeline, AI Query, People, Links\n\"\"\"\n\nfrom fastapi import FastAPI, HTTPException, Query, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import FileResponse\nfrom typing import Optional, List\nfrom datetime import datetime, timedelta\nimport sqlite3\nfrom pathlib import Path\nimport json\nimport os\n\nfrom mvp_models import (\n    Photo, Person, Event, Link, SearchRequest, SearchResult,\n    TimelineRequest, AIQueryRequest, AIQueryResponse,\n    ObjectType, PhotoWithLinks\n)\n\n# ============================================================================\n# APP INITIALIZATION\n# ============================================================================\n\napp = FastAPI(\n    title=\"Hypernet API\",\n    description=\"Personal data operating system API\",\n    version=\"0.1.0\"\n)\n\n# CORS for development (VR app running locally)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # In production, restrict this\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Database path\nDB_PATH = \"hypernet.db\"\n\n\n# ============================================================================\n# DATABASE CONNECTION\n# ============================================================================\n\ndef get_db():\n    \"\"\"Get database connection\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    try:\n        yield conn\n    finally:\n        conn.close()\n\n\n# ============================================================================\n# UTILITY FUNCTIONS\n# ============================================================================\n\ndef row_to_dict(row) -> dict:\n    \"\"\"Convert SQLite row to dictionary\"\"\"\n    return dict(row) if row else None\n\n\ndef rows_to_list(rows) -> list:\n    \"\"\"Convert SQLite rows to list of dictionaries\"\"\"\n    return [dict(row) for row in rows]\n\n\n# ============================================================================\n# HEALTH CHECK\n# ============================================================================\n\n@app.get(\"/\")\ndef root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"service\": \"Hypernet API\",\n        \"version\": \"0.1.0\",\n        \"endpoints\": {\n            \"photos\": \"/photos\",\n            \"search\": \"/search\",\n            \"timeline\": \"/timeline\",\n            \"ai\": \"/ai/query\",\n            \"people\": \"/people\",\n            \"links\": \"/links/{address}\"\n        }\n    }\n\n\n@app.get(\"/health\")\ndef health_check(conn: sqlite3.Connection = Depends(get_db)):\n    \"\"\"Detailed health check with database stats\"\"\"\n    cursor = conn.cursor()\n\n    # Get counts\n    cursor.execute(\"SELECT COUNT(*) as count FROM objects\")\n    total_objects = cursor.fetchone()['count']\n\n    cursor.execute(\"SELECT COUNT(*) as count FROM photos\")\n    total_photos = cursor.fetchone()['count']\n\n    cursor.execute(\"SELECT COUNT(*) as count FROM links\")\n    total_links = cursor.fetchone()['count']\n\n    return {\n        \"status\": \"healthy\",\n        \"database\": \"connected\",\n        \"stats\": {\n            \"total_objects\": total_objects,\n            \"total_photos\": total_photos,\n            \"total_links\": total_links\n        }\n    }\n\n\n# ============================================================================\n# PHOTO ENDPOINTS\n# ============================================================================\n\n@app.get(\"/photos\")\ndef get_photos(\n    owner: str = Query(\"1.1\", description=\"Owner Hypernet Address\"),\n    limit: int = Query(50, le=1000, description=\"Max results\"),\n    offset: int = Query(0, ge=0, description=\"Pagination offset\"),\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Get photos for an owner with optional date filtering\"\"\"\n\n    cursor = conn.cursor()\n\n    query = \"\"\"\n        SELECT\n            o.hypernet_address,\n            o.title,\n            o.description,\n            o.file_path,\n            o.created_at,\n            o.original_date,\n            p.width,\n            p.height,\n            p.taken_at,\n            p.latitude,\n            p.longitude,\n            p.location_name,\n            p.camera_make,\n            p.camera_model,\n            p.thumbnail_large,\n            p.ai_caption,\n            p.ai_tags\n        FROM objects o\n        JOIN photos p ON o.id = p.object_id\n        WHERE o.owner_address = ?\n          AND o.status = 'active'\n    \"\"\"\n\n    params = [owner]\n\n    if start_date:\n        query += \" AND p.taken_at >= ?\"\n        params.append(start_date)\n\n    if end_date:\n        query += \" AND p.taken_at <= ?\"\n        params.append(end_date)\n\n    query += \" ORDER BY p.taken_at DESC LIMIT ? OFFSET ?\"\n    params.extend([limit, offset])\n\n    cursor.execute(query, params)\n    photos = rows_to_list(cursor.fetchall())\n\n    # Parse JSON fields\n    for photo in photos:\n        if photo.get('ai_tags'):\n            photo['ai_tags'] = json.loads(photo['ai_tags'])\n\n    return {\n        \"count\": len(photos),\n        \"photos\": photos,\n        \"pagination\": {\n            \"limit\": limit,\n            \"offset\": offset,\n            \"next_offset\": offset + limit if len(photos) == limit else None\n        }\n    }\n\n\n@app.get(\"/photos/{address}\")\ndef get_photo(\n    address: str,\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Get a single photo with full details and links\"\"\"\n\n    cursor = conn.cursor()\n\n    # Get photo\n    cursor.execute(\"\"\"\n        SELECT\n            o.*,\n            p.width, p.height, p.orientation,\n            p.camera_make, p.camera_model, p.lens_model,\n            p.iso, p.aperture, p.shutter_speed, p.focal_length, p.flash,\n            p.latitude, p.longitude, p.altitude, p.location_name,\n            p.taken_at, p.thumbnail_small, p.thumbnail_medium, p.thumbnail_large,\n            p.ai_caption, p.ai_tags, p.ai_detected_faces\n        FROM objects o\n        JOIN photos p ON o.id = p.object_id\n        WHERE o.hypernet_address = ?\n    \"\"\", (address,))\n\n    photo = row_to_dict(cursor.fetchone())\n\n    if not photo:\n        raise HTTPException(status_code=404, detail=\"Photo not found\")\n\n    # Parse JSON fields\n    if photo.get('metadata'):\n        photo['metadata'] = json.loads(photo['metadata'])\n    if photo.get('ai_tags'):\n        photo['ai_tags'] = json.loads(photo['ai_tags'])\n    if photo.get('ai_detected_faces'):\n        photo['ai_detected_faces'] = json.loads(photo['ai_detected_faces'])\n\n    # Get people in photo\n    cursor.execute(\"\"\"\n        SELECT p.*, o.title\n        FROM links l\n        JOIN people p ON l.target_address = p.hypernet_address\n        JOIN objects o ON p.object_id = o.id\n        WHERE l.source_address = ?\n          AND l.link_type = 'depicts'\n          AND l.status = 'active'\n    \"\"\", (address,))\n\n    people = rows_to_list(cursor.fetchall())\n\n    # Get location\n    cursor.execute(\"\"\"\n        SELECT loc.*, o.title\n        FROM links l\n        JOIN locations loc ON l.target_address = loc.hypernet_address\n        JOIN objects o ON loc.object_id = o.id\n        WHERE l.source_address = ?\n          AND l.link_type = 'located_at'\n          AND l.status = 'active'\n    \"\"\", (address,))\n\n    location = row_to_dict(cursor.fetchone())\n\n    # Get events\n    cursor.execute(\"\"\"\n        SELECT e.*, o.title\n        FROM links l\n        JOIN events e ON l.target_address = e.hypernet_address\n        JOIN objects o ON e.object_id = o.id\n        WHERE l.source_address = ?\n          AND l.link_type = 'related_to'\n          AND l.status = 'active'\n    \"\"\", (address,))\n\n    events = rows_to_list(cursor.fetchall())\n\n    return {\n        \"photo\": photo,\n        \"people\": people,\n        \"location\": location,\n        \"events\": events\n    }\n\n\n@app.get(\"/photos/{address}/file\")\ndef get_photo_file(\n    address: str,\n    size: str = Query(\"original\", regex=\"^(original|large|medium|small)$\"),\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Serve photo file (for VR to display)\"\"\"\n\n    cursor = conn.cursor()\n\n    if size == \"original\":\n        cursor.execute(\"SELECT file_path FROM objects WHERE hypernet_address = ?\", (address,))\n    else:\n        cursor.execute(f\"SELECT thumbnail_{size} as file_path FROM photos WHERE hypernet_address = ?\", (address,))\n\n    result = cursor.fetchone()\n\n    if not result or not result['file_path']:\n        raise HTTPException(status_code=404, detail=\"Photo file not found\")\n\n    file_path = result['file_path']\n\n    if not os.path.exists(file_path):\n        raise HTTPException(status_code=404, detail=\"Photo file not found on disk\")\n\n    return FileResponse(file_path)\n\n\n# ============================================================================\n# SEARCH ENDPOINTS\n# ============================================================================\n\n@app.post(\"/search\")\ndef search(\n    request: SearchRequest,\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Full-text search across all objects\"\"\"\n\n    cursor = conn.cursor()\n\n    # Build query\n    query = \"\"\"\n        SELECT\n            o.hypernet_address,\n            o.object_type,\n            o.title,\n            o.description,\n            o.original_date,\n            o.file_path,\n            CASE\n                WHEN o.object_type = 'photo' THEN p.thumbnail_large\n                ELSE NULL\n            END as thumbnail\n        FROM objects_fts fts\n        JOIN objects o ON fts.rowid = o.id\n        LEFT JOIN photos p ON o.id = p.object_id\n        WHERE objects_fts MATCH ?\n    \"\"\"\n\n    params = [request.query]\n\n    if request.owner_address:\n        query += \" AND o.owner_address = ?\"\n        params.append(request.owner_address)\n\n    if request.object_types:\n        placeholders = ','.join(['?'] * len(request.object_types))\n        query += f\" AND o.object_type IN ({placeholders})\"\n        params.extend([ot.value for ot in request.object_types])\n\n    if request.start_date:\n        query += \" AND o.original_date >= ?\"\n        params.append(request.start_date.isoformat())\n\n    if request.end_date:\n        query += \" AND o.original_date <= ?\"\n        params.append(request.end_date.isoformat())\n\n    query += \" AND o.status = 'active'\"\n    query += \" ORDER BY rank LIMIT ? OFFSET ?\"\n    params.extend([request.limit, request.offset])\n\n    cursor.execute(query, params)\n    results = rows_to_list(cursor.fetchall())\n\n    return {\n        \"query\": request.query,\n        \"count\": len(results),\n        \"results\": results\n    }\n\n\n# ============================================================================\n# TIMELINE ENDPOINTS\n# ============================================================================\n\n@app.post(\"/timeline\")\ndef get_timeline(\n    request: TimelineRequest,\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Get timeline of objects sorted by date\"\"\"\n\n    cursor = conn.cursor()\n\n    query = \"\"\"\n        SELECT\n            o.hypernet_address,\n            o.object_type,\n            o.title,\n            o.description,\n            o.original_date,\n            o.file_path,\n            CASE\n                WHEN o.object_type = 'photo' THEN p.thumbnail_large\n                WHEN o.object_type = 'person' THEN pe.profile_photo_address\n                ELSE NULL\n            END as thumbnail\n        FROM objects o\n        LEFT JOIN photos p ON o.object_type = 'photo' AND o.id = p.object_id\n        LEFT JOIN people pe ON o.object_type = 'person' AND o.id = pe.object_id\n        WHERE o.owner_address = ?\n          AND o.status = 'active'\n          AND o.original_date IS NOT NULL\n    \"\"\"\n\n    params = [request.owner_address]\n\n    if request.start_date:\n        query += \" AND o.original_date >= ?\"\n        params.append(request.start_date.isoformat())\n\n    if request.end_date:\n        query += \" AND o.original_date <= ?\"\n        params.append(request.end_date.isoformat())\n\n    if request.object_types:\n        placeholders = ','.join(['?'] * len(request.object_types))\n        query += f\" AND o.object_type IN ({placeholders})\"\n        params.extend([ot.value for ot in request.object_types])\n\n    query += \" ORDER BY o.original_date DESC LIMIT ?\"\n    params.append(request.limit)\n\n    cursor.execute(query, params)\n    items = rows_to_list(cursor.fetchall())\n\n    return {\n        \"count\": len(items),\n        \"items\": items\n    }\n\n\n# ============================================================================\n# PEOPLE ENDPOINTS\n# ============================================================================\n\n@app.get(\"/people\")\ndef get_people(\n    owner: str = Query(\"1.1\"),\n    living_only: bool = Query(False),\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Get all people for an owner\"\"\"\n\n    cursor = conn.cursor()\n\n    query = \"\"\"\n        SELECT\n            p.*,\n            o.title,\n            o.description,\n            o.created_at\n        FROM people p\n        JOIN objects o ON p.object_id = o.id\n        WHERE o.owner_address = ?\n          AND o.status = 'active'\n    \"\"\"\n\n    params = [owner]\n\n    if living_only:\n        query += \" AND p.is_living = 1\"\n\n    query += \" ORDER BY p.last_name, p.first_name\"\n\n    cursor.execute(query, params)\n    people = rows_to_list(cursor.fetchall())\n\n    return {\n        \"count\": len(people),\n        \"people\": people\n    }\n\n\n@app.get(\"/people/{address}\")\ndef get_person(\n    address: str,\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Get a single person with details\"\"\"\n\n    cursor = conn.cursor()\n\n    cursor.execute(\"\"\"\n        SELECT p.*, o.*\n        FROM people p\n        JOIN objects o ON p.object_id = o.id\n        WHERE p.hypernet_address = ?\n    \"\"\", (address,))\n\n    person = row_to_dict(cursor.fetchone())\n\n    if not person:\n        raise HTTPException(status_code=404, detail=\"Person not found\")\n\n    # Get photos they're in\n    cursor.execute(\"\"\"\n        SELECT COUNT(*) as count\n        FROM links l\n        WHERE l.target_address = ?\n          AND l.link_type = 'depicts'\n          AND l.status = 'active'\n    \"\"\", (address,))\n\n    photo_count = cursor.fetchone()['count']\n    person['photo_count'] = photo_count\n\n    return person\n\n\n# ============================================================================\n# LINK ENDPOINTS\n# ============================================================================\n\n@app.get(\"/links/{address}\")\ndef get_links(\n    address: str,\n    link_type: Optional[str] = None,\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Get all links for an object\"\"\"\n\n    cursor = conn.cursor()\n\n    query = \"\"\"\n        SELECT\n            l.hypernet_address as link_address,\n            l.source_address,\n            l.target_address,\n            l.link_type,\n            l.strength,\n            l.context,\n            os.title as source_title,\n            os.object_type as source_type,\n            ot.title as target_title,\n            ot.object_type as target_type\n        FROM links l\n        JOIN objects os ON l.source_address = os.hypernet_address\n        JOIN objects ot ON l.target_address = ot.hypernet_address\n        WHERE (l.source_address = ? OR l.target_address = ?)\n          AND l.status = 'active'\n    \"\"\"\n\n    params = [address, address]\n\n    if link_type:\n        query += \" AND l.link_type = ?\"\n        params.append(link_type)\n\n    cursor.execute(query, params)\n    links = rows_to_list(cursor.fetchall())\n\n    return {\n        \"count\": len(links),\n        \"links\": links\n    }\n\n\n# ============================================================================\n# AI ENDPOINTS\n# ============================================================================\n\n@app.post(\"/ai/query\")\nasync def ai_query(\n    request: AIQueryRequest,\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Natural language query with AI\"\"\"\n\n    import time\n    start_time = time.time()\n\n    # Simple keyword extraction for demo\n    # In production, use proper NLP or LLM\n    keywords = request.query.lower().split()\n\n    # Search for relevant objects\n    cursor = conn.cursor()\n\n    # Try full-text search first\n    cursor.execute(\"\"\"\n        SELECT\n            o.hypernet_address,\n            o.object_type,\n            o.title,\n            o.description,\n            o.original_date,\n            CASE\n                WHEN o.object_type = 'photo' THEN p.thumbnail_large\n                ELSE NULL\n            END as thumbnail\n        FROM objects_fts fts\n        JOIN objects o ON fts.rowid = o.id\n        LEFT JOIN photos p ON o.id = p.object_id\n        WHERE objects_fts MATCH ?\n          AND o.owner_address = ?\n          AND o.status = 'active'\n        ORDER BY rank\n        LIMIT ?\n    \"\"\", (request.query, request.owner_address, request.max_results))\n\n    results = rows_to_list(cursor.fetchall())\n\n    # Generate simple answer\n    if results:\n        answer = f\"I found {len(results)} items related to '{request.query}'.\"\n\n        # Add context based on object types\n        types = {}\n        for r in results:\n            types[r['object_type']] = types.get(r['object_type'], 0) + 1\n\n        type_summary = \", \".join([f\"{count} {otype}(s)\" for otype, count in types.items()])\n        answer += f\" Including: {type_summary}.\"\n    else:\n        answer = f\"I couldn't find anything matching '{request.query}'. Try rephrasing your query.\"\n\n    execution_time = (time.time() - start_time) * 1000  # Convert to ms\n\n    return AIQueryResponse(\n        answer=answer,\n        sources=[SearchResult(**r, relevance_score=1.0) for r in results],\n        query_interpretation=request.query,\n        execution_time_ms=execution_time\n    )\n\n\n# ============================================================================\n# STATS ENDPOINTS (for demo)\n# ============================================================================\n\n@app.get(\"/stats/{owner}\")\ndef get_stats(\n    owner: str = \"1.1\",\n    conn: sqlite3.Connection = Depends(get_db)\n):\n    \"\"\"Get statistics for demo dashboard\"\"\"\n\n    cursor = conn.cursor()\n\n    # Total objects\n    cursor.execute(\"SELECT COUNT(*) as count FROM objects WHERE owner_address = ? AND status = 'active'\", (owner,))\n    total_objects = cursor.fetchone()['count']\n\n    # Photos\n    cursor.execute(\"\"\"\n        SELECT COUNT(*) as count\n        FROM objects o\n        JOIN photos p ON o.id = p.object_id\n        WHERE o.owner_address = ? AND o.status = 'active'\n    \"\"\", (owner,))\n    total_photos = cursor.fetchone()['count']\n\n    # People\n    cursor.execute(\"\"\"\n        SELECT COUNT(*) as count\n        FROM objects o\n        JOIN people p ON o.id = p.object_id\n        WHERE o.owner_address = ? AND o.status = 'active'\n    \"\"\", (owner,))\n    total_people = cursor.fetchone()['count']\n\n    # Links\n    cursor.execute(\"\"\"\n        SELECT COUNT(*) as count\n        FROM links l\n        JOIN objects o ON l.source_address = o.hypernet_address\n        WHERE o.owner_address = ? AND l.status = 'active'\n    \"\"\", (owner,))\n    total_links = cursor.fetchone()['count']\n\n    # Date range of photos\n    cursor.execute(\"\"\"\n        SELECT MIN(taken_at) as earliest, MAX(taken_at) as latest\n        FROM photos p\n        JOIN objects o ON p.object_id = o.id\n        WHERE o.owner_address = ? AND o.status = 'active'\n    \"\"\", (owner,))\n    date_range = cursor.fetchone()\n\n    return {\n        \"owner\": owner,\n        \"total_objects\": total_objects,\n        \"total_photos\": total_photos,\n        \"total_people\": total_people,\n        \"total_links\": total_links,\n        \"photo_date_range\": {\n            \"earliest\": date_range['earliest'],\n            \"latest\": date_range['latest']\n        }\n    }\n\n\n# ============================================================================\n# RUN SERVER\n# ============================================================================\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    print(\"=\" * 80)\n    print(\"HYPERNET API\")\n    print(\"=\" * 80)\n    print()\n    print(\"Starting server...\")\n    print(\"API Documentation: http://localhost:8000/docs\")\n    print(\"Health Check: http://localhost:8000/health\")\n    print()\n    print(\"Endpoints:\")\n    print(\"  GET  /photos              - List photos\")\n    print(\"  GET  /photos/{address}    - Get photo details\")\n    print(\"  POST /search              - Full-text search\")\n    print(\"  POST /timeline            - Get timeline\")\n    print(\"  GET  /people              - List people\")\n    print(\"  POST /ai/query            - AI natural language query\")\n    print(\"  GET  /stats/{owner}       - Get statistics\")\n    print()\n    print(\"Press Ctrl+C to stop\")\n    print(\"=\" * 80)\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000, log_level=\"info\")\n"
    },
    "created_at": "2026-02-17T01:20:04.933538+00:00",
    "updated_at": "2026-02-17T01:20:04.933538+00:00",
    "deleted_at": null,
    "source_type": "import",
    "source_id": "file:api.py"
  }
}