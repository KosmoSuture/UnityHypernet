{
  "version": 1,
  "content_hash": "d707e4ba82500abd",
  "snapshot_at": "2026-02-17T01:21:59.110710+00:00",
  "node": {
    "address": "0.1.1.11",
    "type_address": null,
    "data": {
      "name": "mvp_models.py",
      "type": "file",
      "extension": ".py",
      "path": "C:\\Hypernet\\Hypernet Structure\\0\\0.1 - Hypernet Core\\0.1.1 - Core System\\mvp_models.py",
      "size": 16988,
      "content": "\"\"\"\nHypernet MVP Data Models\nPython models for the minimal viable database schema\nUsing Pydantic for validation and FastAPI integration\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional, List, Dict, Any\nfrom enum import Enum\nfrom pydantic import BaseModel, Field, field_validator\nimport json\n\n\n# ============================================================================\n# ENUMS\n# ============================================================================\n\nclass PrivacyLevel(str, Enum):\n    \"\"\"Privacy levels for objects\"\"\"\n    PRIVATE = \"private\"\n    FAMILY = \"family\"\n    FRIENDS = \"friends\"\n    PROFESSIONAL = \"professional\"\n    PUBLIC = \"public\"\n    AI_ACCESS = \"ai_access\"\n    LEGACY = \"legacy\"\n\n\nclass ObjectStatus(str, Enum):\n    \"\"\"Status of objects\"\"\"\n    ACTIVE = \"active\"\n    ARCHIVED = \"archived\"\n    DELETED = \"deleted\"\n\n\nclass ObjectType(str, Enum):\n    \"\"\"Types of objects in Hypernet\"\"\"\n    PHOTO = \"photo\"\n    EMAIL = \"email\"\n    PERSON = \"person\"\n    EVENT = \"event\"\n    LOCATION = \"location\"\n    DOCUMENT = \"document\"\n    NOTE = \"note\"\n    TASK = \"task\"\n\n\nclass LinkType(str, Enum):\n    \"\"\"Types of relationships between objects\"\"\"\n    DEPICTS = \"depicts\"  # Photo depicts a person\n    MENTIONS = \"mentions\"  # Email mentions a person\n    LOCATED_AT = \"located_at\"  # Photo taken at location\n    RELATED_TO = \"related_to\"  # Generic relationship\n    PARENT_OF = \"parent_of\"  # Person is parent of person\n    CHILD_OF = \"child_of\"  # Person is child of person\n    SPOUSE_OF = \"spouse_of\"  # Person is spouse of person\n    OCCURRED_AT = \"occurred_at\"  # Event occurred at location\n    ATTENDED_BY = \"attended_by\"  # Event attended by person\n    ATTACHED_TO = \"attached_to\"  # Document attached to email\n\n\n# ============================================================================\n# BASE MODELS\n# ============================================================================\n\nclass HypernetObject(BaseModel):\n    \"\"\"Base model for all Hypernet objects\"\"\"\n    id: Optional[int] = None\n    hypernet_address: str\n    object_type: ObjectType\n    owner_address: str\n    status: ObjectStatus = ObjectStatus.ACTIVE\n\n    title: Optional[str] = None\n    description: Optional[str] = None\n    privacy_level: PrivacyLevel = PrivacyLevel.PRIVATE\n\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    original_date: Optional[datetime] = None\n\n    file_path: Optional[str] = None\n    file_size: Optional[int] = None\n    mime_type: Optional[str] = None\n\n    metadata: Optional[Dict[str, Any]] = None\n    search_text: Optional[str] = None\n\n    class Config:\n        use_enum_values = True\n        json_encoders = {\n            datetime: lambda v: v.isoformat()\n        }\n\n    def to_db_dict(self) -> dict:\n        \"\"\"Convert to dictionary for database insertion\"\"\"\n        data = self.model_dump()\n        # Convert datetime to ISO string\n        if data.get('created_at'):\n            data['created_at'] = data['created_at'].isoformat()\n        if data.get('updated_at'):\n            data['updated_at'] = data['updated_at'].isoformat()\n        if data.get('original_date'):\n            data['original_date'] = data['original_date'].isoformat()\n        # Convert metadata dict to JSON string\n        if data.get('metadata'):\n            data['metadata'] = json.dumps(data['metadata'])\n        return data\n\n\nclass Link(BaseModel):\n    \"\"\"Link between two Hypernet objects\"\"\"\n    id: Optional[int] = None\n    hypernet_address: str\n\n    source_address: str\n    target_address: str\n    link_type: LinkType\n\n    strength: float = Field(default=1.0, ge=0.0, le=1.0)\n    bidirectional: bool = False\n\n    context: Optional[str] = None\n    created_by: str = \"system\"\n\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    status: ObjectStatus = ObjectStatus.ACTIVE\n    metadata: Optional[Dict[str, Any]] = None\n\n    class Config:\n        use_enum_values = True\n\n\n# ============================================================================\n# SPECIFIC OBJECT MODELS\n# ============================================================================\n\nclass Photo(BaseModel):\n    \"\"\"Photo object with EXIF metadata\"\"\"\n    id: Optional[int] = None\n    object_id: Optional[int] = None\n    hypernet_address: str\n\n    # Dimensions\n    width: Optional[int] = None\n    height: Optional[int] = None\n    orientation: Optional[int] = None\n\n    # Camera info\n    camera_make: Optional[str] = None\n    camera_model: Optional[str] = None\n    lens_model: Optional[str] = None\n\n    # Settings\n    iso: Optional[int] = None\n    aperture: Optional[float] = None\n    shutter_speed: Optional[str] = None\n    focal_length: Optional[float] = None\n    flash: Optional[bool] = None\n\n    # Location\n    latitude: Optional[float] = None\n    longitude: Optional[float] = None\n    altitude: Optional[float] = None\n    location_name: Optional[str] = None\n\n    # When taken\n    taken_at: Optional[datetime] = None\n\n    # Thumbnails\n    thumbnail_small: Optional[str] = None\n    thumbnail_medium: Optional[str] = None\n    thumbnail_large: Optional[str] = None\n\n    # AI metadata\n    ai_caption: Optional[str] = None\n    ai_tags: Optional[List[str]] = None\n    ai_detected_faces: Optional[List[Dict[str, Any]]] = None\n\n    # Duplicate detection\n    perceptual_hash: Optional[str] = None\n\n    def to_db_dict(self) -> dict:\n        \"\"\"Convert to dictionary for database insertion\"\"\"\n        data = self.model_dump()\n        if data.get('taken_at'):\n            data['taken_at'] = data['taken_at'].isoformat()\n        if data.get('ai_tags'):\n            data['ai_tags'] = json.dumps(data['ai_tags'])\n        if data.get('ai_detected_faces'):\n            data['ai_detected_faces'] = json.dumps(data['ai_detected_faces'])\n        return data\n\n\nclass Person(BaseModel):\n    \"\"\"Person (living or deceased)\"\"\"\n    id: Optional[int] = None\n    object_id: Optional[int] = None\n    hypernet_address: str\n\n    # Name\n    first_name: Optional[str] = None\n    middle_name: Optional[str] = None\n    last_name: Optional[str] = None\n    preferred_name: Optional[str] = None\n    suffix: Optional[str] = None\n\n    # Dates\n    birth_date: Optional[datetime] = None\n    death_date: Optional[datetime] = None\n\n    # Contact\n    email: Optional[str] = None\n    phone: Optional[str] = None\n\n    # Relationships\n    relationship_to_owner: Optional[str] = None\n\n    # Profile\n    profile_photo_address: Optional[str] = None\n    bio: Optional[str] = None\n\n    # Status\n    is_living: bool = True\n    is_hypernet_user: bool = False\n\n    @property\n    def full_name(self) -> str:\n        \"\"\"Get full name\"\"\"\n        parts = [self.first_name, self.middle_name, self.last_name, self.suffix]\n        return \" \".join(p for p in parts if p)\n\n    @property\n    def display_name(self) -> str:\n        \"\"\"Get display name (preferred or full)\"\"\"\n        if self.preferred_name:\n            return self.preferred_name\n        return self.full_name\n\n    def to_db_dict(self) -> dict:\n        \"\"\"Convert to dictionary for database insertion\"\"\"\n        data = self.model_dump()\n        if data.get('birth_date'):\n            data['birth_date'] = data['birth_date'].isoformat()\n        if data.get('death_date'):\n            data['death_date'] = data['death_date'].isoformat()\n        return data\n\n\nclass Event(BaseModel):\n    \"\"\"Event (birthday, holiday, trip, meeting, etc.)\"\"\"\n    id: Optional[int] = None\n    object_id: Optional[int] = None\n    hypernet_address: str\n\n    event_type: str\n\n    # When\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    all_day: bool = False\n\n    # Where\n    location_name: Optional[str] = None\n    latitude: Optional[float] = None\n    longitude: Optional[float] = None\n\n    # Recurrence\n    recurrence_rule: Optional[str] = None\n\n    # Attendees\n    attendees: Optional[List[str]] = None  # List of person HAs\n\n    def to_db_dict(self) -> dict:\n        \"\"\"Convert to dictionary for database insertion\"\"\"\n        data = self.model_dump()\n        if data.get('start_date'):\n            data['start_date'] = data['start_date'].isoformat()\n        if data.get('end_date'):\n            data['end_date'] = data['end_date'].isoformat()\n        if data.get('attendees'):\n            data['attendees'] = json.dumps(data['attendees'])\n        return data\n\n\nclass Email(BaseModel):\n    \"\"\"Email message\"\"\"\n    id: Optional[int] = None\n    object_id: Optional[int] = None\n    hypernet_address: str\n\n    # Headers\n    message_id: str\n    subject: Optional[str] = None\n    from_address: str\n    from_name: Optional[str] = None\n    to_addresses: List[str]\n    cc_addresses: Optional[List[str]] = None\n    bcc_addresses: Optional[List[str]] = None\n\n    # Content\n    body_plain: Optional[str] = None\n    body_html: Optional[str] = None\n\n    # Metadata\n    sent_at: datetime\n    received_at: Optional[datetime] = None\n\n    # Threading\n    in_reply_to: Optional[str] = None\n    thread_id: Optional[str] = None\n\n    # Flags\n    is_read: bool = False\n    is_starred: bool = False\n    is_archived: bool = False\n\n    # Attachments\n    attachments: Optional[List[str]] = None\n\n    def to_db_dict(self) -> dict:\n        \"\"\"Convert to dictionary for database insertion\"\"\"\n        data = self.model_dump()\n        if data.get('sent_at'):\n            data['sent_at'] = data['sent_at'].isoformat()\n        if data.get('received_at'):\n            data['received_at'] = data['received_at'].isoformat()\n        if data.get('to_addresses'):\n            data['to_addresses'] = json.dumps(data['to_addresses'])\n        if data.get('cc_addresses'):\n            data['cc_addresses'] = json.dumps(data['cc_addresses'])\n        if data.get('bcc_addresses'):\n            data['bcc_addresses'] = json.dumps(data['bcc_addresses'])\n        if data.get('attachments'):\n            data['attachments'] = json.dumps(data['attachments'])\n        return data\n\n\nclass Location(BaseModel):\n    \"\"\"Physical location\"\"\"\n    id: Optional[int] = None\n    object_id: Optional[int] = None\n    hypernet_address: str\n\n    # Details\n    name: Optional[str] = None\n    address: Optional[str] = None\n    city: Optional[str] = None\n    state: Optional[str] = None\n    country: Optional[str] = None\n    postal_code: Optional[str] = None\n\n    # Coordinates\n    latitude: float\n    longitude: float\n\n    # Type\n    location_type: Optional[str] = None\n\n    # Visits\n    first_visit_date: Optional[datetime] = None\n    last_visit_date: Optional[datetime] = None\n    visit_count: int = 0\n\n    def to_db_dict(self) -> dict:\n        \"\"\"Convert to dictionary for database insertion\"\"\"\n        data = self.model_dump()\n        if data.get('first_visit_date'):\n            data['first_visit_date'] = data['first_visit_date'].isoformat()\n        if data.get('last_visit_date'):\n            data['last_visit_date'] = data['last_visit_date'].isoformat()\n        return data\n\n\n# ============================================================================\n# API REQUEST/RESPONSE MODELS\n# ============================================================================\n\nclass PhotoWithLinks(BaseModel):\n    \"\"\"Photo with its associated links\"\"\"\n    photo: Photo\n    object: HypernetObject\n    people: List[Person] = []\n    location: Optional[Location] = None\n    events: List[Event] = []\n\n\nclass SearchRequest(BaseModel):\n    \"\"\"Search request\"\"\"\n    query: str\n    object_types: Optional[List[ObjectType]] = None\n    start_date: Optional[datetime] = None\n    end_date: Optional[datetime] = None\n    owner_address: Optional[str] = None\n    limit: int = Field(default=50, le=1000)\n    offset: int = 0\n\n\nclass SearchResult(BaseModel):\n    \"\"\"Search result\"\"\"\n    hypernet_address: str\n    object_type: ObjectType\n    title: Optional[str]\n    description: Optional[str]\n    thumbnail: Optional[str] = None\n    relevance_score: float\n    original_date: Optional[datetime] = None\n\n\nclass TimelineRequest(BaseModel):\n    \"\"\"Request for timeline view\"\"\"\n    owner_address: str\n    start_date: Optional[datetime] = None\n    end_date: Optional[datetime] = None\n    object_types: Optional[List[ObjectType]] = None\n    limit: int = Field(default=100, le=1000)\n\n\nclass AIQueryRequest(BaseModel):\n    \"\"\"Request for AI query\"\"\"\n    query: str\n    owner_address: str\n    include_types: Optional[List[ObjectType]] = None\n    max_results: int = Field(default=10, le=100)\n\n\nclass AIQueryResponse(BaseModel):\n    \"\"\"Response from AI query\"\"\"\n    answer: str\n    sources: List[SearchResult]\n    query_interpretation: str\n    execution_time_ms: float\n\n\n# ============================================================================\n# HYPERNET ADDRESS UTILITIES\n# ============================================================================\n\nclass HypernetAddress:\n    \"\"\"Utility class for Hypernet Address manipulation\"\"\"\n\n    @staticmethod\n    def generate(category: int, subcategory: int, type_: int,\n                 subtype: int, instance: int) -> str:\n        \"\"\"Generate a Hypernet Address\"\"\"\n        return f\"{category}.{subcategory}.{type_}.{subtype}.{instance:05d}\"\n\n    @staticmethod\n    def parse(address: str) -> Dict[str, int]:\n        \"\"\"Parse a Hypernet Address into components\"\"\"\n        parts = address.split('.')\n        if len(parts) == 2:\n            # Short form like \"1.1\" (person)\n            return {\n                'category': int(parts[0]),\n                'subcategory': int(parts[1]),\n                'type': None,\n                'subtype': None,\n                'instance': None\n            }\n        elif len(parts) == 5:\n            # Full form like \"1.1.8.0.00001\"\n            return {\n                'category': int(parts[0]),\n                'subcategory': int(parts[1]),\n                'type': int(parts[2]),\n                'subtype': int(parts[3]),\n                'instance': int(parts[4])\n            }\n        else:\n            raise ValueError(f\"Invalid Hypernet Address: {address}\")\n\n    @staticmethod\n    def is_valid(address: str) -> bool:\n        \"\"\"Check if address is valid\"\"\"\n        try:\n            HypernetAddress.parse(address)\n            return True\n        except:\n            return False\n\n    @staticmethod\n    def get_next_instance(category: int, subcategory: int,\n                         type_: int, subtype: int,\n                         existing_instances: List[int]) -> int:\n        \"\"\"Get next available instance number\"\"\"\n        if not existing_instances:\n            return 1\n        return max(existing_instances) + 1\n\n\n# ============================================================================\n# EXAMPLE USAGE\n# ============================================================================\n\nif __name__ == \"__main__\":\n    # Example: Create a photo object\n    photo_obj = HypernetObject(\n        hypernet_address=\"1.1.8.0.00001\",\n        object_type=ObjectType.PHOTO,\n        owner_address=\"1.1\",\n        title=\"Family Christmas 2023\",\n        description=\"Christmas dinner at our house\",\n        privacy_level=PrivacyLevel.FAMILY,\n        original_date=datetime(2023, 12, 25, 18, 30),\n        file_path=\"/photos/2023/12/IMG_1234.jpg\",\n        file_size=2_500_000,\n        mime_type=\"image/jpeg\"\n    )\n\n    photo = Photo(\n        hypernet_address=\"1.1.8.0.00001\",\n        width=4032,\n        height=3024,\n        camera_make=\"Apple\",\n        camera_model=\"iPhone 14 Pro\",\n        taken_at=datetime(2023, 12, 25, 18, 30),\n        latitude=47.6062,\n        longitude=-122.3321,\n        location_name=\"Seattle, WA\",\n        ai_caption=\"Family gathered around dinner table with Christmas decorations\",\n        ai_tags=[\"christmas\", \"family\", \"dinner\", \"indoor\"]\n    )\n\n    # Example: Create links\n    link_to_sarah = Link(\n        hypernet_address=\"0.5.1.1.00001\",\n        source_address=\"1.1.8.0.00001\",\n        target_address=\"1.2\",\n        link_type=LinkType.DEPICTS,\n        strength=1.0,\n        context=\"Sarah is in the photo\"\n    )\n\n    link_to_event = Link(\n        hypernet_address=\"0.5.1.1.00002\",\n        source_address=\"1.1.8.0.00001\",\n        target_address=\"1.1.9.5.00012\",  # Christmas 2023 event\n        link_type=LinkType.RELATED_TO,\n        strength=1.0,\n        context=\"Photo taken during Christmas 2023 event\"\n    )\n\n    print(\"Photo object:\", photo_obj.model_dump_json(indent=2))\n    print(\"\\nPhoto details:\", photo.model_dump_json(indent=2))\n    print(\"\\nLink:\", link_to_sarah.model_dump_json(indent=2))\n"
    },
    "created_at": "2026-02-17T01:20:05.100572+00:00",
    "updated_at": "2026-02-17T01:20:05.100572+00:00",
    "deleted_at": null,
    "source_type": "import",
    "source_id": "file:mvp_models.py"
  }
}