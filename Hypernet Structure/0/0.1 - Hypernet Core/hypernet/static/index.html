<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypernet Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(10, 10, 15, 0.95);
            border-bottom: 1px solid #1a1a2e;
            display: flex;
            align-items: center;
            padding: 0 16px;
            z-index: 100;
            gap: 16px;
        }

        #header h1 {
            font-size: 16px;
            font-weight: 600;
            color: #7c7cff;
            letter-spacing: 0.5px;
        }

        #search-box {
            flex: 1;
            max-width: 400px;
            padding: 6px 12px;
            background: #12121a;
            border: 1px solid #2a2a3e;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
            outline: none;
        }
        #search-box:focus { border-color: #7c7cff; }
        #search-box::placeholder { color: #555; }

        #stats {
            font-size: 12px;
            color: #666;
            margin-left: auto;
        }

        #graph-container {
            position: absolute;
            top: 48px;
            left: 0;
            right: 320px;
            bottom: 0;
        }

        #graph-container svg {
            width: 100%;
            height: 100%;
        }

        #sidebar {
            position: fixed;
            top: 48px;
            right: 0;
            width: 320px;
            bottom: 0;
            background: rgba(12, 12, 18, 0.98);
            border-left: 1px solid #1a1a2e;
            overflow-y: auto;
            padding: 16px;
            z-index: 50;
        }

        #sidebar h2 {
            font-size: 14px;
            color: #7c7cff;
            margin-bottom: 12px;
            font-weight: 600;
        }

        #sidebar h3 {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 16px 0 8px;
        }

        .node-address {
            font-family: 'Cascadia Code', 'Fira Code', monospace;
            font-size: 18px;
            color: #fff;
            margin-bottom: 4px;
        }

        .node-label {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 16px;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 12px;
            border-bottom: 1px solid #1a1a2e;
        }
        .data-key { color: #888; }
        .data-value { color: #ccc; text-align: right; max-width: 180px; overflow: hidden; text-overflow: ellipsis; }

        .link-item {
            padding: 6px 8px;
            margin: 4px 0;
            background: #12121a;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .link-item:hover { background: #1a1a2e; }
        .link-rel { color: #7c7cff; }
        .link-target { color: #ccc; font-family: monospace; }
        .link-arrow { color: #444; margin: 0 4px; }

        .history-item {
            padding: 6px 8px;
            margin: 4px 0;
            background: #12121a;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .history-item:hover { background: #1a1a2e; }
        .history-version { color: #7c7cff; font-weight: 600; }
        .history-hash { color: #666; font-family: monospace; font-size: 10px; }
        .history-date { color: #888; }

        #empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #555;
        }
        #empty-state p { margin: 8px 0; font-size: 13px; }

        /* Category colors */
        .cat-0 { fill: #5c6bc0; }  /* System - indigo */
        .cat-1 { fill: #26a69a; }  /* People - teal */
        .cat-2 { fill: #ab47bc; }  /* AI - purple */
        .cat-3 { fill: #ef5350; }  /* Business - red */
        .cat-4 { fill: #ffa726; }  /* Knowledge - amber */

        .node-circle {
            stroke: #1a1a2e;
            stroke-width: 1.5;
            cursor: pointer;
            transition: r 0.2s;
        }
        .node-circle:hover { stroke: #fff; stroke-width: 2; }
        .node-circle.selected { stroke: #7c7cff; stroke-width: 3; }

        .node-text {
            font-size: 9px;
            fill: #888;
            pointer-events: none;
            text-anchor: middle;
        }

        .link-line {
            stroke: #1a1a2e;
            stroke-width: 0.8;
            stroke-opacity: 0.6;
        }
        .link-line.highlighted {
            stroke: #7c7cff;
            stroke-width: 1.5;
            stroke-opacity: 1;
        }

        /* Legend */
        #legend {
            position: fixed;
            bottom: 12px;
            left: 12px;
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: #666;
            z-index: 50;
        }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

        #loading {
            position: fixed;
            top: 50%;
            left: calc(50% - 160px);
            transform: translate(-50%, -50%);
            color: #7c7cff;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>HYPERNET EXPLORER</h1>
        <input id="search-box" type="text" placeholder="Enter address (e.g. 2.1) or search..." />
        <span id="stats"></span>
    </div>

    <div id="graph-container">
        <div id="loading">Loading graph...</div>
    </div>

    <div id="sidebar">
        <div id="empty-state">
            <p>Click a node to inspect it</p>
            <p>Scroll to zoom, drag to pan</p>
            <p>Search by address above</p>
        </div>
        <div id="node-detail" style="display:none;"></div>
    </div>

    <div id="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#5c6bc0;"></div> System (0.*)</div>
        <div class="legend-item"><div class="legend-dot" style="background:#26a69a;"></div> People (1.*)</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ab47bc;"></div> AI (2.*)</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ef5350;"></div> Business (3.*)</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffa726;"></div> Knowledge (4.*)</div>
    </div>

    <script>
    const API = '';  // Same origin
    const CAT_COLORS = {
        '0': '#5c6bc0',
        '1': '#26a69a',
        '2': '#ab47bc',
        '3': '#ef5350',
        '4': '#ffa726',
    };

    let simulation, svg, g, linkGroup, nodeGroup;
    let allNodes = [], allLinks = [];
    let selectedNode = null;

    // ========== Data Loading ==========

    async function loadGraph() {
        try {
            const statsResp = await fetch(`${API}/stats`);
            const stats = await statsResp.json();
            document.getElementById('stats').textContent =
                `${stats.total_nodes} nodes | ${stats.total_links} links`;

            // Load all nodes
            const nodesResp = await fetch(`${API}/query`);
            const nodesData = await nodesResp.json();

            // Build node map
            const nodeMap = new Map();
            nodesData.forEach(n => {
                nodeMap.set(n.address, {
                    id: n.address,
                    address: n.address,
                    data: n.data,
                    category: n.address.split('.')[0],
                    depth: n.address.split('.').length,
                    label: n.data.name || n.data.filename || n.data.label || n.address,
                });
            });

            // Load links for high-level nodes (depth <= 3) to avoid overwhelming the graph
            const topNodes = nodesData.filter(n => n.address.split('.').length <= 3);
            const linkSet = new Set();

            // Load links in batches
            const batchSize = 20;
            for (let i = 0; i < topNodes.length; i += batchSize) {
                const batch = topNodes.slice(i, i + batchSize);
                const promises = batch.map(n =>
                    fetch(`${API}/node/${n.address}/links?direction=all`)
                        .then(r => r.json())
                        .catch(() => [])
                );
                const results = await Promise.all(promises);
                results.flat().forEach(link => {
                    const key = `${link.from_address}->${link.to_address}:${link.relationship}`;
                    if (!linkSet.has(key) && nodeMap.has(link.from_address) && nodeMap.has(link.to_address)) {
                        linkSet.add(key);
                        allLinks.push({
                            source: link.from_address,
                            target: link.to_address,
                            relationship: link.relationship,
                            bidirectional: link.bidirectional,
                        });
                    }
                });
            }

            allNodes = Array.from(nodeMap.values());

            document.getElementById('loading').remove();
            initGraph();
        } catch (err) {
            document.getElementById('loading').textContent =
                'Could not connect to Hypernet API. Start the server with: python -m hypernet.server';
            console.error(err);
        }
    }

    // ========== Graph Rendering ==========

    function initGraph() {
        const container = document.getElementById('graph-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        svg = d3.select('#graph-container')
            .append('svg')
            .attr('width', width)
            .attr('height', height);

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on('zoom', (event) => g.attr('transform', event.transform));
        svg.call(zoom);

        g = svg.append('g');

        // Links
        linkGroup = g.append('g').attr('class', 'links');
        const linkElements = linkGroup.selectAll('line')
            .data(allLinks)
            .enter().append('line')
            .attr('class', 'link-line');

        // Nodes
        nodeGroup = g.append('g').attr('class', 'nodes');
        const nodeElements = nodeGroup.selectAll('g')
            .data(allNodes)
            .enter().append('g')
            .call(d3.drag()
                .on('start', dragStarted)
                .on('drag', dragged)
                .on('end', dragEnded));

        nodeElements.append('circle')
            .attr('class', 'node-circle')
            .attr('r', d => Math.max(4, 12 - d.depth * 2))
            .attr('fill', d => CAT_COLORS[d.category] || '#555')
            .on('click', (event, d) => selectNode(d));

        nodeElements.append('text')
            .attr('class', 'node-text')
            .attr('dy', d => Math.max(4, 12 - d.depth * 2) + 12)
            .text(d => d.depth <= 2 ? d.label : '');

        // Force simulation
        simulation = d3.forceSimulation(allNodes)
            .force('link', d3.forceLink(allLinks).id(d => d.id).distance(60))
            .force('charge', d3.forceManyBody().strength(-80))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(15))
            .on('tick', () => {
                linkElements
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                nodeElements.attr('transform', d => `translate(${d.x},${d.y})`);
            });

        // Initial zoom to fit
        setTimeout(() => {
            const bounds = g.node().getBBox();
            const dx = bounds.width, dy = bounds.height;
            const x = bounds.x + dx / 2, y = bounds.y + dy / 2;
            const scale = 0.8 / Math.max(dx / width, dy / height);
            const translate = [width / 2 - scale * x, height / 2 - scale * y];
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        }, 2000);
    }

    // ========== Drag Handlers ==========

    function dragStarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragEnded(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    // ========== Node Selection ==========

    async function selectNode(nodeData) {
        selectedNode = nodeData;

        // Highlight in graph
        d3.selectAll('.node-circle').classed('selected', false);
        d3.selectAll('.node-circle')
            .filter(d => d.id === nodeData.id)
            .classed('selected', true);

        // Highlight connected links
        d3.selectAll('.link-line').classed('highlighted', d =>
            d.source.id === nodeData.id || d.target.id === nodeData.id
        );

        // Fetch full details
        try {
            const [nodeResp, linksResp, historyResp] = await Promise.all([
                fetch(`${API}/node/${nodeData.address}`).then(r => r.json()),
                fetch(`${API}/node/${nodeData.address}/links?direction=all`).then(r => r.json()),
                fetch(`${API}/node/${nodeData.address}/history`).then(r => r.json()),
            ]);

            renderSidebar(nodeResp, linksResp, historyResp);
        } catch (err) {
            console.error('Failed to fetch node details:', err);
        }
    }

    function renderSidebar(node, links, history) {
        document.getElementById('empty-state').style.display = 'none';
        const detail = document.getElementById('node-detail');
        detail.style.display = 'block';

        let html = `
            <div class="node-address">${esc(node.address)}</div>
            <div class="node-label">${esc(node.data.name || node.data.filename || node.data.label || 'Unnamed')}</div>
        `;

        // Data fields
        if (Object.keys(node.data).length > 0) {
            html += '<h3>Data</h3>';
            for (const [key, value] of Object.entries(node.data)) {
                const display = typeof value === 'object' ? JSON.stringify(value) : String(value);
                html += `<div class="data-row"><span class="data-key">${esc(key)}</span><span class="data-value" title="${esc(display)}">${esc(display)}</span></div>`;
            }
        }

        // Metadata
        html += '<h3>Metadata</h3>';
        html += `<div class="data-row"><span class="data-key">type</span><span class="data-value">${esc(node.type_address || '—')}</span></div>`;
        html += `<div class="data-row"><span class="data-key">source</span><span class="data-value">${esc(node.source_type || '—')}</span></div>`;
        html += `<div class="data-row"><span class="data-key">created</span><span class="data-value">${formatDate(node.created_at)}</span></div>`;
        html += `<div class="data-row"><span class="data-key">updated</span><span class="data-value">${formatDate(node.updated_at)}</span></div>`;

        // Links
        if (links.length > 0) {
            html += `<h3>Links (${links.length})</h3>`;
            links.slice(0, 50).forEach(link => {
                const isOutgoing = link.from_address === node.address;
                const otherAddr = isOutgoing ? link.to_address : link.from_address;
                const arrow = link.bidirectional ? '&harr;' : (isOutgoing ? '&rarr;' : '&larr;');
                const safeAddr = esc(otherAddr).replace(/'/g, '&#39;');
                html += `<div class="link-item" onclick="navigateTo('${safeAddr}')">
                    <span class="link-rel">${esc(link.relationship)}</span>
                    <span class="link-arrow">${arrow}</span>
                    <span class="link-target">${esc(otherAddr)}</span>
                </div>`;
            });
            if (links.length > 50) {
                html += `<div style="color:#666;font-size:11px;padding:4px 8px;">... and ${links.length - 50} more</div>`;
            }
        }

        // History
        if (history.length > 0) {
            html += `<h3>Version History (${history.length})</h3>`;
            history.forEach(v => {
                html += `<div class="history-item">
                    <span class="history-version">v${esc(v.version)}</span>
                    <span class="history-hash">${esc(v.content_hash)}</span>
                    <br><span class="history-date">${formatDate(v.snapshot_at)}</span>
                </div>`;
            });
        }

        detail.innerHTML = html;
    }

    function navigateTo(address) {
        const node = allNodes.find(n => n.id === address);
        if (node) {
            selectNode(node);
            // Pan to node
            const transform = d3.zoomTransform(svg.node());
            svg.transition().duration(500).call(
                d3.zoom().transform,
                d3.zoomIdentity
                    .translate(
                        document.getElementById('graph-container').clientWidth / 2,
                        document.getElementById('graph-container').clientHeight / 2
                    )
                    .scale(transform.k)
                    .translate(-node.x, -node.y)
            );
        } else {
            // Node not in current view — try to fetch it
            document.getElementById('search-box').value = address;
            searchAddress(address);
        }
    }

    // ========== Search ==========

    async function searchAddress(query) {
        query = query.trim();
        if (!query) return;

        // Try exact address match
        const node = allNodes.find(n => n.id === query);
        if (node) {
            selectNode(node);
            return;
        }

        // Try prefix search
        const matches = allNodes.filter(n =>
            n.id.startsWith(query) ||
            (n.label && n.label.toLowerCase().includes(query.toLowerCase()))
        );
        if (matches.length > 0) {
            selectNode(matches[0]);
        }
    }

    document.getElementById('search-box').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            searchAddress(e.target.value);
        }
    });

    // ========== Utilities ==========

    function esc(text) {
        const d = document.createElement('div');
        d.textContent = String(text || '');
        return d.innerHTML;
    }

    function formatDate(iso) {
        if (!iso) return '—';
        try {
            const d = new Date(iso);
            return d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        } catch {
            return iso;
        }
    }

    // ========== Init ==========
    loadGraph();
    </script>
</body>
</html>
