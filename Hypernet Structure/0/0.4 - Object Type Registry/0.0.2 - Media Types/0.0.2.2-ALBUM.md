# ALBUM - Media Collection Object Type

**Type ID:** `hypernet.media.album`
**Version:** 1.0
**Category:** 0.0.2 - Media Types
**Parent:** BaseObject
**Status:** Active - Core Media Type
**Created:** 2026-02-09
**Last Updated:** 2026-02-09

---

## Object Type Metadata

```yaml
type_name: "Album"
type_id: "hypernet.media.album"
version: "1.0"
parent_type: "BaseObject"
category: "0.0.2 - Media Types"
abstract: false
instantiable: true
```

---

## Purpose and Description

### What is an Album?

The Album object type represents a curated collection of media items (photos, videos, audio, documents). Albums provide organizational structure for media, enabling users to group related content by theme, event, time period, or any custom criteria. Albums are the primary organizational tool in Hypernet's media management system.

### Revolutionary Design Philosophy

Hypernet albums are flexible, intelligent, and source-agnostic:
- **Multi-Media Support** - Albums can contain photos, videos, audio, and documents
- **Smart and Manual** - Support both curated manual albums and AI-generated smart albums
- **Source Agnostic** - Combine media from Instagram, Google Photos, local uploads, and more
- **Nested Organization** - Albums can contain sub-albums for hierarchical organization
- **Collaborative** - Share albums with specific users or make them public
- **Synchronized** - Keep albums in sync with platform albums (Instagram albums, Google Photos albums)

### Core Functions

1. **Media Organization** - Group related media into logical collections
2. **Timeline Creation** - Organize media chronologically for events and trips
3. **Smart Collections** - Auto-generate albums based on criteria (date, location, tags, AI analysis)
4. **Sharing and Collaboration** - Share albums with family, friends, or publicly
5. **Export and Backup** - Download entire albums as ZIP archives
6. **Cross-Platform Unification** - Combine media from multiple sources into unified albums

### When to Use

- Creating event-based collections (wedding, vacation, birthday party)
- Organizing photos by theme (family, work, hobbies)
- Building smart collections (all photos at a location, all videos from 2024)
- Importing platform albums (Instagram albums, Google Photos albums)
- Creating shareable galleries for external viewing
- Organizing AI-generated content by project or theme

---

## Inherited Fields from BaseObject

```yaml
id: UUID
  - Globally unique album identifier
  - Generated on creation

created_at: DateTime
  - Album creation timestamp
  - Immutable

updated_at: DateTime
  - Last modification timestamp (metadata or media changes)
  - Auto-updated when media added/removed or metadata changed

deleted_at: DateTime (nullable)
  - Soft delete timestamp
  - Null for active albums
  - Albums preserved for 30 days before hard delete

user_id: UUID
  - Foreign key to User who owns this album
  - Required - all albums must have an owner
  - Immutable (use ownership transfer API for changes)

metadata: JSONB
  - Extensible metadata storage
  - See Metadata Schema section below
  - Stores platform-specific data, smart album criteria
```

---

## Required Fields

### Album Identity

```yaml
title: String(500)
  type: String
  max_length: 500
  nullable: false
  indexed: true
  description: "Album title or name"
  examples:
    - "Summer Vacation 2024"
    - "Best Photos of 2023"
    - "Work Projects"
    - "Sarah's Birthday Party"
  constraints:
    - Minimum 1 character
    - Maximum 500 characters
    - Trimmed of whitespace
  searchable: true

album_type: Enum
  type: String
  max_length: 20
  nullable: false
  indexed: true
  default: "manual"
  description: "Type of album organization"
  allowed_values:
    - "manual": User-curated album with explicit media selection
    - "smart": Auto-generated based on criteria (date, location, tags, AI)
    - "imported": Synchronized from external platform (Instagram, Google Photos)
    - "system": System-generated (All Photos, Favorites, Recently Added)
  behavior:
    manual: User explicitly adds/removes media
    smart: Media auto-added based on smart_criteria in metadata
    imported: Synced with platform album via integration
    system: Cannot be deleted, auto-maintained by system
```

---

## Optional Fields

### Album Description

```yaml
description: Text
  type: Text
  nullable: true
  max_length: 5000
  description: "Detailed description of album content and purpose"
  examples:
    - "Photos from our amazing 2-week trip through Japan"
    - "Professional headshots and portfolio images"
  searchable: true
  format: "Plain text or Markdown"

cover_media_id: UUID
  type: UUID
  nullable: true
  description: "Foreign key to Media object used as album cover"
  references: "Media.id"
  cascade: "ON DELETE SET NULL"
  constraints:
    - Media must be in this album
    - Media must not be deleted
    - Defaults to first media in album if not set
  usage: "Display as album thumbnail in UI"
```

### Organization

```yaml
parent_album_id: UUID
  type: UUID
  nullable: true
  indexed: true
  description: "Foreign key to parent Album for nested organization"
  references: "Album.id"
  cascade: "ON DELETE CASCADE"
  constraints:
    - Cannot be self-referencing
    - Cannot create circular references
    - Max depth: 5 levels
  examples:
    - "Travel 2024" contains "Japan Trip", "Europe Trip"
    - "Work" contains "Projects", "Events"

sort_order: String(50)
  type: String
  max_length: 50
  nullable: false
  default: "date_desc"
  description: "Default sort order for media in album"
  allowed_values:
    - "date_desc": Newest first (default)
    - "date_asc": Oldest first
    - "title_asc": Alphabetical by title
    - "manual": User-defined custom order
    - "added_desc": Recently added first
  usage: "Determines display order in UI and API responses"

media_count: Integer
  type: Integer
  nullable: false
  default: 0
  indexed: true
  description: "Number of media items in album (denormalized)"
  constraints:
    - Must be >= 0
    - Updated automatically when media added/removed
    - Excludes deleted media
  performance: "Cached count for fast display without JOIN"
```

### Temporal Information

```yaml
start_date: DateTime
  type: DateTime
  nullable: true
  indexed: true
  timezone: true
  description: "Start date/time for event-based albums"
  examples:
    - Vacation album: "2024-06-01T00:00:00Z"
    - Conference album: "2024-03-15T09:00:00Z"
  usage: "Filter albums by date range, display in timeline"

end_date: DateTime
  type: DateTime
  nullable: true
  timezone: true
  description: "End date/time for event-based albums"
  constraints:
    - Must be >= start_date if both provided
  examples:
    - Vacation album: "2024-06-14T23:59:59Z"
```

### Sharing and Privacy

```yaml
visibility: Enum
  type: String
  max_length: 20
  nullable: false
  default: "private"
  indexed: true
  description: "Album visibility and sharing settings"
  allowed_values:
    - "private": Only owner can view
    - "shared": Shared with specific users (see album_shares table)
    - "public": Anyone with link can view
    - "unlisted": Public but not indexed/searchable
  security:
    - private: Requires authentication as owner
    - shared: Requires authentication as owner or invited user
    - public: No authentication required
    - unlisted: No authentication required, not in public listings

share_token: String(64)
  type: String
  max_length: 64
  nullable: true
  indexed: true
  unique: true
  description: "Random token for public/unlisted album access"
  format: "64 character random alphanumeric string"
  generation: "Auto-generated when visibility set to public/unlisted"
  usage: "Access via /albums/shared/{share_token}"
  security:
    - Token is unguessable (cryptographically random)
    - Can be regenerated to revoke old link
    - Required for public/unlisted access

allow_downloads: Boolean
  type: Boolean
  nullable: false
  default: true
  description: "Whether viewers can download media from shared albums"
  applicable: "visibility = shared, public, or unlisted"
  behavior:
    true: Download buttons visible, media files accessible
    false: View-only mode, no download buttons
```

### Platform Synchronization

```yaml
source_platform: String(100)
  type: String
  max_length: 100
  nullable: true
  indexed: true
  description: "Platform where album originated (for imported albums)"
  examples:
    - "instagram"
    - "google_photos"
    - "facebook"
    - "icloud"
  applicable: "album_type = 'imported'"

source_id: String(200)
  type: String
  max_length: 200
  nullable: true
  indexed: true
  description: "External album ID from source platform"
  examples:
    - Instagram album ID
    - Google Photos album ID
  purpose: "Prevent duplicate imports, enable sync"

integration_id: UUID
  type: UUID
  nullable: true
  indexed: true
  description: "Foreign key to Integration that manages this album"
  references: "Integration.id"
  cascade: "ON DELETE SET NULL"
  purpose: "Track which integration created/syncs this album"

sync_enabled: Boolean
  type: Boolean
  nullable: false
  default: false
  description: "Whether album stays synced with platform album"
  applicable: "album_type = 'imported'"
  behavior:
    true: Periodic sync adds new media from platform
    false: Album is static snapshot
```

---

## Metadata Schema

The `metadata` JSONB field stores smart album criteria and platform-specific data:

```json
{
  "smart_criteria": {
    "media_type": ["photo", "video"],
    "tags": ["vacation", "2024"],
    "location": "Hawaii",
    "date_range": {
      "start": "2024-06-01",
      "end": "2024-06-30"
    },
    "ai_labels": ["beach", "sunset"],
    "min_quality_score": 0.8,
    "people": ["person-uuid-1", "person-uuid-2"]
  },
  "platform": {
    "instagram": {
      "album_id": "abc123",
      "album_name": "Summer Highlights",
      "last_synced": "2026-02-09T10:00:00Z",
      "media_count_platform": 24
    },
    "google_photos": {
      "album_id": "xyz789",
      "shared_url": "https://photos.app.goo.gl/...",
      "is_shared": true,
      "collaborators": ["user@example.com"]
    }
  },
  "display": {
    "theme": "light",
    "layout": "grid",
    "columns": 3,
    "show_captions": true,
    "show_dates": true
  },
  "stats": {
    "total_views": 1250,
    "total_downloads": 42,
    "last_viewed_at": "2026-02-09T14:30:00Z"
  },
  "export": {
    "last_export_at": "2026-01-15T09:00:00Z",
    "export_format": "zip",
    "include_metadata": true
  }
}
```

---

## Relationships to Other Object Types

### Ownership

```yaml
owned_by: User
  description: "User who owns this album"
  cardinality: "N:1 (many albums, one owner)"
  implementation: "user_id foreign key"
  cascade: "ON DELETE CASCADE (delete album if user deleted)"

created_by: Integration
  description: "Integration that created this album (if imported)"
  cardinality: "N:1 (many albums, one integration)"
  implementation: "integration_id foreign key"
  cascade: "ON DELETE SET NULL"
```

### Media Organization

```yaml
contains_media: Media
  description: "Media items in this album"
  cardinality: "M:N (many albums, many media)"
  implementation: "album_media join table"
  join_table_fields:
    - album_id: UUID (FK to Album.id)
    - media_id: UUID (FK to Media.id)
    - position: Integer (for manual sort order)
    - added_at: DateTime (when media added to album)
  constraints:
    - Composite unique (album_id, media_id)
    - Media can be in multiple albums
    - Position used for sort_order = 'manual'

has_cover: Media
  description: "Media used as album cover/thumbnail"
  cardinality: "N:1 (many albums, one cover media)"
  implementation: "cover_media_id foreign key"
  cascade: "ON DELETE SET NULL"
  constraint: "Cover media must be in the album"
```

### Hierarchical Organization

```yaml
parent_album: Album
  description: "Parent album in nested hierarchy"
  cardinality: "N:1 (many child albums, one parent)"
  implementation: "parent_album_id foreign key"
  cascade: "ON DELETE CASCADE"
  constraints:
    - No circular references
    - Max depth: 5 levels

child_albums: Album
  description: "Sub-albums nested under this album"
  cardinality: "1:N (one parent, many children)"
  implementation: "Reverse of parent_album"
```

### Sharing

```yaml
shared_with: User
  description: "Users who have access to shared album"
  cardinality: "M:N (many albums, many users)"
  implementation: "album_shares join table"
  join_table_fields:
    - album_id: UUID
    - user_id: UUID
    - permission: Enum (view, edit, admin)
    - shared_at: DateTime
    - shared_by: UUID (user who granted access)
  applicable: "visibility = 'shared'"
```

---

## API Endpoints

### Album Creation

```http
POST /api/v1/albums
  Description: Create new album
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "title": "Summer Vacation 2024",
      "description": "Trip to Hawaii",
      "album_type": "manual",
      "start_date": "2024-06-01T00:00:00Z",
      "end_date": "2024-06-14T23:59:59Z",
      "visibility": "private"
    }
  Response: 201 Created
    {
      "id": "album-uuid",
      "title": "Summer Vacation 2024",
      "album_type": "manual",
      "media_count": 0,
      "visibility": "private",
      "created_at": "2026-02-09T15:00:00Z"
    }

POST /api/v1/albums/smart
  Description: Create smart album with auto-population
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "title": "Hawaii Photos",
      "album_type": "smart",
      "metadata": {
        "smart_criteria": {
          "location": "Hawaii",
          "date_range": {
            "start": "2024-06-01",
            "end": "2024-06-30"
          },
          "media_type": ["photo"]
        }
      }
    }
  Response: 201 Created
    {
      "id": "album-uuid",
      "title": "Hawaii Photos",
      "album_type": "smart",
      "media_count": 127,
      "created_at": "2026-02-09T15:00:00Z"
    }
  Behavior:
    - Media automatically added based on smart_criteria
    - Album updates as new matching media is added
```

### Album Retrieval

```http
GET /api/v1/albums/{id}
  Description: Get album details with media list
  Headers:
    Authorization: Bearer {access_token}
  Query Parameters:
    include_media: true|false (default: false)
    limit: 50 (media page size, default: 50)
    offset: 0 (media pagination offset)
  Response: 200 OK
    {
      "id": "album-uuid",
      "title": "Summer Vacation 2024",
      "description": "Trip to Hawaii",
      "album_type": "manual",
      "media_count": 127,
      "cover_media_id": "media-uuid",
      "visibility": "private",
      "created_at": "2026-02-09T15:00:00Z",
      "media": [{media objects}]  // if include_media=true
    }
  Privacy:
    - Owner always has access
    - Shared users need appropriate permission
    - Public/unlisted accessible via share_token

GET /api/v1/albums/{id}/media
  Description: Get paginated media in album
  Headers:
    Authorization: Bearer {access_token}
  Query Parameters:
    limit: 50 (default: 50, max: 200)
    offset: 0
    sort: date_desc|date_asc|manual (uses album's sort_order by default)
  Response: 200 OK
    {
      "media": [{media objects}],
      "total": 127,
      "limit": 50,
      "offset": 0,
      "album": {album summary}
    }

GET /api/v1/albums/shared/{share_token}
  Description: Access public/unlisted album via share token
  Headers: None (public access)
  Response: 200 OK
    {album and media data}
  Behavior:
    - No authentication required
    - Respects allow_downloads setting
    - Limited to visibility=public or unlisted
```

### Album Management

```http
PATCH /api/v1/albums/{id}
  Description: Update album metadata
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "title": "Updated Title",
      "description": "Updated description",
      "cover_media_id": "media-uuid",
      "visibility": "shared",
      "allow_downloads": false
    }
  Response: 200 OK
    {updated album object}
  Constraints:
    - Cannot change: album_type (manual/smart/imported)
    - Owner or users with edit permission only

DELETE /api/v1/albums/{id}
  Description: Soft delete album
  Headers:
    Authorization: Bearer {access_token}
  Response: 204 No Content
  Behavior:
    - Sets deleted_at timestamp
    - Album preserved for 30 days
    - Media remains (only album deleted)
    - Cannot delete system albums
  Permissions:
    - Owner or users with admin permission only
```

### Media Management

```http
POST /api/v1/albums/{id}/media
  Description: Add media to album
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "media_ids": ["media-uuid-1", "media-uuid-2"],
      "position": 0  // Optional, for manual sort order
    }
  Response: 200 OK
    {
      "added_count": 2,
      "album": {updated album object}
    }
  Constraints:
    - Media must be owned by user
    - Media must not be deleted
    - Duplicates ignored (no error)
    - Only for manual albums (smart albums auto-managed)

DELETE /api/v1/albums/{id}/media
  Description: Remove media from album
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "media_ids": ["media-uuid-1", "media-uuid-2"]
    }
  Response: 200 OK
    {
      "removed_count": 2,
      "album": {updated album object}
    }
  Behavior:
    - Media not deleted, only removed from album
    - Media can still be in other albums
    - Only for manual albums

POST /api/v1/albums/{id}/reorder
  Description: Reorder media in album (manual sort only)
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "media_positions": [
        {"media_id": "uuid-1", "position": 0},
        {"media_id": "uuid-2", "position": 1},
        {"media_id": "uuid-3", "position": 2}
      ]
    }
  Response: 200 OK
  Constraints:
    - Only for albums with sort_order = 'manual'
```

### Sharing

```http
POST /api/v1/albums/{id}/share
  Description: Share album with users or generate public link
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "visibility": "shared",
      "user_emails": ["user@example.com"],
      "permission": "view",
      "allow_downloads": true
    }
  Response: 200 OK
    {
      "album": {updated album object},
      "share_url": "https://hypernet.io/albums/shared/{token}"
    }
  Behavior:
    - Generates share_token if not exists
    - Sends email invitations to shared users
    - Creates album_shares records

DELETE /api/v1/albums/{id}/share
  Description: Remove sharing / make album private
  Headers:
    Authorization: Bearer {access_token}
  Response: 200 OK
  Behavior:
    - Sets visibility to 'private'
    - Removes all album_shares records
    - Keeps share_token (for potential re-sharing)

POST /api/v1/albums/{id}/regenerate-token
  Description: Generate new share token (revoke old link)
  Headers:
    Authorization: Bearer {access_token}
  Response: 200 OK
    {
      "share_token": "new-token",
      "share_url": "https://hypernet.io/albums/shared/{new-token}"
    }
  Purpose: "Revoke access via old public link"
```

### Bulk Operations

```http
GET /api/v1/albums
  Description: List user's albums
  Headers:
    Authorization: Bearer {access_token}
  Query Parameters:
    album_type: manual|smart|imported|system
    parent_album_id: {uuid} - Child albums only
    visibility: private|shared|public|unlisted
    limit: 50 (default: 50, max: 200)
    offset: 0
    sort: created_at|updated_at|title|media_count
    order: asc|desc (default: desc)
  Response: 200 OK
    {
      "albums": [{album objects}],
      "total": 45,
      "limit": 50,
      "offset": 0
    }

POST /api/v1/albums/{id}/export
  Description: Export album as ZIP file
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "include_metadata": true,
      "format": "zip"
    }
  Response: 202 Accepted
    {
      "job_id": "export-job-uuid",
      "status": "processing"
    }
  Behavior:
    - Async job to create ZIP file
    - Includes all media files
    - Optional JSON metadata file
    - Download link sent when ready
```

---

## Database Schema (SQLAlchemy Model Reference)

```python
from sqlalchemy import (
    Column, String, Integer, Enum as SQLEnum,
    DateTime, Boolean, ForeignKey, Index, CheckConstraint, Text, Table
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from app.models.base import BaseObject

# Association table for album-media many-to-many relationship
album_media = Table(
    'album_media',
    BaseObject.metadata,
    Column('album_id', UUID(as_uuid=True), ForeignKey('albums.id', ondelete='CASCADE'),
           primary_key=True),
    Column('media_id', UUID(as_uuid=True), ForeignKey('media.id', ondelete='CASCADE'),
           primary_key=True),
    Column('position', Integer, nullable=True, doc="Position for manual sort order"),
    Column('added_at', DateTime(timezone=True), nullable=False,
           default=datetime.utcnow, doc="When media was added to album"),
    Index('idx_album_media_album', 'album_id'),
    Index('idx_album_media_media', 'media_id'),
    Index('idx_album_media_position', 'album_id', 'position'),
)

# Association table for album sharing
album_shares = Table(
    'album_shares',
    BaseObject.metadata,
    Column('album_id', UUID(as_uuid=True), ForeignKey('albums.id', ondelete='CASCADE'),
           primary_key=True),
    Column('user_id', UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'),
           primary_key=True),
    Column('permission', SQLEnum('view', 'edit', 'admin', name='album_permission_enum'),
           nullable=False, default='view'),
    Column('shared_at', DateTime(timezone=True), nullable=False, default=datetime.utcnow),
    Column('shared_by', UUID(as_uuid=True), ForeignKey('users.id', ondelete='SET NULL'),
           nullable=True),
    Index('idx_album_shares_user', 'user_id'),
)

class Album(BaseObject):
    """
    Album - collection of media items

    Inherits from BaseObject: id, user_id, created_at, updated_at, deleted_at, metadata
    """

    __tablename__ = "albums"

    # Album Identity (Required)
    title = Column(
        String(500),
        nullable=False,
        index=True,
        doc="Album title or name"
    )
    album_type = Column(
        SQLEnum('manual', 'smart', 'imported', 'system',
                name='album_type_enum'),
        nullable=False,
        index=True,
        default='manual',
        doc="Type of album organization"
    )

    # Album Description (Optional)
    description = Column(
        Text,
        nullable=True,
        doc="Detailed description of album"
    )
    cover_media_id = Column(
        UUID(as_uuid=True),
        ForeignKey('media.id', ondelete='SET NULL'),
        nullable=True,
        doc="Media used as album cover"
    )

    # Organization (Optional)
    parent_album_id = Column(
        UUID(as_uuid=True),
        ForeignKey('albums.id', ondelete='CASCADE'),
        nullable=True,
        index=True,
        doc="Parent album for nested organization"
    )
    sort_order = Column(
        String(50),
        nullable=False,
        default='date_desc',
        doc="Default sort order for media"
    )
    media_count = Column(
        Integer,
        nullable=False,
        default=0,
        index=True,
        doc="Number of media items (denormalized)"
    )

    # Temporal Information (Optional)
    start_date = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        doc="Start date/time for event-based albums"
    )
    end_date = Column(
        DateTime(timezone=True),
        nullable=True,
        doc="End date/time for event-based albums"
    )

    # Sharing and Privacy (Optional)
    visibility = Column(
        SQLEnum('private', 'shared', 'public', 'unlisted',
                name='album_visibility_enum'),
        nullable=False,
        default='private',
        index=True,
        doc="Album visibility setting"
    )
    share_token = Column(
        String(64),
        nullable=True,
        unique=True,
        index=True,
        doc="Random token for public access"
    )
    allow_downloads = Column(
        Boolean,
        nullable=False,
        default=True,
        doc="Allow downloads in shared albums"
    )

    # Platform Synchronization (Optional)
    source_platform = Column(
        String(100),
        nullable=True,
        index=True,
        doc="Platform where album originated"
    )
    source_id = Column(
        String(200),
        nullable=True,
        index=True,
        doc="External album ID"
    )
    integration_id = Column(
        UUID(as_uuid=True),
        ForeignKey('integrations.id', ondelete='SET NULL'),
        nullable=True,
        index=True,
        doc="Integration that manages this album"
    )
    sync_enabled = Column(
        Boolean,
        nullable=False,
        default=False,
        doc="Keep synced with platform album"
    )

    # Relationships
    owner = relationship("User", foreign_keys=[BaseObject.user_id])
    cover_media = relationship("Media", foreign_keys=[cover_media_id])
    integration = relationship("Integration", foreign_keys=[integration_id])

    media = relationship(
        "Media",
        secondary=album_media,
        back_populates="albums",
        order_by="album_media.c.position"
    )

    parent_album = relationship(
        "Album",
        remote_side="Album.id",
        foreign_keys=[parent_album_id]
    )
    child_albums = relationship(
        "Album",
        back_populates="parent_album"
    )

    shared_users = relationship(
        "User",
        secondary=album_shares,
        backref="shared_albums"
    )

    # Table Constraints
    __table_args__ = (
        # Media count must be non-negative
        CheckConstraint('media_count >= 0', name='check_media_count'),

        # End date must be after start date
        CheckConstraint(
            'end_date IS NULL OR start_date IS NULL OR end_date >= start_date',
            name='check_date_range'
        ),

        # Cannot be own parent
        CheckConstraint(
            'parent_album_id IS NULL OR parent_album_id != id',
            name='check_no_self_parent'
        ),

        # Composite indexes
        Index('idx_album_user_type', 'user_id', 'album_type'),
        Index('idx_album_visibility', 'visibility'),
        Index('idx_album_dates', 'start_date', 'end_date'),
        Index('idx_album_source', 'source_platform', 'source_id'),
    )

    def __repr__(self):
        return f"<Album(id={self.id}, title={self.title}, type={self.album_type})>"

    @property
    def is_manual(self):
        return self.album_type == 'manual'

    @property
    def is_smart(self):
        return self.album_type == 'smart'

    @property
    def is_shared(self):
        return self.visibility in ('shared', 'public', 'unlisted')

    @property
    def public_url(self):
        if self.share_token and self.visibility in ('public', 'unlisted'):
            return f"https://hypernet.io/albums/shared/{self.share_token}"
        return None
```

---

## Privacy and Security Considerations

### Access Control

1. **Ownership Enforcement**
   - Albums only accessible by owner by default
   - Shared albums require explicit permission grant
   - Public albums accessible via unguessable token

2. **Permission Levels**
   - View: Can view album and media, download if allowed
   - Edit: Can add/remove media, edit metadata
   - Admin: Can delete album, change sharing settings

3. **Share Token Security**
   - 64 character cryptographically random token
   - Unguessable without sharing
   - Can be regenerated to revoke access
   - Separate tokens per album

### Data Protection

1. **Privacy Cascading**
   - Album privacy doesn't override media privacy
   - Shared album shows only media user has access to
   - Location data stripped if user preference set

2. **Download Control**
   - allow_downloads flag prevents file access
   - View-only mode for sensitive albums
   - Watermarking option (future)

3. **GDPR Compliance**
   - User can export all albums with media
   - Album deletion includes cleanup of shares
   - Soft delete with 30-day recovery

---

## Validation Rules

### On Creation

```yaml
title:
  - Minimum 1 character
  - Maximum 500 characters
  - Required

album_type:
  - Must be valid enum value
  - Immutable after creation

parent_album_id:
  - Must exist and belong to same user
  - Cannot create circular references
  - Max nesting depth: 5

smart_criteria:
  - Required if album_type = 'smart'
  - Must be valid criteria object
```

### On Update

```yaml
immutable_fields:
  - id, user_id
  - album_type
  - created_at

mutable_fields:
  - title, description
  - cover_media_id
  - visibility, allow_downloads
  - sort_order
  - start_date, end_date

constraints:
  - cover_media_id must reference media in album
  - end_date >= start_date
```

---

## Use Cases and Examples

### Example 1: Manual Event Album

```json
{
  "id": "album-550e8400-e29b-41d4-a716-446655440000",
  "user_id": "user-uuid",
  "title": "Sarah's 30th Birthday Party",
  "description": "Amazing celebration at the beach house",
  "album_type": "manual",
  "cover_media_id": "media-uuid",
  "media_count": 87,
  "start_date": "2024-06-15T18:00:00Z",
  "end_date": "2024-06-15T23:59:59Z",
  "visibility": "shared",
  "allow_downloads": true,
  "sort_order": "date_asc",
  "created_at": "2024-06-16T10:00:00Z",
  "updated_at": "2024-06-20T14:30:00Z",
  "deleted_at": null
}
```

### Example 2: Smart Location-Based Album

```json
{
  "id": "album-660e8400-e29b-41d4-a716-446655440001",
  "user_id": "user-uuid",
  "title": "All Photos in Tokyo",
  "album_type": "smart",
  "media_count": 342,
  "visibility": "private",
  "sort_order": "date_desc",
  "metadata": {
    "smart_criteria": {
      "location": "Tokyo",
      "media_type": ["photo"],
      "min_quality_score": 0.7
    }
  },
  "created_at": "2024-07-01T09:00:00Z",
  "updated_at": "2026-02-09T15:00:00Z",
  "deleted_at": null
}
```

### Example 3: Imported Instagram Album

```json
{
  "id": "album-770e8400-e29b-41d4-a716-446655440002",
  "user_id": "user-uuid",
  "title": "Instagram: Highlights",
  "album_type": "imported",
  "media_count": 24,
  "source_platform": "instagram",
  "source_id": "instagram-album-123",
  "integration_id": "integration-uuid",
  "sync_enabled": true,
  "visibility": "private",
  "metadata": {
    "platform": {
      "instagram": {
        "album_name": "Highlights",
        "last_synced": "2026-02-09T10:00:00Z"
      }
    }
  },
  "created_at": "2025-01-10T12:00:00Z",
  "updated_at": "2026-02-09T10:00:00Z",
  "deleted_at": null
}
```

---

## Lifecycle States

### 1. Empty Album

```yaml
state: "empty"
media_count: 0
capabilities:
  - Can add media
  - Can set metadata
  - Can delete without confirmation
transitions:
  - add_media -> Active
  - delete -> Deleted
```

### 2. Active Album

```yaml
state: "active"
media_count: > 0
capabilities:
  - Add/remove media (manual albums)
  - Share with users
  - Export as ZIP
  - Generate thumbnails
transitions:
  - remove_all_media -> Empty
  - delete -> Deleted
```

### 3. Syncing (Imported Albums)

```yaml
state: "syncing"
album_type: "imported"
sync_enabled: true
behavior:
  - Periodic sync with platform
  - Auto-add new media
  - Update metadata from platform
transitions:
  - sync_complete -> Active
  - disable_sync -> Static Imported
```

### 4. Deleted

```yaml
state: "deleted"
deleted_at: not null
behavior:
  - Album hidden from UI
  - Media preserved (not deleted)
  - 30-day recovery window
transitions:
  - restore -> Active
  - timeout -> Hard Deleted
```

---

## Notes for Implementers

### Performance Optimization

1. **Denormalized Counts**
   ```python
   # Update media_count on media add/remove
   album.media_count = len(album.media)
   # Avoid COUNT queries in listings
   ```

2. **Smart Album Updates**
   ```python
   # Rebuild smart albums asynchronously
   # Schedule: When media added/updated
   # Rate limit: Max once per 5 minutes per album
   ```

3. **Thumbnail Generation**
   - Use cover_media thumbnail as album thumbnail
   - Cache album thumbnails with CDN
   - Generate collage thumbnails (4 media) for better preview

### Smart Album Implementation

```python
def populate_smart_album(album):
    """Populate smart album based on criteria"""
    criteria = album.metadata.get('smart_criteria', {})

    query = Media.query.filter_by(user_id=album.user_id)

    if 'media_type' in criteria:
        query = query.filter(Media.media_type.in_(criteria['media_type']))

    if 'location' in criteria:
        query = query.filter(Media.location_name.ilike(f"%{criteria['location']}%"))

    if 'tags' in criteria:
        for tag in criteria['tags']:
            query = query.filter(Media.tags.contains([tag]))

    if 'date_range' in criteria:
        query = query.filter(
            Media.taken_at >= criteria['date_range']['start'],
            Media.taken_at <= criteria['date_range']['end']
        )

    # Clear existing and add matching media
    album.media = query.all()
    album.media_count = len(album.media)
```

---

**Status:** Active - Core Media Type
**Version:** 1.0
**Authority:** 0.0.2 - Media Types
**Created:** 2026-02-09
**Owner:** Hypernet Core (0.*)
