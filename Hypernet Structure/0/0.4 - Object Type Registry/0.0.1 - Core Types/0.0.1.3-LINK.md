# LINK - Relationship Between Objects Type

**Type ID:** `hypernet.core.link`
**Version:** 1.0
**Category:** 0.0.1 - Core Types
**Parent:** BaseObject
**Status:** Active - Critical Core Type
**Created:** 2026-02-09
**Last Updated:** 2026-02-09

---

## Object Type Metadata

```yaml
type_name: "Link"
type_id: "hypernet.core.link"
version: "1.0"
parent_type: "BaseObject"
category: "0.0.1 - Core Types"
abstract: false
instantiable: true
```

---

## Purpose and Description

### What is a Link?

A Link is a first-class object that represents a typed relationship between any two objects in Hypernet. Unlike traditional foreign keys or join tables, Links are full-fledged objects with their own identity, metadata, and lifecycle. This design enables Hypernet to function as a knowledge graph where relationships are as important as the objects themselves.

### Revolutionary Design Philosophy

In most systems, relationships are implicit (foreign keys) or hidden (join tables). Hypernet makes relationships explicit and first-class:
- Links ARE objects, not just references
- Links have IDs, timestamps, and metadata
- Links can be queried, filtered, and analyzed
- Links enable graph traversal and knowledge discovery
- Links support AI reasoning about relationships

### Core Functions

1. **Object Relationships** - Connect any object to any other object with semantic meaning
2. **Graph Structure** - Enable graph queries and traversal across all data
3. **Provenance Tracking** - Record where data came from (Photo from Instagram)
4. **Collection Management** - Organize objects into albums, playlists, folders
5. **Deduplication** - Mark duplicates and variants without deletion
6. **Knowledge Graph** - Foundation for AI understanding of user's data universe

### When to Use

- Album contains Photos: `Album --contains--> Photo`
- Photo sourced from Instagram: `Photo --source--> Integration`
- Two Photos are duplicates: `Photo --duplicate_of--> Photo`
- Photo edited from original: `Photo --variant_of--> Photo`
- Event happened at Location: `Event --located_at--> Location`
- Email mentions Person: `Email --mentions--> Contact`
- Any typed relationship between objects

---

## Inherited Fields from BaseObject

```yaml
id: UUID
  - Unique link identifier
  - Links are queryable objects

user_id: UUID
  - Owner of this relationship
  - Typically same as from_object owner
  - Enables per-user relationship graphs

created_at: DateTime
  - When relationship was established
  - Important for temporal graph analysis

updated_at: DateTime
  - Last modification to relationship
  - Updated when metadata changes

deleted_at: DateTime (nullable)
  - Soft delete for relationships
  - Preserves historical graph structure

source_type: String
  - How relationship was created
  - "user" (manually created)
  - "ai" (AI detected)
  - "system" (auto-generated)
  - "integration" (from external service)

source_id: String
  - Optional source identifier

metadata: JSONB
  - Relationship-specific data
  - Confidence scores, reasoning, attributes
```

---

## Required Fields

### Relationship Endpoints

```yaml
from_object_id: UUID
  type: UUID
  nullable: false
  indexed: true
  description: "Source object ID in this relationship"
  constraints:
    - Must be valid UUID
    - Object should exist (soft constraint for flexibility)
  purpose: "Start point of directed relationship"
  examples:
    - Album ID (in album --contains--> photo)
    - Photo ID (in photo --source--> integration)
    - Photo ID (in photo --duplicate_of--> photo)

from_object_type: String(50)
  type: String
  max_length: 50
  nullable: false
  indexed: true
  description: "Type of source object"
  allowed_values:
    - Any valid object type name: "Photo", "Video", "Album", "User", etc.
  purpose: "Enable type-specific queries and validation"
  validation:
    - Must match actual object type
    - Case-sensitive
  examples:
    - "Album"
    - "Photo"
    - "User"
    - "Event"

to_object_id: UUID
  type: UUID
  nullable: false
  indexed: true
  description: "Target object ID in this relationship"
  constraints:
    - Must be valid UUID
    - Object should exist (soft constraint)
  purpose: "End point of directed relationship"
  examples:
    - Photo ID (in album --contains--> photo)
    - Integration ID (in photo --source--> integration)
    - Original Photo ID (in edited --duplicate_of--> original)

to_object_type: String(50)
  type: String
  max_length: 50
  nullable: false
  indexed: true
  description: "Type of target object"
  allowed_values:
    - Any valid object type name
  purpose: "Enable type-specific queries and validation"
```

### Relationship Type

```yaml
link_type: String(50)
  type: String
  max_length: 50
  nullable: false
  indexed: true
  description: "Semantic type of relationship"
  allowed_values:
    # Collection/Containment
    - "contains": Parent contains child (Album → Photo)
    - "belongs_to": Child belongs to parent (Photo → Album, inverse of contains)

    # Provenance/Source
    - "source": Object sourced from external service (Photo → Integration)
    - "imported_from": Alternative to source
    - "exported_to": Object exported to external service

    # Duplication
    - "duplicate_of": Exact duplicate (Photo → Photo)
    - "variant_of": Different version (Edited → Original)
    - "derived_from": Derived work (Thumbnail → Photo)

    # Relationships
    - "related_to": General relationship (Photo ↔ Photo)
    - "similar_to": Similarity relationship (Photo ↔ Photo)
    - "references": One object references another (Note → Photo)

    # Location
    - "located_at": Object at location (Event → Location)
    - "taken_at": Photo taken at location (Photo → Location)

    # People
    - "depicts": Media depicts person (Photo → Contact)
    - "created_by": Created by user/AI (Object → User)
    - "mentions": Object mentions entity (Email → Contact)

    # Temporal
    - "before": Temporal ordering (Event → Event)
    - "after": Temporal ordering (Event → Event)
    - "during": Temporal containment (Event → Event)

    # AI/Knowledge
    - "similar_embedding": AI-detected similarity
    - "topic": Object relates to topic (Note → Topic)
    - "tagged_with": Object tagged with label (Photo → Tag)
  validation:
    - Must be lowercase with underscores
    - Should be semantically clear
  extensibility:
    - New link types can be added
    - Follow naming convention: verb or verb_preposition
```

---

## Optional Fields

### Relationship Attributes

```yaml
strength: Float
  type: Float
  nullable: true
  default: 1.0
  range: 0.0 to 1.0
  description: "Confidence or weight of relationship"
  purpose: "Express uncertainty or importance"
  examples:
    - 1.0: Certain relationship (user-created)
    - 0.95: High confidence AI detection
    - 0.7: Moderate confidence similarity
    - 0.3: Weak possible relationship
  usage:
    - AI-detected relationships have < 1.0 strength
    - Filter low-confidence links
    - Weight graph algorithms

is_bidirectional: Boolean
  type: Boolean
  nullable: false
  default: false
  description: "Whether relationship is symmetric"
  examples:
    - false: "contains", "source", "duplicate_of" (directed)
    - true: "related_to", "similar_to" (undirected)
  purpose: "Simplify bidirectional relationship queries"
  implementation:
    - If true, query both directions without inverse link
    - If false, need separate inverse link for reverse traversal

sort_order: Integer
  type: Integer
  nullable: true
  description: "Position in ordered relationships"
  purpose: "Maintain order in collections"
  examples:
    - Photos in album: 1, 2, 3, ...
    - Playlist tracks: 1, 2, 3, ...
    - Timeline events: by timestamp
  constraints:
    - Null for unordered relationships
    - Unique within (from_object_id, link_type) group
  usage:
    - ORDER BY sort_order in queries
    - Drag-and-drop reordering updates sort_order
```

### Relationship Metadata

```yaml
confidence_score: Float (in metadata)
  description: "AI confidence in relationship"
  range: 0.0 to 1.0
  applicable: AI-detected relationships

reasoning: String (in metadata)
  description: "Why relationship was created"
  examples:
    - "Same location and timestamp"
    - "Visual similarity detected"
    - "User manually added"

attributes: Object (in metadata)
  description: "Type-specific attributes"
  examples:
    - contains: {"position": 5, "featured": true}
    - depicts: {"face_box": [x, y, w, h], "name": "John"}
    - similar_to: {"similarity_score": 0.87, "method": "embedding"}
```

---

## Metadata Schema

The `metadata` JSONB field stores relationship-specific data:

```json
{
  "relationship_details": {
    "added_by": "user|ai|system",
    "added_at": "2026-02-09T10:00:00Z",
    "confidence": 0.89,
    "reasoning": "Same location and timestamp",
    "method": "rule_based|ml_model|user_action"
  },
  "contains": {
    "position": 5,
    "featured": true,
    "caption": "Sunset at the beach",
    "added_to_album_at": "2026-02-09T10:00:00Z"
  },
  "source": {
    "sync_timestamp": "2026-02-09T09:00:00Z",
    "original_id": "instagram:12345",
    "original_url": "https://instagram.com/p/xyz",
    "sync_batch_id": "batch-uuid"
  },
  "duplicate_of": {
    "detection_method": "perceptual_hash",
    "hash_similarity": 1.0,
    "file_size_diff": 0,
    "confirmed_by_user": false
  },
  "similar_to": {
    "similarity_score": 0.87,
    "similarity_method": "clip_embedding",
    "embedding_distance": 0.13,
    "model_version": "openai-clip-vit-l-14"
  },
  "depicts": {
    "face_bounding_box": {
      "x": 100,
      "y": 150,
      "width": 80,
      "height": 100
    },
    "face_confidence": 0.98,
    "recognized_as": "contact-uuid",
    "recognition_confidence": 0.92
  },
  "located_at": {
    "precision": "exact|approximate|city|country",
    "source": "gps|exif|user_added|ai_detected",
    "confidence": 0.95
  },
  "tags": {
    "tag_name": "vacation",
    "auto_generated": true,
    "tag_source": "ai_vision"
  }
}
```

---

## Relationships to Other Object Types

Links connect to two arbitrary objects, making them highly flexible:

### From Object (Source)

```yaml
from: Any Object Type
  description: "Source object in this relationship"
  cardinality: "N:1 (many links from one object)"
  implementation: "from_object_id + from_object_type"
  queries:
    - Get all links FROM a Photo
    - Get all contains links FROM an Album
```

### To Object (Target)

```yaml
to: Any Object Type
  description: "Target object in this relationship"
  cardinality: "N:1 (many links to one object)"
  implementation: "to_object_id + to_object_type"
  queries:
    - Get all links TO a Photo
    - Get all source links TO an Integration
```

### Owner

```yaml
owned_by: User
  description: "User who owns this relationship"
  cardinality: "N:1 (many links, one user)"
  implementation: "user_id foreign key"
  constraints:
    - Typically same as from_object owner
    - Can differ for shared relationships
```

---

## API Endpoints

### Link Management

```http
POST /api/v1/links
  Description: Create new relationship between objects
  Request Body:
    {
      "from_object_id": "album-uuid",
      "from_object_type": "Album",
      "to_object_id": "photo-uuid",
      "to_object_type": "Photo",
      "link_type": "contains",
      "sort_order": 10,
      "strength": 1.0,
      "metadata": {
        "featured": true
      }
    }
  Response: 201 Created
    {link object with all fields}
  Validation:
    - Objects must exist (or skip_validation=true)
    - User must own from_object
    - No duplicate link (same from, to, type)
  Security:
    - User must own from_object
    - User must have read access to to_object

GET /api/v1/links/{id}
  Description: Get single link details
  Path Parameters:
    id: UUID (required) - link ID
  Response: 200 OK
    {link object}
  Security:
    - User must own link or have access to linked objects

PATCH /api/v1/links/{id}
  Description: Update link attributes
  Request Body:
    {
      "sort_order": 15,
      "strength": 0.9,
      "metadata": {additional metadata}
    }
  Response: 200 OK
    {updated link object}
  Validation:
    - Cannot change: from/to objects, link_type
    - Can change: sort_order, strength, metadata

DELETE /api/v1/links/{id}
  Description: Delete relationship (soft delete)
  Response: 204 No Content
  Security:
    - User must own link
```

### Link Queries

```http
GET /api/v1/links
  Description: Query links with flexible filtering
  Query Parameters:
    from_id: UUID - filter by source object
    from_type: string - filter by source type
    to_id: UUID - filter by target object
    to_type: string - filter by target type
    link_type: string - filter by relationship type
    is_bidirectional: boolean
    min_strength: float (0.0-1.0)
    include_deleted: boolean
    limit: integer (default 50, max 500)
    offset: integer (default 0)
  Response: 200 OK
    {
      "items": [{link}, {link}, ...],
      "total": 150,
      "limit": 50,
      "offset": 0
    }
  Examples:
    - GET /api/v1/links?from_id={album_id}&link_type=contains
      → Get all photos in album
    - GET /api/v1/links?to_id={integration_id}&link_type=source
      → Get all media from integration
    - GET /api/v1/links?from_id={photo_id}&link_type=similar_to&min_strength=0.8
      → Get similar photos with high confidence

GET /api/v1/objects/{id}/links/outgoing
  Description: Get all links FROM this object
  Path Parameters:
    id: UUID - source object ID
  Query Parameters:
    link_type: string - filter by type
    to_type: string - filter by target type
  Response: 200 OK
    {
      "items": [{link with target object}, ...],
      "total": 25
    }

GET /api/v1/objects/{id}/links/incoming
  Description: Get all links TO this object
  Path Parameters:
    id: UUID - target object ID
  Query Parameters:
    link_type: string - filter by type
    from_type: string - filter by source type
  Response: 200 OK
    {
      "items": [{link with source object}, ...],
      "total": 10
    }
```

### Convenience Endpoints

```http
POST /api/v1/albums/{id}/add-media
  Description: Add media to album (creates contains link)
  Path Parameters:
    id: UUID - album ID
  Request Body:
    {
      "media_ids": ["photo-uuid-1", "photo-uuid-2"],
      "sort_order_start": 10
    }
  Response: 201 Created
    {
      "links_created": 2,
      "links": [{link}, {link}]
    }
  Implementation:
    - Creates contains link for each media item
    - Auto-assigns sort_order if not specified

GET /api/v1/albums/{id}/media
  Description: Get all media in album (traverses contains links)
  Path Parameters:
    id: UUID - album ID
  Query Parameters:
    sort_by: "sort_order|created_at|updated_at"
    order: "asc|desc"
  Response: 200 OK
    {
      "items": [
        {
          "photo": {photo object},
          "link": {link object},
          "position": 1
        }
      ]
    }
  Implementation:
    - Query links WHERE from_id=album_id AND link_type='contains'
    - Join with Photo/Video objects
    - Order by sort_order

DELETE /api/v1/albums/{id}/media/{media_id}
  Description: Remove media from album (deletes contains link)
  Response: 204 No Content
```

### Graph Traversal

```http
GET /api/v1/graph/traverse
  Description: Multi-hop graph traversal
  Query Parameters:
    start_id: UUID (required) - starting object
    link_types: string[] - relationship types to follow
    max_depth: integer (default 2, max 5)
    direction: "outgoing|incoming|both"
  Response: 200 OK
    {
      "nodes": [{object}, {object}, ...],
      "edges": [{link}, {link}, ...],
      "paths": [
        {
          "start": "obj-1",
          "end": "obj-10",
          "path": ["obj-1", "obj-5", "obj-10"],
          "depth": 2
        }
      ]
    }
  Examples:
    - Find all photos related to a location (direct + indirect)
    - Find connection path between two objects
    - Discover clusters of related content
```

---

## Database Schema (SQLAlchemy Model Reference)

```python
from sqlalchemy import (
    Column, String, Boolean, Integer, Float,
    DateTime, ForeignKey, Index, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from app.models.base import BaseObject

class Link(BaseObject):
    """
    First-class relationship between any two objects

    Inherits from BaseObject: id, user_id, created_at, updated_at,
    deleted_at, source_type, source_id, metadata
    """

    __tablename__ = "links"

    # Relationship Endpoints
    from_object_id = Column(
        UUID(as_uuid=True),
        nullable=False,
        index=True,
        doc="Source object ID in relationship"
    )
    from_object_type = Column(
        String(50),
        nullable=False,
        index=True,
        doc="Type of source object"
    )

    to_object_id = Column(
        UUID(as_uuid=True),
        nullable=False,
        index=True,
        doc="Target object ID in relationship"
    )
    to_object_type = Column(
        String(50),
        nullable=False,
        index=True,
        doc="Type of target object"
    )

    # Relationship Type
    link_type = Column(
        String(50),
        nullable=False,
        index=True,
        doc="Semantic type of relationship"
    )

    # Relationship Attributes
    strength = Column(
        Float,
        nullable=True,
        default=1.0,
        doc="Confidence or weight (0.0-1.0)"
    )
    is_bidirectional = Column(
        Boolean,
        nullable=False,
        default=False,
        doc="Whether relationship is symmetric"
    )
    sort_order = Column(
        Integer,
        nullable=True,
        doc="Position in ordered relationships"
    )

    # Table Constraints
    __table_args__ = (
        # No self-links (same object, same type)
        CheckConstraint(
            "(from_object_id != to_object_id) OR (from_object_type != to_object_type)",
            name="check_no_self_links"
        ),
        # Strength must be 0.0 to 1.0
        CheckConstraint(
            "strength IS NULL OR (strength >= 0.0 AND strength <= 1.0)",
            name="check_strength_range"
        ),
        # No duplicate links (same from, to, type)
        UniqueConstraint(
            'from_object_id', 'to_object_id', 'link_type',
            name='uq_link_from_to_type',
            postgresql_where="deleted_at IS NULL"
        ),
        # Composite indexes for common queries
        Index('idx_link_from', 'from_object_id', 'link_type', 'deleted_at'),
        Index('idx_link_to', 'to_object_id', 'link_type', 'deleted_at'),
        Index('idx_link_type', 'link_type', 'from_object_type', 'to_object_type'),
        Index('idx_link_ordered', 'from_object_id', 'link_type', 'sort_order',
              postgresql_where="sort_order IS NOT NULL AND deleted_at IS NULL"),
        Index('idx_link_strength', 'link_type', 'strength',
              postgresql_where="strength IS NOT NULL"),
        Index('idx_link_bidirectional', 'is_bidirectional', 'link_type',
              postgresql_where="is_bidirectional = true"),
    )

    def __repr__(self):
        return f"<Link(id={self.id}, type={self.link_type}, " \
               f"from={self.from_object_type}:{self.from_object_id}, " \
               f"to={self.to_object_type}:{self.to_object_id})>"

    @property
    def is_ordered(self):
        """Check if this is part of an ordered relationship"""
        return self.sort_order is not None

    @property
    def is_certain(self):
        """Check if relationship is certain (strength = 1.0)"""
        return self.strength is None or self.strength == 1.0

    def inverse_link_type(self):
        """Get inverse link type for bidirectional relationships"""
        inverse_map = {
            'contains': 'belongs_to',
            'belongs_to': 'contains',
            'before': 'after',
            'after': 'before',
            'created_by': 'created',
        }
        return inverse_map.get(self.link_type)

    @classmethod
    def create_bidirectional(cls, from_id, from_type, to_id, to_type,
                            link_type, user_id, **kwargs):
        """Create a bidirectional link (single record)"""
        return cls(
            from_object_id=from_id,
            from_object_type=from_type,
            to_object_id=to_id,
            to_object_type=to_type,
            link_type=link_type,
            is_bidirectional=True,
            user_id=user_id,
            **kwargs
        )

    @classmethod
    def create_pair(cls, obj1_id, obj1_type, obj2_id, obj2_type,
                   link_type, inverse_type, user_id, **kwargs):
        """Create pair of directed links (obj1->obj2 and obj2->obj1)"""
        link1 = cls(
            from_object_id=obj1_id,
            from_object_type=obj1_type,
            to_object_id=obj2_id,
            to_object_type=obj2_type,
            link_type=link_type,
            user_id=user_id,
            **kwargs
        )
        link2 = cls(
            from_object_id=obj2_id,
            from_object_type=obj2_type,
            to_object_id=obj1_id,
            to_object_type=obj1_type,
            link_type=inverse_type,
            user_id=user_id,
            **kwargs
        )
        return link1, link2
```

---

## Privacy and Security Considerations

### Access Control

1. **Link Creation**
   - User must own from_object
   - User must have read access to to_object
   - Cannot create links between other users' private objects

2. **Link Visibility**
   - Link visible if user has access to BOTH linked objects
   - Private object links not exposed in public APIs
   - User can only query their own links

3. **Link Deletion**
   - Only link owner can delete
   - Deleting object should cascade delete its links
   - Soft delete preserves historical relationships

### Data Protection

1. **Relationship Privacy**
   - Links reveal connections between objects
   - Sensitive relationships (medical, financial) require care
   - AI-detected links should have lower default visibility

2. **Graph Traversal Limits**
   - Max depth limits prevent unbounded queries
   - Rate limiting on graph endpoints
   - Prevent privacy leaks through indirect connections

---

## Validation Rules

### On Creation

```yaml
from_object_id and to_object_id:
  - Must be valid UUIDs
  - Objects should exist (can skip with flag)
  - Cannot be same object with same type

from_object_type and to_object_type:
  - Must be valid object type names
  - Case-sensitive

link_type:
  - Must be in allowed list or new type with admin approval
  - Lowercase with underscores

strength:
  - Must be 0.0 to 1.0 if specified
  - Null treated as 1.0

sort_order:
  - Must be integer if specified
  - Should be unique within (from_object_id, link_type) for ordered relationships

user_id:
  - Typically same as from_object owner
  - Must have permission to create link
```

### On Update

```yaml
immutable_fields:
  - id
  - user_id
  - from_object_id
  - from_object_type
  - to_object_id
  - to_object_type
  - link_type
  - created_at

mutable_fields:
  - strength
  - is_bidirectional
  - sort_order
  - metadata
  - updated_at
```

### Database Constraints

```sql
-- Check constraints
CHECK ((from_object_id != to_object_id) OR (from_object_type != to_object_type))
CHECK (strength IS NULL OR (strength >= 0.0 AND strength <= 1.0))

-- Unique constraint (no duplicate links)
UNIQUE (from_object_id, to_object_id, link_type) WHERE deleted_at IS NULL

-- Indexes for performance
CREATE INDEX idx_link_from ON links(from_object_id, link_type) WHERE deleted_at IS NULL;
CREATE INDEX idx_link_to ON links(to_object_id, link_type) WHERE deleted_at IS NULL;
CREATE INDEX idx_link_type ON links(link_type, from_object_type, to_object_type);
CREATE INDEX idx_link_ordered ON links(from_object_id, link_type, sort_order)
  WHERE sort_order IS NOT NULL AND deleted_at IS NULL;
CREATE INDEX idx_link_user ON links(user_id, link_type) WHERE deleted_at IS NULL;
```

---

## Use Cases and Examples

### Example 1: Album Contains Photos

```json
{
  "id": "link-550e8400-e29b-41d4-a716-446655440000",
  "user_id": "user-123-uuid",
  "from_object_id": "album-uuid-abc",
  "from_object_type": "Album",
  "to_object_id": "photo-uuid-xyz",
  "to_object_type": "Photo",
  "link_type": "contains",
  "strength": 1.0,
  "is_bidirectional": false,
  "sort_order": 5,
  "metadata": {
    "added_to_album_at": "2026-02-09T10:00:00Z",
    "featured": true,
    "caption": "Sunset at the beach"
  },
  "source_type": "user",
  "created_at": "2026-02-09T10:00:00Z",
  "updated_at": "2026-02-09T10:00:00Z",
  "deleted_at": null
}
```

### Example 2: Photo Sourced from Integration

```json
{
  "id": "link-550e8400-e29b-41d4-a716-446655440001",
  "user_id": "user-123-uuid",
  "from_object_id": "photo-uuid-xyz",
  "from_object_type": "Photo",
  "to_object_id": "integration-uuid-instagram",
  "to_object_type": "Integration",
  "link_type": "source",
  "strength": 1.0,
  "is_bidirectional": false,
  "sort_order": null,
  "metadata": {
    "sync_timestamp": "2026-02-09T09:00:00Z",
    "original_id": "instagram:12345678",
    "original_url": "https://instagram.com/p/ABC123",
    "sync_batch_id": "batch-uuid"
  },
  "source_type": "integration",
  "source_id": "instagram:12345678",
  "created_at": "2026-02-09T09:00:00Z",
  "updated_at": "2026-02-09T09:00:00Z",
  "deleted_at": null
}
```

### Example 3: Photo Duplicate Detection

```json
{
  "id": "link-550e8400-e29b-41d4-a716-446655440002",
  "user_id": "user-123-uuid",
  "from_object_id": "photo-uuid-duplicate",
  "from_object_type": "Photo",
  "to_object_id": "photo-uuid-original",
  "to_object_type": "Photo",
  "link_type": "duplicate_of",
  "strength": 1.0,
  "is_bidirectional": false,
  "sort_order": null,
  "metadata": {
    "detection_method": "perceptual_hash",
    "hash_similarity": 1.0,
    "file_size_diff": 0,
    "pixel_dimensions_match": true,
    "confirmed_by_user": false
  },
  "source_type": "system",
  "created_at": "2026-02-09T09:30:00Z",
  "updated_at": "2026-02-09T09:30:00Z",
  "deleted_at": null
}
```

### Example 4: AI-Detected Similar Photos

```json
{
  "id": "link-550e8400-e29b-41d4-a716-446655440003",
  "user_id": "user-123-uuid",
  "from_object_id": "photo-uuid-1",
  "from_object_type": "Photo",
  "to_object_id": "photo-uuid-2",
  "to_object_type": "Photo",
  "link_type": "similar_to",
  "strength": 0.87,
  "is_bidirectional": true,
  "sort_order": null,
  "metadata": {
    "similarity_score": 0.87,
    "similarity_method": "clip_embedding",
    "embedding_distance": 0.13,
    "model_version": "openai-clip-vit-l-14",
    "detected_at": "2026-02-09T11:00:00Z",
    "reasoning": "Similar visual content and composition"
  },
  "source_type": "ai",
  "created_at": "2026-02-09T11:00:00Z",
  "updated_at": "2026-02-09T11:00:00Z",
  "deleted_at": null
}
```

### Example 5: Photo Depicts Person

```json
{
  "id": "link-550e8400-e29b-41d4-a716-446655440004",
  "user_id": "user-123-uuid",
  "from_object_id": "photo-uuid",
  "from_object_type": "Photo",
  "to_object_id": "contact-uuid",
  "to_object_type": "Contact",
  "link_type": "depicts",
  "strength": 0.92,
  "is_bidirectional": false,
  "sort_order": null,
  "metadata": {
    "face_bounding_box": {
      "x": 100,
      "y": 150,
      "width": 80,
      "height": 100
    },
    "face_confidence": 0.98,
    "recognition_confidence": 0.92,
    "recognition_method": "facenet_v2",
    "manually_confirmed": true
  },
  "source_type": "ai",
  "created_at": "2026-02-09T09:00:00Z",
  "updated_at": "2026-02-09T12:00:00Z",
  "deleted_at": null
}
```

---

## Lifecycle States

Links have simpler lifecycle than other objects:

### 1. Active (Normal State)

```yaml
state: "active"
deleted_at: null
capabilities:
  - Relationship is valid
  - Appears in queries
  - Can be traversed
transitions:
  - delete -> Deleted
```

### 2. Deleted (Soft Delete)

```yaml
state: "deleted"
deleted_at: not null
capabilities:
  - Relationship is hidden
  - Excluded from queries (unless explicitly included)
  - Can be restored
  - Preserved for audit
transitions:
  - restore -> Active
  - hard_delete -> Permanently Removed
```

---

## Notes for Implementers

### Query Patterns

```python
# Get all photos in album (ordered)
photos = session.query(Photo).join(Link,
    Link.to_object_id == Photo.id
).filter(
    Link.from_object_id == album_id,
    Link.from_object_type == 'Album',
    Link.to_object_type == 'Photo',
    Link.link_type == 'contains',
    Link.deleted_at == None
).order_by(Link.sort_order).all()

# Get source integration for photo
integration = session.query(Integration).join(Link,
    Link.to_object_id == Integration.id
).filter(
    Link.from_object_id == photo_id,
    Link.link_type == 'source',
    Link.deleted_at == None
).first()

# Get similar photos (bidirectional)
similar = session.query(Photo).join(Link,
    or_(
        and_(Link.to_object_id == Photo.id,
             Link.from_object_id == photo_id),
        and_(Link.from_object_id == Photo.id,
             Link.to_object_id == photo_id)
    )
).filter(
    Link.link_type == 'similar_to',
    Link.is_bidirectional == True,
    Link.strength >= 0.8,
    Link.deleted_at == None
).all()

# Get all related objects (any type, any direction)
related = session.query(Link).filter(
    or_(
        Link.from_object_id == object_id,
        Link.to_object_id == object_id
    ),
    Link.deleted_at == None
).all()
```

### Graph Traversal Algorithm

```python
def traverse_graph(start_id, link_types=None, max_depth=2, direction='outgoing'):
    """Multi-hop graph traversal"""
    visited = set()
    queue = [(start_id, 0)]  # (object_id, depth)
    nodes = []
    edges = []

    while queue:
        current_id, depth = queue.pop(0)

        if current_id in visited or depth > max_depth:
            continue

        visited.add(current_id)

        # Get links from current node
        if direction in ['outgoing', 'both']:
            outgoing = session.query(Link).filter(
                Link.from_object_id == current_id,
                Link.deleted_at == None
            )
            if link_types:
                outgoing = outgoing.filter(Link.link_type.in_(link_types))

            for link in outgoing:
                edges.append(link)
                if link.to_object_id not in visited:
                    queue.append((link.to_object_id, depth + 1))

        if direction in ['incoming', 'both']:
            incoming = session.query(Link).filter(
                Link.to_object_id == current_id,
                Link.deleted_at == None
            )
            if link_types:
                incoming = incoming.filter(Link.link_type.in_(link_types))

            for link in incoming:
                edges.append(link)
                if link.from_object_id not in visited:
                    queue.append((link.from_object_id, depth + 1))

    return visited, edges
```

### Cascade Delete Handling

```python
@event.listens_for(Photo, 'before_delete')
def delete_photo_links(mapper, connection, target):
    """Delete all links when photo is deleted"""
    connection.execute(
        Link.__table__.update().where(
            or_(
                Link.from_object_id == target.id,
                Link.to_object_id == target.id
            )
        ).values(deleted_at=datetime.utcnow())
    )
```

---

**Status:** Active - Critical Core Type
**Version:** 1.0
**Authority:** 0.0.1 - Core Types
**Created:** 2026-02-09
**Owner:** Hypernet Core (0.*)
