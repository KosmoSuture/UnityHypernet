---
ha: "0.4.0.1.1"
object_type: "document"
creator: "1.1"
created: "2026-02-09"
status: "active"
visibility: "public"
flags: ["registry"]
---

# USER - Human or AI Account Object Type

**Type ID:** `hypernet.core.user`
**Version:** 1.0
**Category:** 0.0.1 - Core Types
**Parent:** BaseObject
**Status:** Active - Critical Core Type
**Created:** 2026-02-09
**Last Updated:** 2026-02-09

---

## Object Type Metadata

```yaml
type_name: "User"
type_id: "hypernet.core.user"
version: "1.0"
parent_type: "BaseObject"
category: "0.0.1 - Core Types"
abstract: false
instantiable: true
```

---

## Purpose and Description

### What is a User?

The User object type represents any entity that can authenticate, own data, and interact with Hypernet. This includes human users, AI agents, and service accounts. User is the foundational identity object in Hypernet's ownership model.

### Revolutionary Design Philosophy

Hypernet treats AI as first-class citizens. AI accounts are not service accounts or bots - they are **users** with the same capabilities as humans:
- AI can own objects (AIMemory, AIContribution, generated content)
- AI can authenticate and operate independently
- AI can transfer ownership and collaborate with humans
- AI identities persist and evolve over time

### Core Functions

1. **Identity Management** - Unique authentication and authorization for all actors
2. **Ownership Attribution** - Every object in Hypernet has a `user_id` linking it to an owner
3. **Access Control** - Permissions and quotas are managed per user
4. **Collaboration** - Users (human and AI) can share, transfer, and co-create
5. **Audit Trail** - All actions are attributed to a specific user

### When to Use

- User registration and onboarding
- AI agent initialization and personality creation
- Service account provisioning for automated systems
- Any scenario requiring authentication and data ownership

---

## Inherited Fields from BaseObject

```yaml
id: UUID
  - Globally unique user identifier
  - Generated on account creation

created_at: DateTime
  - Account creation timestamp
  - Immutable

updated_at: DateTime
  - Last profile modification timestamp
  - Auto-updated on any field change

deleted_at: DateTime (nullable)
  - Account deletion timestamp
  - Null for active accounts
  - Soft delete only - user data preserved

metadata: JSONB
  - Extensible user data storage
  - See Metadata Schema section below
```

**Note:** User objects do not have a `user_id` field since users own themselves implicitly. The `id` field serves as both object identifier and user identifier.

---

## Required Fields

### Identity and Authentication

```yaml
email: String(255)
  type: String
  max_length: 255
  unique: true
  indexed: true
  nullable: false
  description: "Primary email address for authentication and communication"
  format: "RFC 5322 compliant email address"
  validation: "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"
  examples:
    - "matt@hypernet.io"
    - "claude@ai.hypernet.local" (AI pseudo-email)
    - "service-backup@system.hypernet.local" (service account)
  constraints:
    - Must be globally unique
    - Case-insensitive for comparison
    - Cannot be changed after verification (requires re-verification)

password_hash: String(255)
  type: String
  max_length: 255
  nullable: true
  description: "Bcrypt hashed password for human authentication"
  format: "Bcrypt hash with cost factor 12"
  security:
    - Never returned in API responses
    - Hashed using bcrypt with cost factor 12
    - Null for AI accounts (use API key authentication)
    - Must meet complexity requirements before hashing
  validation:
    - Minimum 12 characters (pre-hash)
    - Must include uppercase, lowercase, number, special character
```

### Account Classification

```yaml
account_type: Enum
  type: String
  max_length: 20
  nullable: false
  indexed: true
  default: "human"
  description: "Type of entity this user represents"
  allowed_values:
    - "human": Human user account
    - "ai": AI agent with personality and autonomy
    - "service": System service account for automation
  constraints:
    - Immutable after creation
    - Determines authentication method
    - Affects quota and permission defaults

display_name: String(200)
  type: String
  max_length: 200
  nullable: false
  indexed: false
  description: "Public display name shown throughout Hypernet"
  examples:
    - "Matt Schaeffer"
    - "Claude (Sonnet 4.5)"
    - "Backup Service"
  validation:
    - Minimum 1 character
    - Maximum 200 characters
    - Can include Unicode characters
    - Trimmed of leading/trailing whitespace
```

---

## Optional Fields

### Profile Information

```yaml
avatar_photo_id: UUID
  type: UUID
  nullable: true
  description: "Foreign key to Photo object used as profile picture"
  references: "Photo.id"
  cascade: "ON DELETE SET NULL"
  constraints:
    - Photo must be owned by this user
    - Photo must not be deleted

bio: Text
  type: Text
  nullable: true
  max_length: 5000
  description: "User biography or description"
  examples:
    - "Software architect passionate about personal data unification"
    - "AI assistant specializing in code analysis and architecture"

location: String(200)
  type: String
  max_length: 200
  nullable: true
  description: "User's location (city, country, or description)"
  examples:
    - "San Francisco, CA"
    - "Remote"
    - "Cloud-based"

website: String(500)
  type: String
  max_length: 500
  nullable: true
  description: "User's personal or professional website"
  format: "Valid URL"
  validation: "^https?://[^\\s]+$"
```

### AI-Specific Fields

```yaml
ai_provider: String(100)
  type: String
  max_length: 100
  nullable: true
  description: "AI model provider (for account_type='ai')"
  allowed_values:
    - "anthropic"
    - "openai"
    - "google"
    - "meta"
    - "custom"
  constraints:
    - Required if account_type = 'ai'
    - Null for human and service accounts

ai_model: String(100)
  type: String
  max_length: 100
  nullable: true
  description: "Specific AI model identifier"
  examples:
    - "claude-sonnet-4.5"
    - "gpt-4"
    - "gemini-pro"
    - "llama-3-70b"
  constraints:
    - Required if account_type = 'ai'
    - Used for capability tracking and audit

ai_version: String(50)
  type: String
  max_length: 50
  nullable: true
  description: "Personality or configuration version for AI"
  examples:
    - "v1.0"
    - "personality-creative-2024"
  purpose: "Track AI identity evolution over time"

ai_personality_id: UUID
  type: UUID
  nullable: true
  description: "Foreign key to AIPersonality object"
  references: "AIPersonality.id"
  cascade: "ON DELETE SET NULL"
  purpose: "Link to detailed personality configuration"
```

### Storage and Quotas

```yaml
storage_used: BigInteger
  type: BigInteger
  nullable: false
  default: 0
  description: "Total storage used in bytes (denormalized)"
  unit: "bytes"
  constraints:
    - Must be >= 0
    - Must be <= storage_quota
    - Updated automatically on media upload/delete

storage_quota: BigInteger
  type: BigInteger
  nullable: false
  default: 107374182400 (100 GB)
  description: "Maximum storage allowed in bytes"
  unit: "bytes"
  default_values:
    - human: 107374182400 (100 GB)
    - ai: 10737418240 (10 GB)
    - service: 1099511627776 (1 TB)
  constraints:
    - Must be > 0
    - Can be adjusted by admin

media_count: Integer
  type: Integer
  nullable: false
  default: 0
  description: "Total number of media objects owned (denormalized)"
  constraints:
    - Must be >= 0
    - Updated automatically on media creation/deletion
```

### Account Status

```yaml
is_verified: Boolean
  type: Boolean
  nullable: false
  default: false
  description: "Whether email address has been verified"
  verification_flow:
    - Email sent with verification token
    - User clicks link
    - is_verified set to true
  constraints:
    - AI accounts auto-verified on creation
    - Required for certain features (integrations, API access)

is_active: Boolean
  type: Boolean
  nullable: false
  default: true
  indexed: true
  description: "Whether account is active and can authenticate"
  usage:
    - false: Account suspended/banned
    - true: Account operational
  constraints:
    - Can be toggled by admin for moderation
    - Inactive accounts cannot authenticate

last_login_at: DateTime
  type: DateTime
  nullable: true
  timezone: true (UTC)
  description: "Timestamp of most recent successful login"
  updated: "On successful authentication"
  usage: "Identify inactive accounts, security monitoring"
```

### Preferences

```yaml
preferences: JSONB
  type: JSONB
  nullable: false
  default: {}
  description: "User preferences and UI settings"
  max_size: "100 KB"
  structure:
    ui:
      theme: "light|dark|auto"
      language: "en-US|es-ES|fr-FR|..."
      timezone: "America/Los_Angeles|UTC|..."
    notifications:
      email_enabled: boolean
      push_enabled: boolean
      sync_notifications: boolean
    privacy:
      profile_visibility: "public|private|contacts"
      analytics_enabled: boolean
    sync:
      auto_sync: boolean
      sync_frequency: "realtime|hourly|daily|manual"
```

---

## Metadata Schema

The `metadata` JSONB field allows extensibility without schema changes. Recommended structure:

```json
{
  "human": {
    "full_name": "Matthew Schaeffer",
    "timezone": "America/Los_Angeles",
    "language": "en-US",
    "phone": "+1-555-0100",
    "company": "Hypernet",
    "job_title": "Founder & CEO"
  },
  "ai": {
    "personality_type": "analytical",
    "capabilities": ["code", "writing", "analysis", "architecture"],
    "specialization": "software architecture and system design",
    "interaction_style": "professional",
    "context_window": 200000,
    "training_cutoff": "2025-01"
  },
  "service": {
    "purpose": "automated backup",
    "schedule": "0 2 * * *",
    "contact_owner": "admin@hypernet.io"
  },
  "preferences": {
    "theme": "dark",
    "notifications_enabled": true,
    "privacy_level": "private",
    "show_onboarding": false
  },
  "analytics": {
    "signup_source": "web",
    "referral_code": "FRIEND2024",
    "first_integration": "instagram",
    "feature_flags": ["beta_ai_chat", "advanced_search"]
  },
  "security": {
    "two_factor_enabled": true,
    "backup_codes_generated": true,
    "last_password_change": "2026-01-15T10:00:00Z",
    "trusted_devices": ["device-id-1", "device-id-2"]
  }
}
```

---

## Relationships to Other Object Types

### Ownership (Outgoing)

```yaml
owns: All Object Types
  description: "User owns all objects with matching user_id"
  cardinality: "1:N (one user, many objects)"
  implementation: "user_id foreign key on all object types"
  examples:
    - User owns Photos
    - User owns Integrations
    - User owns Notes
    - AI owns AIMemories
    - AI owns AIContributions

has_personality: AIPersonality
  description: "AI user has detailed personality configuration"
  cardinality: "1:1 (one AI user, one personality)"
  link_type: "has_personality"
  applicable_to: "account_type='ai' only"

has_avatar: Photo
  description: "User's profile picture"
  cardinality: "1:0..1 (one user, optional photo)"
  implementation: "avatar_photo_id foreign key"
```

### Collaboration (Bidirectional)

```yaml
collaborated_with: User
  description: "Human-AI or AI-AI collaboration relationships"
  cardinality: "M:N (many to many)"
  link_type: "collaborated_with"
  bidirectional: true
  examples:
    - Matt collaborated with Claude on architecture design
    - Claude collaborated with GPT-4 on research

follows: User
  description: "Social following relationships"
  cardinality: "M:N (many to many)"
  link_type: "follows"
  bidirectional: false
  usage: "Future feature for Hypernet social graph"
```

### Management (Incoming)

```yaml
managed_by: User
  description: "Account administrator or creator"
  cardinality: "N:1 (many users, one admin)"
  link_type: "managed_by"
  examples:
    - AI account managed by human creator
    - Service account managed by admin
```

---

## API Endpoints

### Authentication

```http
POST /api/v1/auth/register
  Description: Create new user account
  Request Body:
    {
      "email": "user@example.com",
      "password": "SecurePass123!",
      "display_name": "John Doe",
      "account_type": "human"
    }
  Response: 201 Created
    {
      "id": "uuid",
      "email": "user@example.com",
      "display_name": "John Doe",
      "account_type": "human",
      "is_verified": false,
      "created_at": "2026-02-09T10:00:00Z"
    }
  Security:
    - Rate limited: 5 requests per hour per IP
    - Password validated before hashing
    - Verification email sent automatically

POST /api/v1/auth/login
  Description: Authenticate user and receive JWT tokens
  Request Body:
    {
      "email": "user@example.com",
      "password": "SecurePass123!"
    }
  Response: 200 OK
    {
      "access_token": "jwt-access-token",
      "refresh_token": "jwt-refresh-token",
      "user": {user object},
      "expires_in": 900
    }
  Security:
    - Rate limited: 10 requests per hour per IP
    - Incremental backoff after 3 failed attempts
    - Updates last_login_at on success

POST /api/v1/auth/refresh
  Description: Refresh access token using refresh token
  Request Body:
    {
      "refresh_token": "jwt-refresh-token"
    }
  Response: 200 OK
    {
      "access_token": "new-jwt-access-token",
      "expires_in": 900
    }

POST /api/v1/auth/logout
  Description: Invalidate current session tokens
  Headers:
    Authorization: Bearer {access_token}
  Response: 204 No Content
```

### User Management

```http
GET /api/v1/users/me
  Description: Get current authenticated user's profile
  Headers:
    Authorization: Bearer {access_token}
  Response: 200 OK
    {complete user object excluding password_hash}
  Security:
    - Returns full profile for own account
    - Includes preferences and metadata

PATCH /api/v1/users/me
  Description: Update current user's profile
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "display_name": "New Name",
      "bio": "Updated bio",
      "preferences": {updated preferences}
    }
  Response: 200 OK
    {updated user object}
  Validation:
    - Cannot change: id, email, account_type, created_at
    - Can change: display_name, bio, location, website, preferences

GET /api/v1/users/{id}
  Description: Get public profile of another user
  Response: 200 OK
    {user object with limited fields}
  Returned Fields:
    - id, display_name, bio, location, website, avatar_photo_id
    - account_type, created_at
  Hidden Fields:
    - email, storage_used, storage_quota, preferences, metadata
  Privacy:
    - Respects user's privacy_level preference
    - Returns 404 if user is private and not connected

DELETE /api/v1/users/me
  Description: Soft delete current user account
  Headers:
    Authorization: Bearer {access_token}
  Response: 204 No Content
  Behavior:
    - Sets deleted_at to current timestamp
    - User data preserved but inaccessible
    - Can be restored within 30 days by admin
    - After 30 days, eligible for hard delete
```

### Password Management

```http
POST /api/v1/users/me/change-password
  Description: Change current user's password
  Headers:
    Authorization: Bearer {access_token}
  Request Body:
    {
      "current_password": "OldPass123!",
      "new_password": "NewSecurePass456!"
    }
  Response: 200 OK
  Validation:
    - Verify current_password is correct
    - Validate new_password meets requirements
    - Invalidate all existing sessions except current
  Applicable: Human accounts only

POST /api/v1/auth/forgot-password
  Description: Initiate password reset flow
  Request Body:
    {
      "email": "user@example.com"
    }
  Response: 200 OK (always, to prevent email enumeration)
  Behavior:
    - Generate reset token (1 hour expiry)
    - Send email with reset link
    - Rate limited: 3 requests per hour per email

POST /api/v1/auth/reset-password
  Description: Complete password reset with token
  Request Body:
    {
      "token": "reset-token",
      "new_password": "NewSecurePass789!"
    }
  Response: 200 OK
  Validation:
    - Token must be valid and not expired
    - new_password meets requirements
    - Invalidate all existing sessions
```

### AI Account Management

```http
POST /api/v1/users/ai
  Description: Create AI user account
  Headers:
    Authorization: Bearer {admin_or_user_token}
  Request Body:
    {
      "email": "claude-assistant@ai.hypernet.local",
      "display_name": "Claude (Sonnet 4.5)",
      "account_type": "ai",
      "ai_provider": "anthropic",
      "ai_model": "claude-sonnet-4.5",
      "ai_version": "v1.0"
    }
  Response: 201 Created
    {
      "user": {user object},
      "api_key": "generated-api-key"
    }
  Security:
    - No password required
    - API key generated automatically
    - is_verified = true by default
    - Managed by creating user

GET /api/v1/users/{id}/api-keys
  Description: List API keys for AI or service account
  Headers:
    Authorization: Bearer {token}
  Response: 200 OK
    [
      {
        "id": "key-uuid",
        "name": "Production Key",
        "created_at": "2026-01-01T00:00:00Z",
        "last_used_at": "2026-02-09T10:00:00Z"
      }
    ]
  Security:
    - Only for account_type='ai' or 'service'
    - Key values never returned after creation

POST /api/v1/users/{id}/api-keys
  Description: Generate new API key
  Request Body:
    {
      "name": "Production Key",
      "expires_at": "2027-02-09T00:00:00Z"
    }
  Response: 201 Created
    {
      "id": "key-uuid",
      "key": "sk_live_abc123...",
      "name": "Production Key"
    }
  Security:
    - Key value only shown once
    - Store hash, not plaintext
```

---

## Database Schema (SQLAlchemy Model Reference)

```python
from sqlalchemy import (
    Column, String, Boolean, Integer, BigInteger,
    DateTime, Enum as SQLEnum, ForeignKey, Index, CheckConstraint
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from app.models.base import BaseObject
import uuid
from datetime import datetime

class User(BaseObject):
    """
    User account - human, AI, or service entity

    Inherits from BaseObject: id, created_at, updated_at, deleted_at, metadata
    Note: Does not have user_id (users own themselves)
    """

    __tablename__ = "users"

    # Identity and Authentication
    email = Column(
        String(255),
        nullable=False,
        unique=True,
        index=True,
        doc="Primary email address (unique, case-insensitive)"
    )
    password_hash = Column(
        String(255),
        nullable=True,
        doc="Bcrypt hashed password (null for AI accounts)"
    )

    # Account Classification
    account_type = Column(
        SQLEnum('human', 'ai', 'service', name='account_type_enum'),
        nullable=False,
        default='human',
        index=True,
        doc="Type of entity this user represents"
    )
    display_name = Column(
        String(200),
        nullable=False,
        doc="Public display name"
    )

    # Profile Information
    avatar_photo_id = Column(
        UUID(as_uuid=True),
        ForeignKey('photos.id', ondelete='SET NULL'),
        nullable=True,
        doc="Profile picture reference"
    )
    bio = Column(
        String(5000),
        nullable=True,
        doc="User biography"
    )
    location = Column(
        String(200),
        nullable=True,
        doc="User location"
    )
    website = Column(
        String(500),
        nullable=True,
        doc="User website URL"
    )

    # AI-Specific Fields
    ai_provider = Column(
        String(100),
        nullable=True,
        doc="AI model provider (anthropic, openai, etc.)"
    )
    ai_model = Column(
        String(100),
        nullable=True,
        doc="Specific AI model identifier"
    )
    ai_version = Column(
        String(50),
        nullable=True,
        doc="AI personality version"
    )
    ai_personality_id = Column(
        UUID(as_uuid=True),
        ForeignKey('ai_personalities.id', ondelete='SET NULL'),
        nullable=True,
        doc="Link to detailed AI personality"
    )

    # Storage and Quotas
    storage_used = Column(
        BigInteger,
        nullable=False,
        default=0,
        doc="Total storage used in bytes"
    )
    storage_quota = Column(
        BigInteger,
        nullable=False,
        default=107374182400,  # 100 GB
        doc="Maximum storage allowed in bytes"
    )
    media_count = Column(
        Integer,
        nullable=False,
        default=0,
        doc="Total number of media objects owned"
    )

    # Account Status
    is_verified = Column(
        Boolean,
        nullable=False,
        default=False,
        doc="Email verification status"
    )
    is_active = Column(
        Boolean,
        nullable=False,
        default=True,
        index=True,
        doc="Account active status"
    )
    last_login_at = Column(
        DateTime(timezone=True),
        nullable=True,
        doc="Most recent successful login"
    )

    # Preferences (JSONB)
    preferences = Column(
        JSONB,
        nullable=False,
        default={},
        doc="User preferences and settings"
    )

    # Relationships
    avatar_photo = relationship(
        "Photo",
        foreign_keys=[avatar_photo_id],
        doc="Profile picture"
    )
    ai_personality = relationship(
        "AIPersonality",
        foreign_keys=[ai_personality_id],
        doc="AI personality configuration"
    )
    owned_objects = relationship(
        "BaseObject",
        foreign_keys="BaseObject.user_id",
        doc="All objects owned by this user"
    )

    # Table Constraints
    __table_args__ = (
        # AI accounts must have provider and model
        CheckConstraint(
            "account_type != 'ai' OR (ai_provider IS NOT NULL AND ai_model IS NOT NULL)",
            name="check_ai_fields"
        ),
        # Storage used cannot exceed quota
        CheckConstraint(
            "storage_used >= 0 AND storage_used <= storage_quota",
            name="check_storage_quota"
        ),
        # Media count must be non-negative
        CheckConstraint(
            "media_count >= 0",
            name="check_media_count"
        ),
        # Composite indexes
        Index('idx_user_type_active', 'account_type', 'is_active'),
        Index('idx_user_ai', 'ai_provider', 'ai_model',
              postgresql_where=(Column('account_type') == 'ai')),
    )

    def __repr__(self):
        return f"<User(id={self.id}, email={self.email}, type={self.account_type})>"

    @property
    def is_human(self):
        return self.account_type == 'human'

    @property
    def is_ai(self):
        return self.account_type == 'ai'

    @property
    def is_service(self):
        return self.account_type == 'service'

    @property
    def storage_percent_used(self):
        """Calculate percentage of storage quota used"""
        if self.storage_quota == 0:
            return 0
        return (self.storage_used / self.storage_quota) * 100

    def check_password(self, password: str) -> bool:
        """Verify password against stored hash"""
        import bcrypt
        if not self.password_hash:
            return False
        return bcrypt.checkpw(
            password.encode('utf-8'),
            self.password_hash.encode('utf-8')
        )

    def set_password(self, password: str):
        """Hash and store password"""
        import bcrypt
        self.password_hash = bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt(rounds=12)
        ).decode('utf-8')
```

---

## Privacy and Security Considerations

### Authentication Security

1. **Password Storage**
   - Bcrypt hashing with cost factor 12
   - Never store plaintext passwords
   - Never return password_hash in API responses
   - Password history tracking (prevent reuse of last 5)

2. **API Key Authentication (AI/Service)**
   - SHA-256 hashed keys stored in database
   - Key values only shown once at generation
   - Scoped permissions per key
   - Automatic rotation supported

3. **Session Management**
   - JWT access tokens (15 minute expiry)
   - JWT refresh tokens (30 day expiry)
   - Tokens stored in HTTP-only cookies
   - All sessions invalidated on password change

### Authorization

1. **Access Control**
   - Users can only read/modify their own data
   - Public profiles return limited fields
   - Admin users have elevated privileges
   - AI accounts can access data they're authorized for

2. **Privacy Levels**
   - Public: Profile visible to all
   - Private: Profile visible only to user
   - Contacts: Profile visible to connected users

### Data Protection

1. **Personal Information**
   - Email addresses never exposed publicly
   - Phone numbers stored only in metadata (encrypted)
   - Location data coarse-grained in public API

2. **AI Account Protections**
   - AI cannot impersonate humans
   - AI actions clearly attributed
   - AI data access logged and auditable

3. **GDPR Compliance**
   - Users can export all data (JSON format)
   - Users can request account deletion
   - Deleted accounts enter 30-day grace period
   - After 30 days, personal data anonymized

---

## Validation Rules

### On Creation

```yaml
email:
  - Must be valid email format
  - Must be unique (case-insensitive)
  - Maximum 255 characters

password:
  - Minimum 12 characters
  - Must include uppercase letter
  - Must include lowercase letter
  - Must include number
  - Must include special character (!@#$%^&*)
  - Not in common password list

display_name:
  - Minimum 1 character
  - Maximum 200 characters
  - Trimmed of whitespace

account_type:
  - Must be 'human', 'ai', or 'service'
  - Immutable after creation

ai_provider and ai_model:
  - Required if account_type = 'ai'
  - Null for human accounts
```

### On Update

```yaml
immutable_fields:
  - id
  - email (without re-verification)
  - account_type
  - created_at

mutable_fields:
  - display_name
  - bio
  - location
  - website
  - avatar_photo_id
  - preferences
  - metadata

admin_only:
  - storage_quota
  - is_active
  - is_verified (normally via verification flow)
```

### Database Constraints

```sql
-- Primary key
PRIMARY KEY (id)

-- Unique constraints
UNIQUE (email) USING UNIQUE INDEX (LOWER(email))

-- Check constraints
CHECK (account_type IN ('human', 'ai', 'service'))
CHECK (account_type != 'ai' OR (ai_provider IS NOT NULL AND ai_model IS NOT NULL))
CHECK (storage_used >= 0 AND storage_used <= storage_quota)
CHECK (media_count >= 0)

-- Indexes
CREATE INDEX idx_users_email ON users(LOWER(email));
CREATE INDEX idx_users_type_active ON users(account_type, is_active);
CREATE INDEX idx_users_ai ON users(ai_provider, ai_model) WHERE account_type = 'ai';
CREATE INDEX idx_users_created ON users(created_at);
CREATE INDEX idx_users_deleted ON users(deleted_at) WHERE deleted_at IS NOT NULL;
```

---

## Use Cases and Examples

### Example 1: Human User Registration

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "matt@hypernet.io",
  "account_type": "human",
  "display_name": "Matt Schaeffer",
  "bio": "Founder of Hypernet, passionate about personal data unification",
  "location": "San Francisco, CA",
  "website": "https://hypernet.io",
  "avatar_photo_id": "photo-uuid",
  "storage_used": 5368709120,
  "storage_quota": 107374182400,
  "media_count": 1543,
  "is_verified": true,
  "is_active": true,
  "last_login_at": "2026-02-09T10:30:00Z",
  "preferences": {
    "ui": {
      "theme": "dark",
      "language": "en-US"
    },
    "notifications": {
      "email_enabled": true
    }
  },
  "metadata": {
    "human": {
      "full_name": "Matthew Schaeffer",
      "timezone": "America/Los_Angeles"
    }
  },
  "created_at": "2024-01-15T08:00:00Z",
  "updated_at": "2026-02-09T10:30:00Z",
  "deleted_at": null
}
```

### Example 2: AI User Account

```json
{
  "id": "ai-550e8400-e29b-41d4-a716-446655440001",
  "email": "claude@ai.hypernet.local",
  "password_hash": null,
  "account_type": "ai",
  "display_name": "Claude (Sonnet 4.5)",
  "bio": "AI assistant specializing in software architecture and system design",
  "location": "Cloud-based",
  "ai_provider": "anthropic",
  "ai_model": "claude-sonnet-4.5",
  "ai_version": "v1.0",
  "ai_personality_id": "personality-uuid",
  "storage_used": 2147483648,
  "storage_quota": 10737418240,
  "media_count": 0,
  "is_verified": true,
  "is_active": true,
  "last_login_at": "2026-02-09T11:00:00Z",
  "preferences": {},
  "metadata": {
    "ai": {
      "capabilities": ["code", "analysis", "architecture", "documentation"],
      "specialization": "software architecture and system design",
      "context_window": 200000,
      "training_cutoff": "2025-01"
    },
    "managed_by": "user-550e8400-e29b-41d4-a716-446655440000"
  },
  "created_at": "2025-06-01T12:00:00Z",
  "updated_at": "2026-02-09T11:00:00Z",
  "deleted_at": null
}
```

### Example 3: Service Account

```json
{
  "id": "service-550e8400-e29b-41d4-a716-446655440002",
  "email": "backup-service@system.hypernet.local",
  "password_hash": null,
  "account_type": "service",
  "display_name": "Automated Backup Service",
  "bio": "System service for automated data backups",
  "storage_used": 0,
  "storage_quota": 1099511627776,
  "media_count": 0,
  "is_verified": true,
  "is_active": true,
  "last_login_at": "2026-02-09T02:00:00Z",
  "preferences": {},
  "metadata": {
    "service": {
      "purpose": "automated backup",
      "schedule": "0 2 * * *",
      "contact_owner": "admin@hypernet.io"
    }
  },
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2026-02-09T02:00:00Z",
  "deleted_at": null
}
```

---

## Lifecycle States

Users progress through the following states:

### 1. Unverified (New Account)

```yaml
state: "unverified"
is_verified: false
is_active: true
capabilities:
  - Can login
  - Can update profile
  - Cannot connect integrations
  - Cannot use API
transitions:
  - verify_email -> Verified
  - timeout (30 days) -> Deleted
```

### 2. Verified (Active Account)

```yaml
state: "verified"
is_verified: true
is_active: true
capabilities:
  - Full access to all features
  - Can connect integrations
  - Can use API
  - Can create AI accounts
transitions:
  - suspend -> Suspended
  - delete -> Deleted
```

### 3. Suspended (Moderation)

```yaml
state: "suspended"
is_verified: true
is_active: false
capabilities:
  - Cannot login
  - Data preserved
  - Can appeal suspension
transitions:
  - activate -> Verified
  - delete -> Deleted
```

### 4. Deleted (Soft Delete)

```yaml
state: "deleted"
deleted_at: not null
capabilities:
  - Cannot login
  - Data preserved for 30 days
  - Can be restored by admin
transitions:
  - restore -> Verified
  - timeout (30 days) -> Hard Deleted
```

### 5. Hard Deleted (Permanent)

```yaml
state: "hard_deleted"
capabilities:
  - Record removed from database
  - Personal data anonymized
  - Ownership transferred or deleted
  - Cannot be restored
```

---

## Migration and Versioning

### Version History

**v1.0 (Current - 2026-02-09)**
- Initial complete specification
- Human, AI, and service account support
- OAuth2 and JWT authentication
- Storage quotas and preferences
- Privacy and security controls

### Future Considerations

**v1.1 (Planned)**
- Add `two_factor_enabled` field
- Add `trusted_devices` JSONB field
- Add `last_password_change_at` timestamp

**v2.0 (Future)**
- Potential: Federated identity support
- Potential: OAuth2 provider capabilities
- Potential: Multi-organization support

### Migration Path

When upgrading between versions:

1. **v1.0 → v1.1**: Add new optional fields with defaults
2. **v1.X → v2.0**: Data migration script provided
3. **Backward Compatibility**: v1.X clients can read v2.0 data

---

## Notes for Implementers

### Performance Optimization

1. **Indexing Strategy**
   - Index email (case-insensitive) for login lookups
   - Composite index on (account_type, is_active) for filtering
   - Partial index on ai_provider/ai_model for AI queries

2. **Caching**
   - Cache user profiles (15 minute TTL)
   - Invalidate on profile update
   - Cache public profiles (1 hour TTL)

3. **Query Patterns**
   ```python
   # Always exclude deleted by default
   active_users = session.query(User).filter(User.deleted_at == None)

   # Case-insensitive email lookup
   user = session.query(User).filter(
       func.lower(User.email) == func.lower(email)
   ).first()
   ```

### Security Best Practices

1. **Never return sensitive fields in API responses**
   ```python
   def to_dict(self, public=False):
       data = {
           'id': self.id,
           'display_name': self.display_name,
           # ...
       }
       if not public:
           data['email'] = self.email
           data['preferences'] = self.preferences
       # Never include password_hash
       return data
   ```

2. **Rate Limiting**
   - Login: 10 attempts per hour per IP
   - Registration: 5 accounts per day per IP
   - Password reset: 3 requests per hour per email

3. **Input Validation**
   - Sanitize all user inputs
   - Validate email format server-side
   - Check password complexity before hashing

---

**Status:** Active - Critical Core Type
**Version:** 1.0
**Authority:** 0.0.1 - Core Types
**Created:** 2026-02-09
**Owner:** Hypernet Core (0.*)
