---
ha: "0.4.0.1.2"
object_type: "document"
creator: "1.1"
created: "2026-02-09"
status: "active"
visibility: "public"
flags: ["registry"]
---

# INTEGRATION - External Service Connection Object Type

**Type ID:** `hypernet.core.integration`
**Version:** 1.0
**Category:** 0.0.1 - Core Types
**Parent:** BaseObject
**Status:** Active - Phase 1 Priority
**Created:** 2026-02-09
**Last Updated:** 2026-02-09

---

## Object Type Metadata

```yaml
type_name: "Integration"
type_id: "hypernet.core.integration"
version: "1.0"
parent_type: "BaseObject"
category: "0.0.1 - Core Types"
abstract: false
instantiable: true
```

---

## Purpose and Description

### What is an Integration?

An Integration represents a connection between a Hypernet user and an external service (Instagram, Google Photos, Gmail, Dropbox, etc.). It manages OAuth2 authentication, token lifecycle, sync state, and serves as the source attribution for all data imported from external platforms.

### Core Functions

1. **Authentication Management** - Store and refresh OAuth2 tokens for external services
2. **Sync State Tracking** - Monitor sync progress, cursors, and status
3. **Source Attribution** - Link imported objects back to their origin
4. **Configuration Storage** - User preferences for sync behavior
5. **Error Handling** - Track and report integration failures

### Why This Matters

Integrations are central to Hypernet's data unification vision. They enable:
- Automatic import of photos from Instagram, Google Photos, iCloud
- Email sync from Gmail, Outlook
- Document sync from Dropbox, Google Drive
- Social media post archival from Facebook, Twitter
- Calendar sync from Google Calendar, Outlook

Without Integrations, Hypernet would be limited to manually uploaded data. With Integrations, Hypernet becomes the universal personal data hub that automatically stays synchronized with your digital life.

### When to Use

- User connects their Instagram account to import photos
- Syncing Google Photos library to Hypernet
- Importing email archives from Gmail
- Backing up Dropbox files
- Any scenario requiring external data source connection

---

## Inherited Fields from BaseObject

```yaml
id: UUID
  - Unique integration identifier

user_id: UUID
  - Owner of this integration
  - User who authorized the connection

created_at: DateTime
  - When integration was first connected

updated_at: DateTime
  - Last modification timestamp
  - Updated on token refresh, sync, or settings change

deleted_at: DateTime (nullable)
  - Soft delete timestamp for disconnected integrations
  - Preserves historical sync data

source_type: String
  - Always "integration"

source_id: String
  - External service identifier (optional)

metadata: JSONB
  - Service-specific configuration and statistics
```

---

## Required Fields

### Integration Identity

```yaml
integration_type: String(50)
  type: String
  max_length: 50
  nullable: false
  indexed: true
  description: "Type of external service"
  allowed_values:
    # Social Media
    - "instagram"
    - "facebook"
    - "twitter"
    - "linkedin"
    - "tiktok"
    # Photo Services
    - "google_photos"
    - "icloud_photos"
    - "flickr"
    - "smugmug"
    # Cloud Storage
    - "dropbox"
    - "google_drive"
    - "onedrive"
    - "box"
    # Email
    - "gmail"
    - "outlook"
    - "imap"
    # Productivity
    - "google_calendar"
    - "outlook_calendar"
    - "notion"
    - "evernote"
    # Other
    - "spotify"
    - "fitbit"
    - "apple_health"
  validation:
    - Must be lowercase
    - Must match supported integration types
  usage:
    - Determines OAuth2 provider configuration
    - Routes sync tasks to correct handler

integration_name: String(200)
  type: String
  max_length: 200
  nullable: false
  description: "User-friendly name for this integration"
  examples:
    - "My Instagram"
    - "Work Gmail"
    - "Personal Google Photos"
    - "Family Dropbox"
  default: "{integration_type} Account"
  purpose: "Allow users to distinguish between multiple accounts of same type"
  validation:
    - Minimum 1 character
    - Maximum 200 characters
```

### Integration Status

```yaml
status: Enum
  type: String
  max_length: 20
  nullable: false
  indexed: true
  default: "pending"
  description: "Current state of integration"
  allowed_values:
    - "pending": OAuth flow initiated but not completed
    - "connected": Active and authenticated
    - "disconnected": User manually disconnected
    - "error": Authentication or sync error
    - "expired": OAuth token expired and refresh failed
  transitions:
    pending -> connected: OAuth flow completed
    connected -> disconnected: User disconnects
    connected -> error: Sync or auth failure
    connected -> expired: Token refresh failed
    error -> connected: Manual reconnection
    expired -> connected: Token refreshed
  constraints:
    - Default on creation is "pending"
    - "connected" required for syncing
```

---

## Optional Fields

### OAuth2 Token Management

```yaml
token_expires_at: DateTime
  type: DateTime
  nullable: true
  timezone: true (UTC)
  description: "When the current access token expires"
  purpose: "Trigger automatic token refresh before expiration"
  notes:
    - Null if token doesn't expire (rare)
    - Used by background job to refresh tokens proactively
    - Typically 1-2 hours from token issuance
  examples:
    - "2026-02-09T13:00:00Z"

last_token_refresh_at: DateTime
  type: DateTime
  nullable: true
  timezone: true (UTC)
  description: "When token was last successfully refreshed"
  purpose: "Audit trail and refresh frequency monitoring"
```

### Sync State Tracking

```yaml
last_sync_at: DateTime
  type: DateTime
  nullable: true
  timezone: true (UTC)
  description: "Timestamp of most recent sync attempt"
  updated: "On every sync start"
  usage:
    - Display last sync time to user
    - Calculate time since last sync
    - Trigger overdue sync alerts

last_sync_status: Enum
  type: String
  max_length: 20
  nullable: true
  description: "Result of most recent sync"
  allowed_values:
    - "success": Sync completed without errors
    - "partial": Some items synced, some failed
    - "failed": Sync completely failed
  examples:
    - "success": 150 new photos imported
    - "partial": 145 photos imported, 5 failed (quota exceeded)
    - "failed": Authentication error

last_sync_error: Text
  type: Text
  nullable: true
  description: "Error message from most recent failed sync"
  examples:
    - "Rate limit exceeded (429)"
    - "Token expired"
    - "Insufficient permissions"
  purpose: "Debugging and user error reporting"

sync_cursor: Text
  type: Text
  nullable: true
  description: "Pagination cursor for incremental sync"
  format: "Platform-specific string"
  examples:
    - Instagram: "AQHWyNw..."
    - Dropbox: "AAF1xDnKw..."
    - Gmail: "page_token_xyz"
  purpose: "Resume sync from where we left off"
  notes:
    - Null for initial sync
    - Updated after each successful page
    - Platform-specific format

items_synced: Integer
  type: Integer
  nullable: false
  default: 0
  description: "Total number of items successfully imported"
  constraints:
    - Must be >= 0
  updated: "Incremented after each successful item import"
  purpose: "Show user sync progress and statistics"

items_failed: Integer
  type: Integer
  nullable: false
  default: 0
  description: "Total number of items that failed to import"
  constraints:
    - Must be >= 0
  purpose: "Track sync quality and errors"
```

### Configuration

```yaml
is_enabled: Boolean
  type: Boolean
  nullable: false
  default: true
  indexed: true
  description: "Whether automatic syncing is enabled"
  usage:
    - User can pause sync without disconnecting
    - Useful for temporary bandwidth limitations
    - Background jobs skip disabled integrations
  transitions:
    - User toggles in settings
    - Admin can disable for all users (maintenance)

auto_sync: Boolean
  type: Boolean
  nullable: false
  default: true
  description: "Whether to automatically trigger periodic syncs"
  usage:
    - true: Background job syncs on schedule
    - false: Sync only on manual trigger

sync_frequency: Enum
  type: String
  max_length: 20
  nullable: false
  default: "hourly"
  description: "How often to automatically sync"
  allowed_values:
    - "realtime": Webhook-based (if supported)
    - "every_15min": Every 15 minutes
    - "hourly": Once per hour
    - "daily": Once per day at midnight
    - "weekly": Once per week
    - "manual": Only on user request
  notes:
    - Actual frequency may be rate-limited by provider
    - "realtime" requires webhook support from provider
```

---

## Metadata Schema

The `metadata` JSONB field stores service-specific data and statistics:

```json
{
  "oauth": {
    "access_token_hash": "sha256-hash",
    "refresh_token_hash": "sha256-hash",
    "scope": ["read_photos", "read_user"],
    "token_type": "Bearer"
  },
  "service": {
    "instagram": {
      "user_id": "17841405793187218",
      "username": "user123",
      "profile_picture_url": "https://...",
      "account_type": "personal|business",
      "followers_count": 1543,
      "media_count": 892
    },
    "google": {
      "email": "user@gmail.com",
      "name": "John Doe",
      "picture": "https://...",
      "locale": "en"
    },
    "dropbox": {
      "account_id": "dbid:AAH4f99...",
      "email": "user@example.com",
      "display_name": "John Doe",
      "quota": {
        "used": 5368709120,
        "allocated": 107374182400
      }
    }
  },
  "sync_config": {
    "import_likes": true,
    "import_comments": true,
    "import_stories": false,
    "download_originals": true,
    "create_albums": true,
    "ignore_before": "2020-01-01T00:00:00Z"
  },
  "statistics": {
    "total_items": 1543,
    "photos_synced": 1456,
    "videos_synced": 87,
    "documents_synced": 0,
    "total_bytes": 8589934592,
    "sync_duration_seconds": 320,
    "items_per_second": 4.8,
    "first_sync_at": "2024-01-15T10:00:00Z",
    "last_successful_sync_at": "2026-02-09T10:00:00Z"
  },
  "error_history": [
    {
      "timestamp": "2026-02-08T15:30:00Z",
      "error": "Rate limit exceeded",
      "code": "429",
      "resolved": true
    }
  ],
  "webhooks": {
    "enabled": true,
    "subscription_id": "sub_abc123",
    "verified_at": "2024-01-15T10:05:00Z"
  }
}
```

---

## Relationships to Other Object Types

### Ownership (Incoming)

```yaml
owned_by: User
  description: "User who authorized this integration"
  cardinality: "N:1 (many integrations, one user)"
  implementation: "user_id foreign key"
  constraints:
    - User must exist
    - User must be verified (is_verified=true)
    - Multiple integrations of same type allowed per user
  examples:
    - User has "Personal Instagram" and "Business Instagram"
    - User has "Work Gmail" and "Personal Gmail"
```

### Source Attribution (Outgoing)

```yaml
sources: Media Objects
  description: "All media imported from this integration"
  cardinality: "1:N (one integration, many media)"
  link_type: "source"
  implementation: "Link object with link_type='source'"
  query_pattern:
    from_object_id: media.id
    to_object_id: integration.id
    link_type: "source"
  examples:
    - Photo sourced from Instagram integration
    - Video sourced from Google Photos integration
    - Document sourced from Dropbox integration
  purpose:
    - Track where data came from
    - Handle duplicate detection
    - Resync specific integration's data
```

---

## API Endpoints

### OAuth2 Flow

```http
GET /api/v1/integrations/oauth/start
  Description: Initiate OAuth2 flow for external service
  Query Parameters:
    type: string (required) - integration_type
    name: string (optional) - custom integration_name
    redirect_uri: string (optional) - custom callback URL
  Process:
    1. Create Integration record (status="pending")
    2. Generate OAuth2 state token (CSRF protection)
    3. Build authorization URL with required scopes
    4. Redirect user to external service
  Response: 302 Redirect
    Location: https://instagram.com/oauth/authorize?client_id=...&state=...
  Security:
    - State token stored in session
    - PKCE challenge generated for supported providers
    - Rate limited: 10 requests per hour per user

GET /api/v1/integrations/oauth/callback
  Description: Complete OAuth2 flow after user authorization
  Query Parameters:
    code: string (required) - OAuth2 authorization code
    state: string (required) - CSRF protection token
    error: string (optional) - OAuth2 error if user denied
  Process:
    1. Verify state token matches session
    2. Exchange code for access_token and refresh_token
    3. Fetch user profile from external service
    4. Update Integration record (status="connected")
    5. Store tokens securely (hashed)
    6. Trigger initial sync job
  Response: 302 Redirect
    Location: /integrations/{id}?success=true
  Error Handling:
    - Invalid state: 400 Bad Request
    - Token exchange failure: 502 Bad Gateway
    - User denied: Redirect with error message
```

### Management

```http
GET /api/v1/integrations
  Description: List all integrations for authenticated user
  Query Parameters:
    status: string (optional) - filter by status
    integration_type: string (optional) - filter by type
    is_enabled: boolean (optional) - filter by enabled state
    include_deleted: boolean (optional) - include soft-deleted
  Response: 200 OK
    {
      "items": [
        {integration object},
        {integration object}
      ],
      "total": 5
    }
  Security:
    - Only returns integrations owned by authenticated user
    - Token hashes never included in response

GET /api/v1/integrations/{id}
  Description: Get single integration details
  Path Parameters:
    id: UUID (required) - integration ID
  Response: 200 OK
    {integration object with full details}
  Security:
    - User must own integration
    - Tokens never returned

PATCH /api/v1/integrations/{id}
  Description: Update integration settings
  Path Parameters:
    id: UUID (required) - integration ID
  Request Body:
    {
      "integration_name": "New Name",
      "is_enabled": false,
      "auto_sync": true,
      "sync_frequency": "daily",
      "metadata": {
        "sync_config": {...}
      }
    }
  Response: 200 OK
    {updated integration object}
  Validation:
    - Cannot change: id, user_id, integration_type, created_at
    - Can change: name, enabled state, sync settings
  Security:
    - User must own integration

DELETE /api/v1/integrations/{id}
  Description: Disconnect integration (soft delete)
  Path Parameters:
    id: UUID (required) - integration ID
  Query Parameters:
    delete_data: boolean (optional) - also delete imported data
  Process:
    1. Set deleted_at timestamp
    2. Set status="disconnected"
    3. Revoke OAuth tokens at provider (if supported)
    4. Optionally delete all imported media
  Response: 204 No Content
  Security:
    - User must own integration
    - Confirmation required if delete_data=true
```

### Sync Operations

```http
POST /api/v1/integrations/{id}/sync
  Description: Trigger manual sync
  Path Parameters:
    id: UUID (required) - integration ID
  Request Body (optional):
    {
      "full_sync": false,
      "reset_cursor": false
    }
  Process:
    1. Verify integration is connected and enabled
    2. Check rate limits
    3. Queue sync job
    4. Return job ID for status tracking
  Response: 202 Accepted
    {
      "job_id": "job-uuid",
      "status": "queued",
      "estimated_duration": 300
    }
  Errors:
    - Integration not connected: 400 Bad Request
    - Rate limited: 429 Too Many Requests
    - Sync already in progress: 409 Conflict
  Security:
    - User must own integration
    - Rate limited: 1 manual sync per 5 minutes per integration

GET /api/v1/integrations/{id}/sync-status
  Description: Get current sync status
  Path Parameters:
    id: UUID (required) - integration ID
  Response: 200 OK
    {
      "is_syncing": true,
      "current_job_id": "job-uuid",
      "progress": {
        "items_processed": 150,
        "total_items": 1000,
        "percent_complete": 15
      },
      "last_sync_at": "2026-02-09T10:00:00Z",
      "last_sync_status": "success",
      "items_synced": 10543,
      "items_failed": 12
    }

GET /api/v1/integrations/{id}/history
  Description: Get sync history
  Path Parameters:
    id: UUID (required) - integration ID
  Query Parameters:
    limit: integer (default 50, max 100)
    offset: integer (default 0)
  Response: 200 OK
    {
      "items": [
        {
          "timestamp": "2026-02-09T10:00:00Z",
          "status": "success",
          "items_synced": 25,
          "duration_seconds": 45
        }
      ],
      "total": 150
    }
```

### Token Management (Admin Only)

```http
POST /api/v1/integrations/{id}/refresh-token
  Description: Manually refresh OAuth token
  Headers:
    Authorization: Bearer {admin_token}
  Response: 200 OK
    {
      "token_refreshed": true,
      "expires_at": "2026-02-09T13:00:00Z"
    }

POST /api/v1/integrations/{id}/reconnect
  Description: Re-initiate OAuth flow for existing integration
  Process:
    1. Preserve integration_name and metadata
    2. Start OAuth flow
    3. Update existing integration on callback
  Response: 302 Redirect
    Location: https://service.com/oauth/authorize...
```

---

## Database Schema (SQLAlchemy Model Reference)

```python
from sqlalchemy import (
    Column, String, Boolean, Integer, Text,
    DateTime, Enum as SQLEnum, ForeignKey, Index, CheckConstraint
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from app.models.base import BaseObject
from datetime import datetime

class Integration(BaseObject):
    """
    External service connection with OAuth2 and sync management

    Inherits from BaseObject: id, user_id, created_at, updated_at,
    deleted_at, source_type, source_id, metadata
    """

    __tablename__ = "integrations"

    # Integration Identity
    integration_type = Column(
        String(50),
        nullable=False,
        index=True,
        doc="Type of external service (instagram, gmail, etc.)"
    )
    integration_name = Column(
        String(200),
        nullable=False,
        doc="User-friendly name for this integration"
    )

    # Status
    status = Column(
        SQLEnum(
            'pending', 'connected', 'disconnected', 'error', 'expired',
            name='integration_status_enum'
        ),
        nullable=False,
        default='pending',
        index=True,
        doc="Current state of integration"
    )

    # OAuth2 Token Management
    token_expires_at = Column(
        DateTime(timezone=True),
        nullable=True,
        doc="When access token expires"
    )
    last_token_refresh_at = Column(
        DateTime(timezone=True),
        nullable=True,
        doc="When token was last refreshed"
    )

    # Sync State Tracking
    last_sync_at = Column(
        DateTime(timezone=True),
        nullable=True,
        doc="Most recent sync timestamp"
    )
    last_sync_status = Column(
        SQLEnum('success', 'partial', 'failed', name='sync_status_enum'),
        nullable=True,
        doc="Result of most recent sync"
    )
    last_sync_error = Column(
        Text,
        nullable=True,
        doc="Error message from last failed sync"
    )
    sync_cursor = Column(
        Text,
        nullable=True,
        doc="Pagination cursor for incremental sync"
    )
    items_synced = Column(
        Integer,
        nullable=False,
        default=0,
        doc="Total items successfully imported"
    )
    items_failed = Column(
        Integer,
        nullable=False,
        default=0,
        doc="Total items that failed to import"
    )

    # Configuration
    is_enabled = Column(
        Boolean,
        nullable=False,
        default=True,
        index=True,
        doc="Whether automatic syncing is enabled"
    )
    auto_sync = Column(
        Boolean,
        nullable=False,
        default=True,
        doc="Whether to automatically trigger periodic syncs"
    )
    sync_frequency = Column(
        SQLEnum(
            'realtime', 'every_15min', 'hourly', 'daily', 'weekly', 'manual',
            name='sync_frequency_enum'
        ),
        nullable=False,
        default='hourly',
        doc="How often to automatically sync"
    )

    # Relationships
    owner = relationship(
        "User",
        foreign_keys=[BaseObject.user_id],
        back_populates="integrations",
        doc="User who owns this integration"
    )
    sourced_media = relationship(
        "Link",
        foreign_keys="Link.to_object_id",
        primaryjoin="and_(Link.to_object_id==Integration.id, "
                    "Link.link_type=='source')",
        doc="Media objects sourced from this integration"
    )

    # Table Constraints
    __table_args__ = (
        CheckConstraint(
            "items_synced >= 0",
            name="check_items_synced_positive"
        ),
        CheckConstraint(
            "items_failed >= 0",
            name="check_items_failed_positive"
        ),
        # Composite indexes
        Index('idx_integration_user_type', 'user_id', 'integration_type'),
        Index('idx_integration_status_enabled', 'status', 'is_enabled'),
        Index('idx_integration_next_sync',
              'is_enabled', 'auto_sync', 'last_sync_at',
              postgresql_where="status='connected' AND is_enabled=true"),
    )

    def __repr__(self):
        return f"<Integration(id={self.id}, type={self.integration_type}, " \
               f"user={self.user_id}, status={self.status})>"

    @property
    def is_connected(self):
        """Check if integration is currently connected"""
        return self.status == 'connected'

    @property
    def needs_token_refresh(self):
        """Check if token needs refreshing"""
        if not self.token_expires_at:
            return False
        # Refresh 5 minutes before expiry
        from datetime import timedelta
        threshold = datetime.utcnow() + timedelta(minutes=5)
        return self.token_expires_at <= threshold

    @property
    def sync_success_rate(self):
        """Calculate sync success rate"""
        total = self.items_synced + self.items_failed
        if total == 0:
            return 0.0
        return (self.items_synced / total) * 100

    def mark_sync_started(self):
        """Mark sync as started"""
        self.last_sync_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()

    def mark_sync_complete(self, status, items_synced=0, items_failed=0, error=None):
        """Mark sync as complete with results"""
        self.last_sync_status = status
        self.items_synced += items_synced
        self.items_failed += items_failed
        if error:
            self.last_sync_error = str(error)
        self.updated_at = datetime.utcnow()

    def update_sync_cursor(self, cursor):
        """Update pagination cursor for incremental sync"""
        self.sync_cursor = cursor
        self.updated_at = datetime.utcnow()
```

---

## Privacy and Security Considerations

### Token Storage

1. **Never Store Plaintext Tokens**
   - Access tokens and refresh tokens stored as SHA-256 hashes
   - Actual tokens encrypted at rest using AES-256
   - Tokens never returned in API responses
   - Tokens never logged

2. **Token Encryption**
   ```python
   from cryptography.fernet import Fernet

   def encrypt_token(token: str, key: bytes) -> str:
       f = Fernet(key)
       return f.encrypt(token.encode()).decode()

   def decrypt_token(encrypted: str, key: bytes) -> str:
       f = Fernet(key)
       return f.decrypt(encrypted.encode()).decode()
   ```

3. **Token Rotation**
   - Refresh tokens automatically before expiry
   - Revoke old tokens after successful refresh
   - Manual token rotation available via admin API

### OAuth2 Security

1. **CSRF Protection**
   - State parameter generated per OAuth flow
   - State stored in secure session
   - State verified on callback

2. **PKCE (Proof Key for Code Exchange)**
   - Used for all OAuth2 flows when supported
   - Code verifier generated client-side
   - Code challenge sent to authorization server

3. **Scope Minimization**
   - Request only necessary permissions
   - User shown exact permissions requested
   - Scopes stored in metadata for audit

### Data Protection

1. **Imported Data Ownership**
   - All imported data owned by user
   - Integration deletion can optionally delete imported data
   - Data not shared with other users without explicit permission

2. **Rate Limiting**
   - Protect external services from abuse
   - Per-integration rate limits
   - Per-user aggregate rate limits
   - Backoff on rate limit errors

3. **Audit Trail**
   - All sync operations logged
   - OAuth events logged
   - Token refresh logged
   - Integration disconnection logged

---

## Validation Rules

### On Creation

```yaml
integration_type:
  - Must be in allowed list
  - Must be lowercase
  - Maximum 50 characters

integration_name:
  - Minimum 1 character
  - Maximum 200 characters
  - Defaults to "{integration_type} Account"

status:
  - Must be "pending" on creation
  - Changed to "connected" after OAuth completion

user_id:
  - Must reference existing User
  - User must be verified (is_verified=true)
```

### On Update

```yaml
immutable_fields:
  - id
  - user_id
  - integration_type
  - created_at

mutable_fields:
  - integration_name
  - is_enabled
  - auto_sync
  - sync_frequency
  - metadata

system_managed:
  - status (via OAuth flow or sync errors)
  - token_expires_at (via token refresh)
  - last_sync_at (via sync operations)
  - items_synced (via sync operations)
```

### Database Constraints

```sql
-- Check constraints
CHECK (status IN ('pending', 'connected', 'disconnected', 'error', 'expired'))
CHECK (last_sync_status IS NULL OR last_sync_status IN ('success', 'partial', 'failed'))
CHECK (items_synced >= 0)
CHECK (items_failed >= 0)

-- Indexes
CREATE INDEX idx_integration_user_type ON integrations(user_id, integration_type);
CREATE INDEX idx_integration_status ON integrations(status, is_enabled);
CREATE INDEX idx_integration_next_sync ON integrations(is_enabled, auto_sync, last_sync_at)
  WHERE status = 'connected' AND is_enabled = true;
CREATE INDEX idx_integration_deleted ON integrations(deleted_at)
  WHERE deleted_at IS NOT NULL;
```

---

## Use Cases and Examples

### Example 1: Instagram Integration

```json
{
  "id": "int-550e8400-e29b-41d4-a716-446655440000",
  "user_id": "user-123-uuid",
  "integration_type": "instagram",
  "integration_name": "My Personal Instagram",
  "status": "connected",
  "token_expires_at": "2026-02-09T13:00:00Z",
  "last_token_refresh_at": "2026-02-09T11:00:00Z",
  "last_sync_at": "2026-02-09T11:30:00Z",
  "last_sync_status": "success",
  "last_sync_error": null,
  "sync_cursor": "AQHWyNwCwT7NHJmUzFsU...",
  "items_synced": 1543,
  "items_failed": 2,
  "is_enabled": true,
  "auto_sync": true,
  "sync_frequency": "hourly",
  "metadata": {
    "service": {
      "instagram": {
        "user_id": "17841405793187218",
        "username": "user123",
        "account_type": "personal",
        "media_count": 892
      }
    },
    "sync_config": {
      "import_likes": true,
      "import_comments": true,
      "create_albums": true
    },
    "statistics": {
      "photos_synced": 1456,
      "videos_synced": 87,
      "total_bytes": 8589934592
    }
  },
  "created_at": "2024-06-15T10:00:00Z",
  "updated_at": "2026-02-09T11:30:00Z",
  "deleted_at": null
}
```

### Example 2: Google Photos Integration

```json
{
  "id": "int-550e8400-e29b-41d4-a716-446655440001",
  "user_id": "user-123-uuid",
  "integration_type": "google_photos",
  "integration_name": "Google Photos",
  "status": "connected",
  "token_expires_at": "2026-02-09T12:00:00Z",
  "last_sync_at": "2026-02-09T06:00:00Z",
  "last_sync_status": "success",
  "sync_cursor": "page_token_xyz",
  "items_synced": 8943,
  "items_failed": 15,
  "is_enabled": true,
  "auto_sync": true,
  "sync_frequency": "daily",
  "metadata": {
    "service": {
      "google": {
        "email": "user@gmail.com",
        "name": "John Doe"
      }
    },
    "sync_config": {
      "download_originals": true,
      "ignore_before": "2015-01-01T00:00:00Z"
    }
  },
  "created_at": "2024-01-15T08:00:00Z",
  "updated_at": "2026-02-09T06:30:00Z",
  "deleted_at": null
}
```

### Example 3: Disconnected Gmail Integration

```json
{
  "id": "int-550e8400-e29b-41d4-a716-446655440002",
  "user_id": "user-123-uuid",
  "integration_type": "gmail",
  "integration_name": "Work Gmail",
  "status": "disconnected",
  "token_expires_at": null,
  "last_sync_at": "2025-12-01T10:00:00Z",
  "last_sync_status": "success",
  "items_synced": 5432,
  "items_failed": 8,
  "is_enabled": false,
  "auto_sync": false,
  "sync_frequency": "manual",
  "metadata": {
    "service": {
      "google": {
        "email": "work@company.com"
      }
    },
    "disconnect_reason": "user_requested",
    "disconnect_timestamp": "2026-01-01T00:00:00Z"
  },
  "created_at": "2024-03-01T09:00:00Z",
  "updated_at": "2026-01-01T00:00:00Z",
  "deleted_at": "2026-01-01T00:00:00Z"
}
```

---

## Lifecycle States

Integrations progress through the following states:

### 1. Pending (OAuth Initiated)

```yaml
state: "pending"
status: "pending"
capabilities:
  - OAuth flow in progress
  - No syncing possible
  - Token fields null
transitions:
  - oauth_complete -> Connected
  - timeout (1 hour) -> Auto-deleted
```

### 2. Connected (Active)

```yaml
state: "connected"
status: "connected"
is_enabled: true
capabilities:
  - Full syncing enabled
  - Auto-sync scheduled
  - Token refresh automatic
transitions:
  - disconnect -> Disconnected
  - auth_error -> Error
  - token_expired -> Expired
```

### 3. Error (Temporary Failure)

```yaml
state: "error"
status: "error"
capabilities:
  - Syncing paused
  - User notified of error
  - Manual reconnection available
transitions:
  - reconnect -> Connected
  - disconnect -> Disconnected
  - timeout (7 days) -> Disconnected
```

### 4. Expired (Token Refresh Failed)

```yaml
state: "expired"
status: "expired"
capabilities:
  - Token refresh failed
  - Re-authorization required
  - Historical data preserved
transitions:
  - reauthorize -> Connected
  - disconnect -> Disconnected
```

### 5. Disconnected (User Disabled)

```yaml
state: "disconnected"
status: "disconnected"
deleted_at: set
capabilities:
  - No syncing
  - Historical data preserved (unless deleted)
  - Can reconnect
transitions:
  - reconnect -> Connected
  - hard_delete -> Permanently Removed
```

---

## Notes for Implementers

### Sync Implementation Pattern

```python
async def sync_integration(integration_id: UUID):
    """Generic sync pattern for all integration types"""
    integration = get_integration(integration_id)

    # Pre-sync checks
    if not integration.is_connected:
        raise IntegrationNotConnected()
    if not integration.is_enabled:
        raise IntegrationDisabled()
    if integration.needs_token_refresh:
        await refresh_token(integration)

    # Mark sync started
    integration.mark_sync_started()

    try:
        # Get platform-specific sync handler
        handler = get_sync_handler(integration.integration_type)

        # Perform sync
        result = await handler.sync(
            integration=integration,
            cursor=integration.sync_cursor
        )

        # Update integration
        integration.mark_sync_complete(
            status='success',
            items_synced=result.items_synced,
            items_failed=result.items_failed
        )
        integration.update_sync_cursor(result.next_cursor)

    except RateLimitError as e:
        # Backoff and retry
        integration.mark_sync_complete(status='partial', error=str(e))
        schedule_retry(integration_id, delay=e.retry_after)

    except AuthenticationError as e:
        # Mark as error, notify user
        integration.status = 'error'
        integration.last_sync_error = str(e)
        notify_user(integration.user_id, 'integration_error', integration.id)
```

### Token Refresh Pattern

```python
async def refresh_token(integration: Integration):
    """Refresh OAuth2 access token"""
    # Get provider config
    provider = get_oauth_provider(integration.integration_type)

    # Decrypt refresh token
    refresh_token = decrypt_token(
        integration.metadata['oauth']['refresh_token_hash'],
        key=get_encryption_key()
    )

    # Request new token
    response = await provider.refresh_token(refresh_token)

    # Update integration
    integration.token_expires_at = response.expires_at
    integration.last_token_refresh_at = datetime.utcnow()

    # Store new tokens securely
    integration.metadata['oauth']['access_token_hash'] = hash_token(response.access_token)
    if response.refresh_token:
        integration.metadata['oauth']['refresh_token_hash'] = hash_token(response.refresh_token)
```

### Background Job Scheduling

```python
# Schedule auto-sync jobs based on frequency
@scheduler.task('cron', hour='*', minute='0')
async def schedule_hourly_syncs():
    """Find integrations that need hourly sync"""
    integrations = get_integrations(
        status='connected',
        is_enabled=True,
        auto_sync=True,
        sync_frequency='hourly'
    )
    for integration in integrations:
        queue_sync_job(integration.id)

# Monitor token expiry
@scheduler.task('cron', minute='*/5')
async def refresh_expiring_tokens():
    """Refresh tokens expiring in next 5 minutes"""
    integrations = get_integrations_with_expiring_tokens(
        threshold=timedelta(minutes=5)
    )
    for integration in integrations:
        await refresh_token(integration)
```

---

**Status:** Active - Phase 1 Priority
**Version:** 1.0
**Authority:** 0.0.1 - Core Types
**Created:** 2026-02-09
**Owner:** Hypernet Core (0.*)
