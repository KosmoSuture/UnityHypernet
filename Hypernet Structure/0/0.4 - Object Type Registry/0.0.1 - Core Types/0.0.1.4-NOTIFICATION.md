---
ha: "0.4.0.1.4"
object_type: "document"
creator: "1.1"
created: "2026-02-09"
status: "active"
visibility: "public"
flags: ["registry"]
---

# NOTIFICATION - User Notification Object Type

**Type ID:** `hypernet.core.notification`
**Version:** 1.0
**Category:** 0.0.1 - Core Types
**Parent:** BaseObject
**Status:** Active
**Created:** 2026-02-09
**Last Updated:** 2026-02-09

---

## Object Type Metadata

```yaml
type_name: "Notification"
type_id: "hypernet.core.notification"
version: "1.0"
parent_type: "BaseObject"
category: "0.0.1 - Core Types"
abstract: false
instantiable: true
```

---

## Purpose and Description

### What is a Notification?

A Notification is a message to a user about an event, status change, or action that requires their attention. Notifications inform users about sync progress, integration errors, AI discoveries, system updates, and user actions. They are the primary communication channel between Hypernet and its users.

### Core Functions

1. **User Communication** - Alert users to important events and status changes
2. **Integration Status** - Report sync progress, errors, and completions
3. **AI Insights** - Share AI discoveries, recommendations, and analysis
4. **System Updates** - Announce new features, maintenance, security issues
5. **Action Prompts** - Request user decisions or confirmations
6. **Audit Trail** - Record of all communications to user

### Why This Matters

Without a unified notification system:
- Users miss important events (sync failures, quota limits)
- Integration errors go unnoticed
- AI insights are lost
- User experience is fragmented across channels

With Notifications, Hypernet provides:
- Centralized communication hub
- Multi-channel delivery (in-app, email, push)
- Priority and category management
- Read/unread tracking
- Action links and deep links

### When to Use

- Integration sync completes or fails
- AI discovers duplicates or relationships
- Storage quota approaching limit
- Security alert (new login, password change)
- Feature announcement
- Collaboration invitation
- Any event requiring user awareness

---

## Inherited Fields from BaseObject

```yaml
id: UUID
  - Unique notification identifier

user_id: UUID
  - Recipient of this notification
  - User who should see this message

created_at: DateTime
  - When notification was created
  - Used for chronological ordering

updated_at: DateTime
  - Last modification timestamp
  - Updated when read/unread status changes

deleted_at: DateTime (nullable)
  - Soft delete for dismissed notifications
  - Preserves notification history

source_type: String
  - What generated this notification
  - "system", "integration", "ai", "user"

source_id: String
  - ID of source object (optional)
  - Integration ID, AI task ID, etc.

metadata: JSONB
  - Notification-specific data
  - Action links, context, formatting
```

---

## Required Fields

### Notification Content

```yaml
notification_type: String(50)
  type: String
  max_length: 50
  nullable: false
  indexed: true
  description: "Type/category of notification"
  allowed_values:
    # Integration Events
    - "sync_started": Sync operation initiated
    - "sync_completed": Sync finished successfully
    - "sync_failed": Sync encountered errors
    - "sync_partial": Sync partially completed
    - "integration_connected": New integration added
    - "integration_error": Integration authentication failed
    - "integration_disconnected": Integration removed

    # AI Events
    - "ai_discovery": AI found duplicates, relationships
    - "ai_recommendation": AI suggests action
    - "ai_analysis_complete": AI analysis finished
    - "ai_insight": AI shares insight about user's data

    # System Events
    - "storage_warning": Approaching storage quota
    - "storage_full": Storage quota exceeded
    - "feature_announcement": New feature available
    - "maintenance_scheduled": Upcoming maintenance
    - "system_update": System upgrade completed

    # Security Events
    - "login_new_device": Login from unrecognized device
    - "password_changed": Password was changed
    - "api_key_created": New API key generated
    - "suspicious_activity": Potential security issue

    # User Events
    - "collaboration_invite": Invited to collaborate
    - "share_received": Someone shared content
    - "comment_added": Comment on user's content
    - "mention": User mentioned in content

    # Account Events
    - "welcome": New user onboarding
    - "verification_required": Email verification needed
    - "subscription_expiring": Subscription renewal due
    - "account_suspended": Account suspended
  purpose: "Enable filtering, routing, and priority assignment"

title: String(200)
  type: String
  max_length: 200
  nullable: false
  description: "Short notification title/subject"
  examples:
    - "Instagram Sync Complete"
    - "Storage Quota at 90%"
    - "AI Found 15 Duplicate Photos"
    - "Login from New Device"
  constraints:
    - Minimum 1 character
    - Maximum 200 characters
    - Should be concise and actionable

message: Text
  type: Text
  nullable: false
  description: "Full notification message body"
  format: "Plain text or markdown"
  examples:
    - "Successfully synced 25 new photos from your Instagram account."
    - "Your storage is at 90% capacity (45 GB of 50 GB used). Consider upgrading or deleting unused files."
    - "AI detected 15 potential duplicate photos. Review and merge?"
  constraints:
    - Minimum 1 character
    - Maximum 5000 characters
    - Should provide context and actionable information

priority: Enum
  type: String
  max_length: 20
  nullable: false
  indexed: true
  default: "normal"
  description: "Urgency level of notification"
  allowed_values:
    - "low": Informational, no urgency
    - "normal": Standard notification
    - "high": Important, requires attention
    - "urgent": Critical, immediate action needed
  examples:
    - low: Feature announcement, AI insight
    - normal: Sync completed, new content shared
    - high: Storage warning, integration error
    - urgent: Security alert, account suspended
  purpose: "Determine notification presentation and delivery"
```

---

## Optional Fields

### Status and Tracking

```yaml
is_read: Boolean
  type: Boolean
  nullable: false
  default: false
  indexed: true
  description: "Whether user has read this notification"
  transitions:
    - false -> true: User opens notification
    - true -> false: User marks as unread (rare)
  purpose: "Show unread badge count, filter unread notifications"

read_at: DateTime
  type: DateTime
  nullable: true
  timezone: true (UTC)
  description: "When user marked notification as read"
  updated: "When is_read changes to true"
  purpose: "Track engagement, calculate read rates"

is_dismissed: Boolean
  type: Boolean
  nullable: false
  default: false
  indexed: true
  description: "Whether user dismissed this notification"
  purpose: "Hide from notification list without deleting"
  note: "Dismissed notifications still queryable for history"

dismissed_at: DateTime
  type: DateTime
  nullable: true
  timezone: true (UTC)
  description: "When user dismissed notification"
```

### Delivery Management

```yaml
delivery_channels: JSONB
  type: JSONB
  nullable: false
  default: ["in_app"]
  description: "Where notification should be delivered"
  allowed_values:
    - "in_app": Notification center in Hypernet UI
    - "email": Send email to user
    - "push": Push notification (web/mobile)
    - "sms": SMS message (high priority only)
    - "webhook": Webhook to external service
  examples:
    - ["in_app"]: Standard notification
    - ["in_app", "email"]: Important notification
    - ["in_app", "email", "push"]: Urgent notification
  constraints:
    - Must include at least "in_app"
    - Actual delivery respects user preferences

delivered_at: JSONB
  type: JSONB
  nullable: false
  default: {}
  description: "Delivery timestamps per channel"
  structure:
    {
      "in_app": "2026-02-09T10:00:00Z",
      "email": "2026-02-09T10:01:30Z",
      "push": "2026-02-09T10:00:15Z"
    }
  purpose: "Track delivery status and timing"

delivery_errors: JSONB
  type: JSONB
  nullable: false
  default: {}
  description: "Errors encountered during delivery"
  structure:
    {
      "email": {
        "error": "SMTP server unavailable",
        "attempted_at": "2026-02-09T10:01:30Z",
        "retry_count": 2
      }
    }
```

### Action and Context

```yaml
action_url: String(500)
  type: String
  max_length: 500
  nullable: true
  description: "Deep link URL for primary action"
  format: "Absolute or relative URL"
  examples:
    - "/integrations/integration-uuid": View integration
    - "/media/duplicates": Review duplicates
    - "/settings/storage": Manage storage
    - "https://hypernet.io/feature/xyz": External link
  purpose: "Enable click-through from notification"

action_label: String(100)
  type: String
  max_length: 100
  nullable: true
  description: "Label for primary action button"
  examples:
    - "View Details"
    - "Review Duplicates"
    - "Upgrade Storage"
    - "Learn More"
  constraints:
    - Required if action_url is set

related_object_id: UUID
  type: UUID
  nullable: true
  indexed: true
  description: "ID of related object (if applicable)"
  examples:
    - Integration ID for sync notifications
    - Photo ID for duplicate notifications
    - User ID for collaboration invites
  purpose: "Link notification to relevant object"

related_object_type: String(50)
  type: String
  max_length: 50
  nullable: true
  indexed: true
  description: "Type of related object"
  examples:
    - "Integration"
    - "Photo"
    - "Album"
    - "User"

expires_at: DateTime
  type: DateTime
  nullable: true
  timezone: true (UTC)
  description: "When notification should expire and auto-dismiss"
  examples:
    - Feature announcement: 30 days from creation
    - Sync status: 7 days from creation
    - Urgent alert: Never expires (null)
  purpose: "Auto-cleanup old notifications"
```

---

## Metadata Schema

The `metadata` JSONB field stores notification-specific data:

```json
{
  "sync": {
    "integration_id": "integration-uuid",
    "integration_name": "My Instagram",
    "integration_type": "instagram",
    "items_synced": 25,
    "items_failed": 0,
    "duration_seconds": 45,
    "next_sync_at": "2026-02-09T12:00:00Z"
  },
  "ai_discovery": {
    "discovery_type": "duplicates",
    "count": 15,
    "confidence": 0.95,
    "review_url": "/media/duplicates",
    "estimated_storage_savings": "250 MB"
  },
  "storage": {
    "used_bytes": 48318382080,
    "quota_bytes": 53687091200,
    "percent_used": 90,
    "growth_rate_mb_per_day": 50,
    "estimated_full_date": "2026-03-01"
  },
  "security": {
    "event_type": "login",
    "device": {
      "type": "desktop",
      "os": "Windows 11",
      "browser": "Chrome 122",
      "ip_address": "192.168.1.100",
      "location": "San Francisco, CA"
    },
    "is_recognized": false
  },
  "formatting": {
    "icon": "check-circle",
    "color": "success",
    "avatar_url": "https://...",
    "thumbnail_url": "https://..."
  },
  "actions": [
    {
      "label": "View Integration",
      "url": "/integrations/integration-uuid",
      "style": "primary"
    },
    {
      "label": "Dismiss",
      "action": "dismiss",
      "style": "secondary"
    }
  ],
  "analytics": {
    "campaign_id": "feature_launch_2026_02",
    "segment": "power_users",
    "ab_test_variant": "A"
  }
}
```

---

## Relationships to Other Object Types

### Recipient (Incoming)

```yaml
received_by: User
  description: "User who receives this notification"
  cardinality: "N:1 (many notifications, one user)"
  implementation: "user_id foreign key"
  constraints:
    - User must exist
    - Cannot be null

related_to: Any Object Type
  description: "Object this notification is about"
  cardinality: "N:0..1 (many notifications, optional object)"
  implementation: "related_object_id + related_object_type"
  examples:
    - Notification about Integration sync
    - Notification about Photo duplicate
    - Notification about Album share
```

---

## API Endpoints

### Notification Management

```http
GET /api/v1/notifications
  Description: Get notifications for authenticated user
  Query Parameters:
    is_read: boolean - filter by read status
    is_dismissed: boolean - filter by dismissed status
    notification_type: string - filter by type
    priority: string - filter by priority
    since: datetime - notifications after this time
    limit: integer (default 50, max 100)
    offset: integer (default 0)
  Response: 200 OK
    {
      "items": [{notification}, {notification}, ...],
      "total": 150,
      "unread_count": 12,
      "limit": 50,
      "offset": 0
    }
  Default Behavior:
    - Excludes dismissed notifications
    - Excludes expired notifications
    - Sorted by created_at DESC (newest first)

GET /api/v1/notifications/unread
  Description: Get only unread notifications
  Response: 200 OK
    {
      "items": [{notification}, ...],
      "count": 12
    }
  Purpose: Display unread badge count

GET /api/v1/notifications/{id}
  Description: Get single notification
  Path Parameters:
    id: UUID (required) - notification ID
  Response: 200 OK
    {notification object}
  Side Effect:
    - If is_read=false, marks as read automatically
  Security:
    - User must be notification recipient

PATCH /api/v1/notifications/{id}
  Description: Update notification status
  Path Parameters:
    id: UUID (required) - notification ID
  Request Body:
    {
      "is_read": true,
      "is_dismissed": true
    }
  Response: 200 OK
    {updated notification object}
  Validation:
    - Can only change: is_read, is_dismissed
    - Cannot change content or metadata
  Security:
    - User must be notification recipient

DELETE /api/v1/notifications/{id}
  Description: Delete notification (soft delete)
  Path Parameters:
    id: UUID (required) - notification ID
  Response: 204 No Content
  Purpose: Permanent removal from notification list
  Security:
    - User must be notification recipient
```

### Bulk Operations

```http
POST /api/v1/notifications/mark-all-read
  Description: Mark all notifications as read
  Query Parameters:
    notification_type: string - only mark specific type
  Response: 200 OK
    {
      "marked_count": 12
    }
  Purpose: "Mark all as read" button

POST /api/v1/notifications/dismiss-all
  Description: Dismiss all notifications
  Query Parameters:
    notification_type: string - only dismiss specific type
    before: datetime - only dismiss before this time
  Response: 200 OK
    {
      "dismissed_count": 25
    }
  Purpose: Clear notification center

DELETE /api/v1/notifications/cleanup
  Description: Delete all dismissed or expired notifications
  Response: 200 OK
    {
      "deleted_count": 50
    }
  Purpose: Periodic cleanup of old notifications
```

### Notification Preferences

```http
GET /api/v1/users/me/notification-preferences
  Description: Get user's notification preferences
  Response: 200 OK
    {
      "channels": {
        "in_app": true,
        "email": true,
        "push": false,
        "sms": false
      },
      "types": {
        "sync_completed": ["in_app"],
        "sync_failed": ["in_app", "email"],
        "ai_discovery": ["in_app"],
        "storage_warning": ["in_app", "email"],
        "security_alert": ["in_app", "email", "push"]
      },
      "quiet_hours": {
        "enabled": true,
        "start": "22:00",
        "end": "08:00",
        "timezone": "America/Los_Angeles"
      }
    }

PATCH /api/v1/users/me/notification-preferences
  Description: Update notification preferences
  Request Body:
    {
      "channels": {
        "email": false
      },
      "types": {
        "sync_completed": ["in_app"]
      }
    }
  Response: 200 OK
    {updated preferences}
```

### System Operations (Internal/Admin)

```http
POST /api/v1/notifications/send
  Description: Create and send notification (internal)
  Headers:
    Authorization: Bearer {system_token}
  Request Body:
    {
      "user_id": "user-uuid",
      "notification_type": "sync_completed",
      "title": "Instagram Sync Complete",
      "message": "Successfully synced 25 new photos.",
      "priority": "normal",
      "delivery_channels": ["in_app", "email"],
      "action_url": "/integrations/integration-uuid",
      "action_label": "View Details",
      "related_object_id": "integration-uuid",
      "related_object_type": "Integration",
      "metadata": {...}
    }
  Response: 201 Created
    {notification object}
  Purpose: System-generated notifications
  Security:
    - Requires system/admin authentication

POST /api/v1/notifications/broadcast
  Description: Send notification to multiple users
  Headers:
    Authorization: Bearer {admin_token}
  Request Body:
    {
      "user_ids": ["user-1", "user-2", "user-3"],
      "notification_type": "feature_announcement",
      "title": "New Feature: AI Duplicate Detection",
      "message": "...",
      "priority": "low",
      "expires_at": "2026-03-09T00:00:00Z"
    }
  Response: 201 Created
    {
      "notifications_created": 3,
      "notification_ids": ["notif-1", "notif-2", "notif-3"]
    }
  Purpose: Broadcast announcements
  Security:
    - Admin only
```

---

## Database Schema (SQLAlchemy Model Reference)

```python
from sqlalchemy import (
    Column, String, Boolean, Text,
    DateTime, Enum as SQLEnum, ForeignKey, Index, CheckConstraint
)
from sqlalchemy.dialects.postgresql import UUID, JSONB, ARRAY
from sqlalchemy.orm import relationship
from app.models.base import BaseObject
from datetime import datetime

class Notification(BaseObject):
    """
    User notification about events, status, or actions

    Inherits from BaseObject: id, user_id, created_at, updated_at,
    deleted_at, source_type, source_id, metadata
    """

    __tablename__ = "notifications"

    # Notification Content
    notification_type = Column(
        String(50),
        nullable=False,
        index=True,
        doc="Type/category of notification"
    )
    title = Column(
        String(200),
        nullable=False,
        doc="Short notification title"
    )
    message = Column(
        Text,
        nullable=False,
        doc="Full notification message body"
    )
    priority = Column(
        SQLEnum('low', 'normal', 'high', 'urgent', name='notification_priority_enum'),
        nullable=False,
        default='normal',
        index=True,
        doc="Urgency level"
    )

    # Status and Tracking
    is_read = Column(
        Boolean,
        nullable=False,
        default=False,
        index=True,
        doc="Whether user has read this"
    )
    read_at = Column(
        DateTime(timezone=True),
        nullable=True,
        doc="When marked as read"
    )
    is_dismissed = Column(
        Boolean,
        nullable=False,
        default=False,
        index=True,
        doc="Whether user dismissed this"
    )
    dismissed_at = Column(
        DateTime(timezone=True),
        nullable=True,
        doc="When dismissed"
    )

    # Delivery Management
    delivery_channels = Column(
        JSONB,
        nullable=False,
        default=["in_app"],
        doc="Where to deliver notification"
    )
    delivered_at = Column(
        JSONB,
        nullable=False,
        default={},
        doc="Delivery timestamps per channel"
    )
    delivery_errors = Column(
        JSONB,
        nullable=False,
        default={},
        doc="Delivery errors per channel"
    )

    # Action and Context
    action_url = Column(
        String(500),
        nullable=True,
        doc="Deep link URL for action"
    )
    action_label = Column(
        String(100),
        nullable=True,
        doc="Label for action button"
    )
    related_object_id = Column(
        UUID(as_uuid=True),
        nullable=True,
        index=True,
        doc="ID of related object"
    )
    related_object_type = Column(
        String(50),
        nullable=True,
        index=True,
        doc="Type of related object"
    )
    expires_at = Column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        doc="When notification expires"
    )

    # Relationships
    recipient = relationship(
        "User",
        foreign_keys=[BaseObject.user_id],
        back_populates="notifications",
        doc="User who receives this notification"
    )

    # Table Constraints
    __table_args__ = (
        # action_label required if action_url set
        CheckConstraint(
            "action_url IS NULL OR action_label IS NOT NULL",
            name="check_action_label_with_url"
        ),
        # Composite indexes
        Index('idx_notification_user_read', 'user_id', 'is_read', 'created_at'),
        Index('idx_notification_user_type', 'user_id', 'notification_type'),
        Index('idx_notification_unread', 'user_id', 'is_read', 'priority',
              postgresql_where="is_read = false AND is_dismissed = false"),
        Index('idx_notification_expired', 'expires_at',
              postgresql_where="expires_at IS NOT NULL"),
        Index('idx_notification_related', 'related_object_id', 'related_object_type'),
    )

    def __repr__(self):
        return f"<Notification(id={self.id}, type={self.notification_type}, " \
               f"user={self.user_id}, read={self.is_read})>"

    @property
    def is_expired(self):
        """Check if notification has expired"""
        if not self.expires_at:
            return False
        return datetime.utcnow() >= self.expires_at

    @property
    def is_active(self):
        """Check if notification is active (not dismissed, not expired)"""
        return not self.is_dismissed and not self.is_expired

    def mark_as_read(self):
        """Mark notification as read"""
        if not self.is_read:
            self.is_read = True
            self.read_at = datetime.utcnow()
            self.updated_at = datetime.utcnow()

    def mark_as_unread(self):
        """Mark notification as unread"""
        if self.is_read:
            self.is_read = False
            self.read_at = None
            self.updated_at = datetime.utcnow()

    def dismiss(self):
        """Dismiss notification"""
        if not self.is_dismissed:
            self.is_dismissed = True
            self.dismissed_at = datetime.utcnow()
            self.updated_at = datetime.utcnow()

    def record_delivery(self, channel: str, success: bool, error: str = None):
        """Record delivery attempt"""
        if success:
            self.delivered_at[channel] = datetime.utcnow().isoformat()
        else:
            self.delivery_errors[channel] = {
                'error': error,
                'attempted_at': datetime.utcnow().isoformat()
            }
        self.updated_at = datetime.utcnow()

    @classmethod
    def create_notification(cls, user_id, notification_type, title, message,
                           priority='normal', **kwargs):
        """Factory method for creating notifications"""
        return cls(
            user_id=user_id,
            notification_type=notification_type,
            title=title,
            message=message,
            priority=priority,
            source_type=kwargs.pop('source_type', 'system'),
            **kwargs
        )
```

---

## Privacy and Security Considerations

### Access Control

1. **Notification Visibility**
   - Users can only see their own notifications
   - Admin cannot read user notifications (privacy)
   - System can create notifications for any user

2. **Sensitive Information**
   - Don't include passwords or tokens in messages
   - Don't expose other users' data
   - Careful with error messages (no system internals)

3. **Delivery Security**
   - Email delivery uses TLS
   - Push notifications encrypted
   - Webhook deliveries signed

### Data Protection

1. **Personal Information**
   - Notifications may contain PII
   - Respect user's notification preferences
   - Allow opt-out of all non-critical notifications

2. **Retention**
   - Auto-expire old notifications
   - User can delete notification history
   - Dismissed notifications eligible for cleanup

---

## Validation Rules

### On Creation

```yaml
user_id:
  - Must reference existing User
  - Cannot be null

notification_type:
  - Must be in allowed list
  - Maximum 50 characters

title:
  - Minimum 1 character
  - Maximum 200 characters

message:
  - Minimum 1 character
  - Maximum 5000 characters

priority:
  - Must be: low, normal, high, urgent
  - Defaults to normal

delivery_channels:
  - Must include at least "in_app"
  - Must be array of valid channel names

action_url and action_label:
  - If action_url set, action_label required
  - action_url maximum 500 characters
  - action_label maximum 100 characters
```

### Database Constraints

```sql
-- Check constraints
CHECK (action_url IS NULL OR action_label IS NOT NULL)
CHECK (LENGTH(title) > 0 AND LENGTH(title) <= 200)
CHECK (LENGTH(message) > 0)

-- Indexes
CREATE INDEX idx_notification_user_read ON notifications(user_id, is_read, created_at);
CREATE INDEX idx_notification_unread ON notifications(user_id, is_read, priority)
  WHERE is_read = false AND is_dismissed = false;
CREATE INDEX idx_notification_expired ON notifications(expires_at)
  WHERE expires_at IS NOT NULL;
CREATE INDEX idx_notification_related ON notifications(related_object_id, related_object_type);
```

---

## Use Cases and Examples

### Example 1: Sync Completion Notification

```json
{
  "id": "notif-550e8400-e29b-41d4-a716-446655440000",
  "user_id": "user-123-uuid",
  "notification_type": "sync_completed",
  "title": "Instagram Sync Complete",
  "message": "Successfully synced 25 new photos from your Instagram account 'My Personal Instagram'. All photos are now available in your Hypernet library.",
  "priority": "normal",
  "is_read": false,
  "read_at": null,
  "is_dismissed": false,
  "dismissed_at": null,
  "delivery_channels": ["in_app"],
  "delivered_at": {
    "in_app": "2026-02-09T10:00:00Z"
  },
  "delivery_errors": {},
  "action_url": "/integrations/integration-uuid",
  "action_label": "View Integration",
  "related_object_id": "integration-uuid",
  "related_object_type": "Integration",
  "expires_at": "2026-02-16T10:00:00Z",
  "metadata": {
    "sync": {
      "integration_name": "My Personal Instagram",
      "integration_type": "instagram",
      "items_synced": 25,
      "duration_seconds": 45
    }
  },
  "source_type": "integration",
  "source_id": "integration-uuid",
  "created_at": "2026-02-09T10:00:00Z",
  "updated_at": "2026-02-09T10:00:00Z",
  "deleted_at": null
}
```

### Example 2: Storage Warning (High Priority)

```json
{
  "id": "notif-550e8400-e29b-41d4-a716-446655440001",
  "user_id": "user-123-uuid",
  "notification_type": "storage_warning",
  "title": "Storage Quota at 90%",
  "message": "You're using 45 GB of your 50 GB storage quota (90%). At your current rate, you'll reach your limit in about 10 days. Consider upgrading your plan or managing your storage.",
  "priority": "high",
  "is_read": false,
  "is_dismissed": false,
  "delivery_channels": ["in_app", "email"],
  "delivered_at": {
    "in_app": "2026-02-09T10:00:00Z",
    "email": "2026-02-09T10:01:15Z"
  },
  "action_url": "/settings/storage",
  "action_label": "Manage Storage",
  "expires_at": null,
  "metadata": {
    "storage": {
      "used_bytes": 48318382080,
      "quota_bytes": 53687091200,
      "percent_used": 90,
      "estimated_full_date": "2026-02-19"
    }
  },
  "source_type": "system",
  "created_at": "2026-02-09T10:00:00Z",
  "updated_at": "2026-02-09T10:01:15Z",
  "deleted_at": null
}
```

### Example 3: AI Discovery Notification

```json
{
  "id": "notif-550e8400-e29b-41d4-a716-446655440002",
  "user_id": "user-123-uuid",
  "notification_type": "ai_discovery",
  "title": "AI Found 15 Duplicate Photos",
  "message": "AI analyzed your photo library and discovered 15 potential duplicate photos. Reviewing and merging these duplicates could free up approximately 250 MB of storage.",
  "priority": "low",
  "is_read": false,
  "is_dismissed": false,
  "delivery_channels": ["in_app"],
  "delivered_at": {
    "in_app": "2026-02-09T11:00:00Z"
  },
  "action_url": "/media/duplicates",
  "action_label": "Review Duplicates",
  "expires_at": "2026-03-09T00:00:00Z",
  "metadata": {
    "ai_discovery": {
      "discovery_type": "duplicates",
      "count": 15,
      "confidence": 0.95,
      "estimated_storage_savings": "250 MB"
    }
  },
  "source_type": "ai",
  "created_at": "2026-02-09T11:00:00Z",
  "updated_at": "2026-02-09T11:00:00Z",
  "deleted_at": null
}
```

### Example 4: Security Alert (Urgent)

```json
{
  "id": "notif-550e8400-e29b-41d4-a716-446655440003",
  "user_id": "user-123-uuid",
  "notification_type": "login_new_device",
  "title": "New Device Login Detected",
  "message": "Your account was accessed from a new device: Windows 11 desktop using Chrome from San Francisco, CA. If this wasn't you, please secure your account immediately.",
  "priority": "urgent",
  "is_read": false,
  "is_dismissed": false,
  "delivery_channels": ["in_app", "email", "push"],
  "delivered_at": {
    "in_app": "2026-02-09T14:00:00Z",
    "email": "2026-02-09T14:00:30Z",
    "push": "2026-02-09T14:00:10Z"
  },
  "action_url": "/settings/security",
  "action_label": "Review Activity",
  "expires_at": null,
  "metadata": {
    "security": {
      "event_type": "login",
      "device": {
        "type": "desktop",
        "os": "Windows 11",
        "browser": "Chrome 122",
        "ip_address": "192.168.1.100",
        "location": "San Francisco, CA"
      },
      "is_recognized": false
    }
  },
  "source_type": "system",
  "created_at": "2026-02-09T14:00:00Z",
  "updated_at": "2026-02-09T14:00:30Z",
  "deleted_at": null
}
```

---

## Lifecycle States

Notifications have a simple lifecycle:

### 1. Unread (Initial State)

```yaml
state: "unread"
is_read: false
is_dismissed: false
capabilities:
  - Shows in notification center with badge
  - Can be marked as read
  - Can be dismissed
transitions:
  - open -> Read
  - dismiss -> Dismissed
```

### 2. Read

```yaml
state: "read"
is_read: true
is_dismissed: false
capabilities:
  - Shows in notification center (no badge)
  - Can be marked as unread
  - Can be dismissed
transitions:
  - mark_unread -> Unread
  - dismiss -> Dismissed
```

### 3. Dismissed

```yaml
state: "dismissed"
is_dismissed: true
capabilities:
  - Hidden from notification center
  - Still queryable in history
  - Can be deleted
transitions:
  - delete -> Deleted
```

### 4. Expired

```yaml
state: "expired"
expires_at: past
capabilities:
  - Auto-dismissed if not already read
  - Hidden from notification center
  - Eligible for cleanup
transitions:
  - cleanup -> Deleted
```

### 5. Deleted

```yaml
state: "deleted"
deleted_at: not null
capabilities:
  - Soft deleted
  - Excluded from all queries
  - Can be hard deleted
```

---

## Notes for Implementers

### Notification Delivery Service

```python
class NotificationService:
    """Service for creating and delivering notifications"""

    async def send_notification(self, user_id: UUID, notification_type: str,
                                title: str, message: str, **kwargs):
        """Create and deliver notification"""
        # Create notification
        notification = Notification.create_notification(
            user_id=user_id,
            notification_type=notification_type,
            title=title,
            message=message,
            **kwargs
        )
        session.add(notification)
        session.commit()

        # Get user preferences
        preferences = get_user_notification_preferences(user_id)

        # Determine delivery channels
        channels = self._determine_channels(
            notification.priority,
            notification_type,
            preferences
        )

        # Deliver to each channel
        for channel in channels:
            try:
                await self._deliver_to_channel(notification, channel)
                notification.record_delivery(channel, success=True)
            except Exception as e:
                notification.record_delivery(channel, success=False, error=str(e))

        session.commit()
        return notification

    async def _deliver_to_channel(self, notification: Notification, channel: str):
        """Deliver notification to specific channel"""
        if channel == 'in_app':
            # Already in database, just flag
            pass
        elif channel == 'email':
            await send_email(
                to=notification.recipient.email,
                subject=notification.title,
                body=notification.message,
                action_url=notification.action_url
            )
        elif channel == 'push':
            await send_push_notification(
                user_id=notification.user_id,
                title=notification.title,
                body=notification.message,
                data={'notification_id': str(notification.id)}
            )

    def _determine_channels(self, priority: str, notification_type: str,
                          preferences: dict) -> list:
        """Determine delivery channels based on priority and preferences"""
        # Always include in-app
        channels = ['in_app']

        # Check user preferences
        type_prefs = preferences.get('types', {}).get(notification_type, [])

        # High and urgent priorities force email
        if priority in ['high', 'urgent']:
            channels.append('email')
            if priority == 'urgent':
                channels.append('push')

        # Add user-preferred channels
        for channel in type_prefs:
            if channel not in channels and preferences.get('channels', {}).get(channel, False):
                channels.append(channel)

        return channels
```

### Background Jobs

```python
# Cleanup expired notifications
@scheduler.task('cron', hour='2', minute='0')
async def cleanup_expired_notifications():
    """Auto-dismiss expired notifications"""
    expired = session.query(Notification).filter(
        Notification.expires_at < datetime.utcnow(),
        Notification.is_dismissed == False
    ).all()

    for notification in expired:
        notification.dismiss()

    session.commit()
    print(f"Dismissed {len(expired)} expired notifications")

# Delete old dismissed notifications (30 days)
@scheduler.task('cron', hour='3', minute='0')
async def delete_old_notifications():
    """Hard delete old dismissed notifications"""
    threshold = datetime.utcnow() - timedelta(days=30)

    deleted_count = session.query(Notification).filter(
        Notification.is_dismissed == True,
        Notification.dismissed_at < threshold
    ).delete()

    session.commit()
    print(f"Deleted {deleted_count} old notifications")
```

---

**Status:** Active
**Version:** 1.0
**Authority:** 0.0.1 - Core Types
**Created:** 2026-02-09
**Owner:** Hypernet Core (0.*)
